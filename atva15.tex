\documentclass{llncs}
\usepackage{makeidx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{latexsym}
\usepackage{url}
\usepackage{color}
\usepackage{isabelle}

\usepackage{isabellesym}
\usepackage{theorem}

%%%%%%%%%%%% For Isabelle code
\newlength{\fminilength}
\newsavebox{\fminibox}
\newenvironment{fmini}[1][\linewidth]
  {\setlength{\fminilength}{#1\fboxsep-2\fboxrule}%
   \vspace{2ex}\noindent\begin{lrbox}{\fminibox}\begin{minipage}{\fminilength}%
   \mbox{ }\hfill\vspace{-2.5ex}}%
  {\end{minipage}\end{lrbox}\vspace{1ex}\hspace{0ex}%
   \framebox{\usebox{\fminibox}}}

\newenvironment{specification}
{\noindent\scriptsize
\tt\begin{fmini}\begin{tabbing}X\=X12345\=XXXX\=XXXX\=XXXX\=XXXX\=XXXX
\=\+\kill} {\end{tabbing}\normalfont\end{fmini}}
%%%%%%%%%%%% For Isabelle code
\def \twoSpaces {\ \ }
\input{tcilatex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%for comments
\newcommand\JP[1]{\textcolor{magenta}{JP: #1}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%for hyper-ref
\usepackage[colorlinks,
            linkcolor=black,
            anchorcolor=black,
            citecolor=blue,
            urlcolor=black,
            bookmarks=true
            ]{hyperref}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%=========================================
\begin{document}
\title{A Novel Approach to  Parameterized Proofs for Cache Coherence Protocols}

\author{Yongjian Li\inst{1} \and
        Kaiqiang Duan \inst{1} \and
        Jun Pang\inst{2} \and
        William~N.~N.~Hung \inst{3} \and
        Xiaoyu~Song \inst{4}}
\institute{
%Laboratory for Computer Science \\
Institute of Software, Chinese Academy of Sciences \and
%Interdisciplinary Centre for Security, Reliability and Trust\\
University of Luxembourg \and
Synopsys Inc  \and
Portland State University
}


%=========================================

\maketitle

%-------------------------------------------------------------------------
\begin{abstract}
 The challenge posed by
parameterized verification of cache coherence protocols is that  safety properties, represented
in terms of invariants, of such protocols should hold for any
protocol instances, which is difficult to handle by only exploring
model-checking techniques. In this paper, we propose a novel
approach for parameterized verification by first proposing a general inductive model to formalize
the semantics of a cache coherence protocol. We then propose a
consistency theorem to prove a set of invariants for a protocol. The
importance of this lemma lies in that it divides the proof of the
invariants into a large number of subproofs, which mainly verify the
existence of typical casual relations between a protocol rule and an
invariant. This  decomposing strategy is  the key to automatically
generate the large number of sub-proofs with the help of theorem provers
because the proof patterns for the subgoals
are usually similar and modular. We proceed with showing how to automatically
generate a parameterized proof for the invariants w.r.t. a protocol
by generalizing the causal information which can be derived from a
small finite protocol instance. Finally, the application of our
approach is demonstrated on several typical benchmarks.
\end{abstract}
%-------------------------------------------------------------------------

%=========================================
\section{Introduction}
%=========================================
Verification of parameterized concurrent systems are both
interesting and challenging in the field of formal methods, mainly
due to the practical importance of such systems. Parameterized
systems like cache coherence protocols play a key role in modern
parallel or distributed computer systems. They require complex
algorithms that must deal with asynchrony, unpredictable message
delays, and multiple communication paths between many nodes.
Therefore, the highest possible assurance for the correctness of
these complex parameterized systems should be guaranteed by formal
reasoning techniques.

Formally speaking, let $P$ be a parameterized system and
 $P(N)$ denote its instance with the cardinality $N$.  $P(N)$ usually
consists of a small number (may be none) of heterogeneous processes,
together with a set of homogeneous processes $\{ P_i\, |\, 0 \le i \le N \}$.
When $N$ is small, verification of $P(N)$ w.r.t.\ some
invariants can be solved by applying model-checking techniques.
Due to high concurrency, a system with
only 4-5 nodes running, for example, a cache coherence protocol may have a huge number of
possible executions. In practice, such systems normally consist of hundred of nodes.
Moreover, we need to prove that the invariants hold in any
instance of the parameterized system. The challenge posed by
parameterized verification is that the correctness of a
system, limited to a fixed (very small) number of instances,
does not logically imply the correctness of the system of
arbitrary sizes.

%-------------------------------------------------------------------------
\medskip
\noindent{\bf Related work.}
%-------------------------------------------------------------------------
There have been a lot of research papers in the field of  parameterized verification.
Among them, the work~\cite{Pandav2005} is closely related to ours,
where a method combining inductive invariant
checking with a heuristic-based method for discovering invariants
was reported for parameterized verification of safety properties.
The heuristics are created by manual syntactic analysis of the
counterexamples generated during inductive invariant checking. These
heuristics are then manually used to construct and refine
invariants.
%
Parameter abstraction and guard strengthening are proposed in~\cite{Chou2004}.
An abstract model of a parameterized protocol
is constructed iteratively.
Normally the initial abstract system does not satisfy an
invariant. Nevertheless it is still submitted to a model
checker for verification. When a counterexample is produced, one needs to
carefully analyze it and comes up with an auxiliary invariant,
then uses it to strengthen the guards of some transition
rules of the abstract node. The `strengthened' system is then
subject to model checking again. This process stops until the
refined abstract system eventually satisfies the original invariant
as well as all the auxiliary invariants supplied by the
user. However, this method's soundness is only argued in an
informal way.
%To the best of our knowledge, no one has
%formally proved its correctness in a theorem prover.
This situation may be not ideal because its application domain for cache
coherence protocols  which demands the highest assurance for
correctness.
%
The `invisible invariants' method proposed in~\cite{Arons2001}
is an automatic technique for parameterized verification. In this
method, auxiliary invariants are computed for a finite system
instance to aid inductive invariant checking. Combining parameter
abstraction and guard strengthening with the idea of computing
invariants in a finite instance, Lv~et al.~\cite{Lv2007} use a small instance of a
parameterized protocol as a `reference model' to compute candidate
invariants. References to a specific
node in these candidate invariants are then abstracted away, and the
resulting formulas are used to strengthen guards of the transition
rules in the abstract node. Both works~\cite{Arons2001,Lv2007} attempt to automatically
find invariants. However, the invariants computed is
\emph{invisible} as they are represented, e.g., in
BDDs, which are difficult to understand.
%
Recently, Cubicle is developed for verifying safety properties
of parameterized systems~\cite{cubicle2011}. It model checks a
property by a symbolic backward reachability analysis on  states
represented by specific simple formulas, called cubes. Auxiliary
invariants in ground form can be inferred if the property holds,
otherwise a counter-example is represented as a trace. However, the
above invariants are insufficient to be used to derive a formal
proof in a theorem prover.

To the best of our knowledge, there does not exist a generic
mechanical theory formalized in a theorem prover to model
parameterized cache coherence protocols and prove their invariants.
 Besides, it is difficult to obtain auxiliary invariants in a proper form to
 give a rigorous proof. Usually auxiliary invariants are derived from a finite small
 reference protocol model, which is ground formula, not a parameterized formula.
 At last, we need not only
 invariants, but also a kind of causal relation between invariants and rules,
 which can be used to prove the invariants inductively.

%-------------------------------------------------------------------------
\medskip
\noindent{\bf Contributions.}
%-------------------------------------------------------------------------
We aim to bridge the gap in this field by studying parameterized
verification of cache coherence protocols in a theorem prover.
%
The main contribution of this paper is twofold. The first is to
the development a theoretical result to give a general model to formalize
parameterized cache coherence protocols and a general
proof principle to prove their invariants. The second is to
an empirical approach to automate our modeling and proof methods in
Isabelle.
%We briefly discuss the novelties of our work below:
%%
%\begin{itemize}
%\item We introduce an inductive definition for reachable states of a parameterized
%cache coherence protocol, which consists of a set of parameterized transition rules
%and initializing predicates. %This gives an accurate and formal
%%definition for the operational semantics of protocol execution. It
%%not only provides us a constructive derivation of a reachable state,
%%but also introduces an effective and rigorous technique of rule
%%induction to prove properties of the reachable state set.
%Here, the parameterized transition rules and initializing predicates are
%specified in a general modeling language, which is protocol
%independent.
%
%%\item In particular, we originate key proof techniques to prove an
%%invariant as shown in Fig.
%%\ref{mutualExclusionProt}. %%formally prove important invariants of the protocols.
%%One key proof technique $f$  is $\emph{invariant Strengthening}$. In
%%order to prove an invariant $f$, we need strengthen $f$ with a list
%%of auxially invariants such as $f_1$, ..., $f_n$.  Usually $f$
%%cannot be directly proved by induction, but $f \wedge f_1 ... \wedge
%%f_n$ can be done. In the view of induction proof method, with a list
%%of strengthened invariants, we can use a more powerful induction
%%hypothesis to prove the strengthened conclusion when we do the
%%induction proof step.
%
%\item Secondly, we originate a key technique which is the consistency lemma to
%prove that all the invariants hold for the parameterized system under consideration.
%The core of our consistency lemma is to
%prove that a consistent property holds between the set of all the
%invariants and all the rules.
%The consistency lemma itself is proved by
% induction for a general protocol model.
%Thus it eliminates the need of directly using the induction proof
%method again in ground case studies. It allows for focusing on  the
%causal relationship between transition rules of a protocol and its
%invariants, and it also allows for dividing the proof of the
%invariants to a series of subproofs to verify whether one of five
%kinds of casual relations holds for  a rule  and an invariant.
%  This strategy of `divide and
%  conquer' is the crux to make the series of sub-proofs
%  to be automatically generated because the proof patterns for the  subproofs  are similar
%  and modular. The consistency relationship
%  also shows the strong heuristics to
%automatically generate auxiliary invariants to prove the main
%invariant. Being different from previous studies, auxiliary
%invariants, which are automatically generated, are now visible to
%us. Namely, not only they have intuitive meanings, but also help us
%to understand the correspondence relation among all the invariants
%and rules.
%%It is the the correspondence among the invariants that can tell us the
%%mechanism of the protocol to guarantee the invariants step by step.
%
%\item Thirdly, we show key techniques which   automatically generate a
%parameterized proof for the invariants w.r.t. a protocol provided
%that we  have derived some necessary causal information from a small
%finite protocol instance. Notice that the former is parameterized,
%which usually contain an arbitrary parameter N, while the latter is
%ground. Key techniques include parameter mapping, mapping a
%parameterized proof on a case on some parameters on rule and
%invariant parameters to a ground causal relation, and modular and
%automatical way to implement  the mechanical parameterized proof in
%the theorem prover Isabelle. Isabelle's mechanism of {\sf locale}
%and {\sf interpretation} provide strong support for us to implement
% the proof generation.
%%\item Being different from  the automatical  methods of checking
%%invariants of parameterized system, our method focuses on the aiding
%%of the people to understand  the correctness of protocol design by
%%finding auxially invariants. In our points of proof view, the
%%auxialy should be visible to the designers of the protocol. Namely,
%%not only need we find these auxiarly invariants, but also need
%%understand the correspondence relation among them. The
%%correspondence among the invariants can tell us how the mechanism of
%%the protocol to guarantee the invariants step by step. There are two
%%categories of invariants we need: correspondence properties, and
%%mutual exclusion
%%properties. We will explain this in detail in later discussion. %Combination of
%
%%\item In our model, a parameterized rule is just a function from a
%%list of parameters to a rule. In Murphi language, a ruleset, which
%%is shown in Table ?, defines a parameterized rule. In our model, a
%%list 1..n is just the list of parameters. A cache protocol usually
%%consists a set of parameterized rules, and one or two parameter set.
%%Usually a set of rules are crated by instantiating the parameterized
%%rule to construct a protocol system.
%
%%\item We define symmetry of a protocol in our formal model, and relate it to the symmetry between
%%invariants. We prove the close correspondence between the two kinds
%%of symmetry. This result induces a  symmetric reduction methodology.
%%A protocol is symmetric if there is permutation between two rules of
%%the system. Correspondingly symmetry exist among state space of the
%%system, and symmetry reduction can be applied to verify the
%%symmetric invariants. For instance, in order to prove the invariant
%%$\forall i ~j.~  (i!=j) -> (n[i]=C ->!n[j]=C$, by symmetry
%%reduction, we only need prove $(n[1]=C ->!n[2]=C$. Symmetry
%%reduction can greatly alleviate the burden of our proof obligation.
%\end{itemize}
%
%Among the three contributions, the former two establish the
%theoretical foundation of our approach, and the third opens the way
%to automatically mechanize our approach.

%=========================================
\section{A simple cache coherence protocol}
\label{sec:informalAccounting}
%=========================================

Murphi is a high-level description language for
finite-state asynchronous concurrent systems. It adopts a guarded assignment style to model systems. Cache coherence protocols can naturally
 be modeled in such a style. %because they are finite-state in essence asynchronous concurrent systems.
 %In this part,  we use a
%Murphi-like language to give an informal accounting of cache
%coherence protocols. .
Below, we use an example
to illustrate how to use Murphi to model a cache coherence protocol.

%\begin{table}
\vspace{2mm}
\begin{specification}
NODE : 100;\\
\>VAR x : boolean;\ \
 state : enum \{I, T, C, E\};\ \
   n : array [NODE] of state; \\
  StartState Init  \\
\> x := true; ~~ for i : NODE do n[i] := I;
   endfor; end;\\ %\\
  ruleset i : NODE do\\
    rule try n[i] = I ==> n[i] := T;
 end;\\
%  ruleset i : NODE do\\
    rule crit n[i] = T\& x = true ==>  n[i] := C; x := false; end;\\

%  ruleset i : NODE do\\
 rule exit  n[i] = C ==>  n[i] := E;
   end;\\
%   ruleset i : NODE do\\
   rule idle   n[i] = E ==> n[i] := I;  x := true;
end; \\% \\
Invariant mutualExclusion \\
\>forall i : NODE do forall j : NODE do  (i!=j) -> (n[i]=C ->!
n[j]=C)
  endforall end;
\end{specification}
%\caption{A simple mutual exclusion protocol}
%\end{table}\label{mutualExclusionProt}

 A Murphi description consists of declarations of constants, types,
global variables; a collection of transition rules; a description of
the initial states; and a set of invariants. Usually the rules and
invariants are specified in a parameterized form.% Semantically, a
%parameterized rule (or invariant) can be considered as syntactic
%sugar for creating a copy of its component rules (or invariants) for
%every value of the parameter. Each transition rule is given in the
%form of a guarded command, which consists of a condition (a Boolean
%expression on the global variables) and an action (a statement that
%can modify the values of the variables).
By the Murphi semantics,
there is an implicit scheduler who selects a rule to execute whose
guard condition is satisfied. After a rule is triggered and action
is done, the state of the protocol is changed, then new transitions
may be enabled. The scheduling procedure is repeated forever.
%
%Note that the above Murphi code only verifies the protocol with a
%fixed  size $100$, while we aim to verify that the invariants hold  for any
%positive natural number that the parameter ${\it NODE}$ is set.

%=========================================
\section{A General Model for Cache Coherence Protocols}
%=========================================

%-------------------------------------------------------------------------
\subsection{Protocol syntax}
%-------------------------------------------------------------------------
To formally capture cache coherence protocols,
such as the one discussed in Section~\ref{sec:informalAccounting},
we first need to define the variables used in protocols.
There are two kinds of variables, global and
parameterized (local) variables.
%
%\vspace{2mm}
%\begin{specification}
%datatype varType=Global  string | Para string nat\\
%\\
%datatype expType= IVar varType   |  Const nat |
%           iteForm
%formula  expType  expType\\
%\\
%and  formula = eqn expType expType|\\
%                andForm  formula formula |
%                 neg formula|
%                   orForm formula formula |
%                implyForm formula formula\\
%\\
%type\_synonym assignType=  varType $\times$   expType
% datatype statement= assign assignType      |\\
% ~~                 parallel assignType  statement
%
%\end{specification}
%
For instance, $\mathsf{Global}~ x$ and $\mathsf{Para}~ n ~i$ are used to
formalize the global variable $x$ and the local variable $n[i]$ in
the Murphi program listed in Section~\ref{sec:informalAccounting}.
%
%Expressions and formulas are coupled together to define.
An expression can be simple, which is either a
variable or a constant, or a symbolic one which is an \emph{ite}
expression. In our model, a value of a variable is
 just a natural number.  A boolean variable is encoded as 0 or 1.
 A value is obtained from either reading a variable or being assigned directly by a natural
 number. The simplest formula is equivalence between expressions. Negation,
conjunction, disjunction, and implication formulas can also be
defined. A guard condition in Murphi is formalized by a formula.
% Expressions are simple as well, because operations to data are just copying or invalidating
% in cache coherence protocols.
%Thus   complex arithmetical operations are not so far needed.
 An assignment is just a pair of variable and expression. A statement is
a lists of assignments, but these assignments are executed in
parallel, \emph{not} in a sequential order. Though our modelling language
is simple but it is suitable to describe cache coherence protocols.
With the formalization of formula and statement, it is natural to
define a protocol rule. A guard and
 statement of a rule are also defined for convenience.

 \vspace{2mm}
 \begin{specification}
datatype rule =  guard formula  statement\\
primrec pre::rule $\Rightarrow$ formula where pre (guard f a)=f\\
primrec act::rule $\Rightarrow$statement where act  (guard f a)=a
\end{specification}

Now we can formalize the example protocol {\tt simpMutual} as follows:

\vspace{2mm}
\begin{specification}
definition try::nat $\Rightarrow$ rule where\\
    try i $\equiv$
         let g=eqn (IVar (Para n i))(Const I) in \\
         ~~let Sent=assign ((Para n i),(Const T)) in
~             guard g Sent \\%
%\\
% definition  crit::nat $\Rightarrow$ rule where\\
%      crit  i $\equiv$
%          let g1= eqn (IVar (Para  n i)) (Const T) in
 %         let g2=  eqn (IVar (Global  x )) (Const TRUE) in\\
%          let a=   ((Para  n i), (Const C)) in
 %         let Sent2= assign  ((Global  x ), (Const FALSE)) in\\
 %         guard (andForm g1 g2) (parallel a  Sent2)\\
%\\
% definition  exit::nat $\Rightarrow$ rule where\\
%      exit  i $\equiv$
%       let g= eqn (IVar (Para  n i)) (Const C) in \\
%       let Sent=assign ((Para  n i), (Const E)) in\\
%~             guard g Sent
%\end{specification}

%\begin{specification}
%definition idle::nat $\Rightarrow$ rule where\\
%     idle  i $\equiv$
%       let g= eqn (IVar (Para  n i)) (Const E) in\\
%         let a=   ((para  n i), (Const I)) in\\
%         let Sent2= assign  ((Global  x), (Const TRUE)) in
%         guard g (Parallel a Sent2)\\
%\\
definition mutualIni::nat$\Rightarrow$formula where\\
 mutualIni  N $\equiv$
  andForm (eqn (IVar (Global x)) (Const TRUE))\\
 (forallForm [0..<N] (\%x.eqn (IVar (para n x))(Const I)))\\

definition exLessP:
nat $\Rightarrow$ (nat $\Rightarrow$ bool) $\Rightarrow$bool\\

 where exLessP N P $\equiv$ $\exists$i. (i$\le$N $\wedge$ P i)\\

 definition rules::nat $\Rightarrow$ rule set where \\
 rules N $\equiv$ \{r. exLessP N (\% i. r=crit   i)~$\vee$~exLessP N (\% i. r=exit
i)  $\vee$\\
 exLessP N (\%i. r=idle i)~$\vee$ exLessP N (\%i.r=try i)\}\\
%\\
definition mutualInv::nat $\Rightarrow$ nat $\Rightarrow$
$\Rightarrow$rule where\\
 mutualInv i j $\equiv$
  let ant=eqn (IVar (Para  n i)) (Const C)  in\\
  let cons= neg (eqn (IVar (Para  n j)) (Const C)) in
~       (implyForm ant cons)  s
\end{specification}

In the above formalization, we first define the constants and
parameterized rules $\mathsf{ try }$,
$\mathsf{ crit }$, $\mathsf{ exit }$, and
$\mathsf{ idle }$. Initialization of the
protocol is defined as a predicate $\mathsf{ mutualIni}$.
The predicate $\mathsf{exLessP}~ N ~P$
says that there exists a natural number that is less than   $N$ and the property $P~i$ holds.
$\mathsf{rules}~N$ just defines the set of all transition rules. The mutual exclusion property is defined as
  $\mathsf{mutualInv}$.

%-------------------------------------------------------------------------
\subsection{Protocol semantics}
%-------------------------------------------------------------------------
A  protocol state is an instantaneous snapshot of its
behavior given by an assignment of  values to variables.
Formal semantics of expressions and formulas are then formalized routinely.

\vspace{2mm}
 \begin{specification}
 type\_synonym state= varType $\Rightarrow$ nat\\
primrec expEval :: expType $\Rightarrow$ state $\Rightarrow$
nat  and \\

 formEval :: formula $\Rightarrow$ state $\Rightarrow$bool
where\\
expEval  (IVar ie) s =  ( s ie) |
 expEval  (Const i) s =i\\
 expEval  (iteForm f e1 e2) s=
   ( if (formEval f s) then     (expEval e1 s)\\
   else (expEval e2 s))  |\\
 formEval (eqn e1 e2) s
 = ((expEval e1 s) = (expEval e1 s)) |\\
formEval ( andForm f1 f2) s=   (formEval f1 s) $\wedge$ (formEval f2
s)|\\
 formEval (neg f1 ) s=  $\neg$(formEval f1 s)|\\
  formEval (orForm f1 f2) s= (formEval f1 s) $\vee$  (formEval f2 s)|\\
formEval (implyForm f1 f2) s= (formEval f1
s)$\longrightarrow$(formEval f2 s)
\end{specification}

A state transition from a state to another sate, which is caused by
an execution of a statement, is
 defined as follows:

\vspace{2mm}
 \begin{specification}
 primrec trans:: statement $\Rightarrow$ state $\Rightarrow$state
 where\\
trans (assign pair) s =  s ((fst pair):= expEval  (snd pair) s)
|\\
trans (parallel  (pair) sent2) s =  (trans sent2 s) ((fst
pair):=expEval  (snd pair) s)
\end{specification}

Here we emphasize that the assignments are executed in parallel.
Therefore, we always assign an
evaluation of an expression in a state to the corresponding variable.
%
The reachable sate set of a protocol, which is described by a set of
initiate formulas and a set of rules, can be formalized inductively
as follows:

\vspace{2mm}
\begin{specification}

inductive\_set reachableSet:: \\formula set$\Rightarrow$ rule set
$\Rightarrow$state set\\
  for  inis::formula set  and rules::rule set   where\\

initState:  $\isasymlbrakk$formEval  ini s; ini $\in$
inis$\isasymrbrakk$ $\Longrightarrow$ (s$\in$ (reachableSet inis
rules)) |~\\\\
oneStep:     $\isasymlbrakk$s $\in$  reachableSet inis rules ;
               r $\in$   rules ; formEval (pre r) s$\isasymrbrakk$\\
               $\Longrightarrow$  trans  (act r) s  $\in$  reachableSet inis
               rules
\end{specification}
%

\noindent
 The rule $\mathsf{initState}$ says that a state $s$ is in
$\mathsf{reachableSet}~inis~ rules$ if
 there exists a formula $ini$ that is true in state $s$. Next rule $\mathsf{oneStep}$ says that
$\mathsf{ trans}~  (\mathsf{act}~ r )~ s $ is also in
 $\mathsf{reachableSet}~inis~ rules$ if $s$ already is in
 $\mathsf{reachableSet}~inis~ rules$ and $r $ $\in$  $rules$.
%
For the {\tt simpMutual} protocol, we prove the following
lemma:
\begin{lemma}
  $\isasymlbrakk
  s \in \mathsf{reachableSet}~ \{\mathsf{mutualIni}~  N\} ~(\mathsf{rules} ~N)$; $0<N$
  $\isasymrbrakk \Longrightarrow i\neq j\wedge i\leq N \wedge j \leq N\longrightarrow
   \mathsf{formEval}~ (\mathsf{mutualInv}~i~j)~ s $
\end{lemma}
%
It says that the invariant  `$\mathsf{mutualInv}~i~j$' (mutual exclusion property) holds for any $s$ in
$\mathsf{reachableSet}~ \{\mathsf{mutualIni}~  N\} ~(\mathsf{rules}~N)$ if $i
\neq j$, $i\leq N$, and $j \leq N$.

%=========================================
\section{The Consistency Theorem}
%=========================================
There are two key points in our proof strategy for
proving invariants of cache coherence protocols:  \emph{invariant
strengthening} and the \emph{consistency} lemma.
In this section, we focus on the consistency lemma,
as invariant strengthening is already well studied in the literature.

In order to prove an invariant $inv$, given in the form of an implication, we usually need to figure out a
list of auxiliary invariants such as $inv_1, \ldots, inv_n$. Instead of just
proving the single invariant $inv$, we need to prove all invariants
 $inv' \in \{inv, inv_1 ... , inv_n\}$ holds. In fact,
strengthening an invariant with a set of auxiliary invariant is
naturally developed in our application of induction proof method because we
can use a more powerful induction hypothesis to prove the
strengthened conclusion when we perform an induction proof step. %How to
%figure out the set of auxiliary invariants is always a central topic
%%in the field of parameterized verification. We will briefly discuss our invariant finder
%which is also guided the heuristics hinted by consistency lemma in later section.

Secondly, we originate a novel proof method for the proof of
invariance for cache coherence protocols. This method is based
on the following consistency lemma.
Before giving the lemma, we need a set of preliminary definitions.
Let ${\it asgn}\!=\![(v_1,e_1),\ldots,(v_n,e_n)]$ be an assignment to variables
$x_i$ by expressions $e_i$. $\mathsf{substExp}~asgn~e$ ($\mathsf{substForm}~asgn~f$)
denotes the expression $e$ (formula $f$) in which the occurrence of variable
$x_i$ is replaced by $e_i$. A statement $S$ can be transformed into an assignment to some variables $x_i$,
which is formalized by $\mathsf{statement2Assigns}~ S$. $\mathsf{preCond}~f~S$
is defined by $\mathsf{substForm}~ f~ (\mathsf{statement2Assigns} ~S)$.
After executing statement $S$, $f$ holds if $\mathsf{preCond}~f~S$ holds before the execution.
%\JP{statement2Assigns is not defined in the code!
%substExpByStatement in the following Isabelle code is not explained on the contrary.}

\vspace{2mm}
\begin{specification}

primrec substExp::expType$\Rightarrow$assignType
list$\Rightarrow$expType\\

and substForm ::  formula $\Rightarrow$ assignType list
$\Rightarrow$ formula
 where\\


substExpVar:
substExp (IVar v') asgns=(valOf asgns v')
|\\
substExpConst:
substExp (Const i) asgns=Const i\\

substIte: substExp  (iteForm f e1 e2)  asgns= (iteForm (substForm f asgns) \\
~~~~~~~~~~(substExp e1  asgns) (substExp e2  asgns))|\\

substForm (eqn l r) asgns=(eqn (substExp l asgns) (substExp r
asgns)) |\\

substForm (andForm f1 f2)  asgns=(andForm (substForm f1 asgns) \\
~~~~~~~~~~(substForm f2 asgns)) |\\

substForm (neg f1) asgns=(neg (substForm f1 asgns))
|\\

substForm (orForm f1 f2) asgns=(orForm (substForm f1 asgns) \\
~~~~~~~~~~(substForm f2 asgns)) |\\

substForm (implyForm f1 f2) asgns=(implyForm (substForm f1 asgns) \\
~~~~~~~~~~(substForm f2  asgns))  \\

%substForm chaos asgns=chaos\\\\

definition  substExpByStatement::expType $\Rightarrow$statement
$\Rightarrow$expType
   where [simp]:\\

substExpByStatement e S$\equiv$substExp e (statement2Assigns S)\\

definition preCond::formula $\Rightarrow$statement
$\Rightarrow$formula
   where [simp]:\\

preCond f S$\equiv$substForm f (statement2Assigns S)\\


%definition statementEnableForm:: rule $\Rightarrow$
%formula$\Rightarrow$bool
%\\
% where statementEnableForm r f$\equiv$
%$\forall$s. formEval (pre r) s \\
%$\longrightarrow$ formEval  (preCond f (act r)) s\\
%definition statementDisableForm::rule$\Rightarrow$formula$\Rightarrow$bool\\
%where statementDisableForm r f $\equiv$
 %    $\forall$s. formEval (pre r) s \\
%$\longrightarrow$ $\neg$ formEval  (preCond f (act r)) s
%\end{specification}

%Function $\mathsf{statementEnableForm}$ says that the guard of the rule implies
% the pre-condition of  formula $f$  w.r.t. statement of
% the rule. This means that $f$ must be valid after statement $S$ is executed.
%On the other hand,  $\mathsf{statementDisableForm}$ says that   the
%guard of the rule implies the negation of the pre-condition of
%formula $f$ w.r.t. statement of the rule. This means that $f$ must
%be invalid after statement $S$ is executed.
%For instance,  for the statement $S=\mathsf{assign}~
%((\mathsf{Para}~  n~ 0), (\mathsf{Const} ~\mathsf{T}))$, formula
%$f_1= \mathsf{eqn}~ (\mathsf{IVar}~ (\mathsf{Para}~ n 0))
%(\mathsf{Const}~ \mathsf{T})) $, $f_2= \mathsf{eqn}~ (\mathsf{IVar}~
%(\mathsf{Para}~ n ~0))\mathsf (\mathsf{Const}~ \mathsf{E}))$, we
%have $\mathsf{statementEnableForm}~S~f_1$ and
%$\mathsf{statementDisableForm}~S~f_2$. We also define two functions
%$\mathsf{varOfForm}~f$ and $\mathsf{varOfSent}~S$ to denote the set
%of variables used in the formula $f$ and statement $S$.

%\begin{specification}
primrec invHoldForRule1::
formula $\Rightarrow$ rule $\Rightarrow$ bool where\\
invHoldForRule1 (implyForm ant cons) r=%\\
$\forall$s. formEval (pre r) s $\longrightarrow $ \\
formEval  (substFormByStatement f (act r)) s \\ %\\

definition invHoldForRule2:: formula $\Rightarrow$ rule
$\Rightarrow$ bool  where\\
 invHoldForRule2 f  r =(varOfSent (act r)) $\cap$  (varOfForm f)=$\emptyset$ \\ %\\
%\end{specification}

%\vspace{2mm}
% \begin{specification}
primrec  invHoldForRule3:: formula $\Rightarrow$ rule
$\Rightarrow$formula set $ \Rightarrow$ bool where\\
 invHoldForRule3 (implyForm ant cons) r fs =\\
 (varOfSent (act r)$\cap$varOfForm cons=$\emptyset$
)$\wedge$ \\
   ($\exists$f' ant'.f'$\in$fs$\wedge$
  logicImply f'(implyForm ant' cons)$\wedge$\\
  logicImply (andForm (pre r)
  (preCond ant (act r))  ant')))\\ %\\

primrec  invHoldForRule4:: formula $\Rightarrow$ rule
$\Rightarrow$formula set$\Rightarrow$ bool
  where\\
 invHoldForRule4 (implyForm ant cons) r fs  =\\
 ($\exists$f'  ant'  ant''.f'$\in$ fs$\wedge$ logicImply f'  (implyForm ant' (neg ant''))$\wedge$ \\
 ((varOfSent (act r))$\cap$ varOfForm ant''=$\emptyset$)$\wedge$ logicImply ant ant''  $\wedge$ \\
(logicImply (andForm  (pre r) (preCond (neg cons) (act r))) ant'))\\ %\\

definition invHoldForRule5:: formula $\Rightarrow$rule
$\Rightarrow$formula set  $\Rightarrow$bool
 where\\
invHoldForRule5 inv0 r fs $\equiv$ \\
($\exists$f'.  f' $\in$fs $\wedge$ logicImply f'  (preCond inv0 (act r)))  \\
%\\
definition consistent::formula set $\Rightarrow$formula set
$\Rightarrow$rule set $\Rightarrow$bool  where\\
 consistent invs inis rs $\equiv$
 $\forall$inv ini s. (inv $\in$ invs
$\longrightarrow$  ini$\in$ inis$\longrightarrow$ \\ formEval ini s
$\longrightarrow$  formEval inv s)) $\wedge$\\
 ($\forall$ inv r.(inv $\in$invs$\longrightarrow$ r $\in$ rs$\longrightarrow$(invHoldForRule1 inv r $\vee$ \\
 invHoldForRule2 inv r  $\vee$ invHoldForRule3 inv r invs  $\vee$ \\
 invHoldForRule4 inv r invs  $\vee$ invHoldForRule5 inv r invs))
\end{specification}

Let $f=\mathsf{implyForm}~ant ~cons$ present an implication between $ant$ and $cons$.
Predicate $\mathsf{invHoldForRule1 }~f~ r$ says that after rule $r$
is executed, the pre-condition of $f$ \emph{w.r.t.} $\mathsf{act}~r$
is implied by the guard of $r$. %Namely, $f$ must be valid after
%\JP{the statement $S$???} is executed.
$\mathsf{invHoldForRule2 }~f~ r$ says
that all the variables in the statement of the action of rule $r$
has nothing to do with those in the formula $f$. Intuitively this
means that the execution of the rule $r$ will have no effect in the
the evaluation of the formula $f$. $\mathsf{invHoldForRule3}~f~
r~fs$ says that action of $r$ have nothing to do with $cons$, and
there exists another invariant $f'$ in the invariant set $fs$ and
another formula $ant'$  that  $ \mathsf{logicImply}~ f' ~
(\mathsf{implyForm}~ ant'~ cons ) $ and $\mathsf{logicImply}~
(\mathsf{andForm}~(\mathsf{pre}~ r)~(\mathsf{preCond}~ ant~
(\mathsf{act} ~r))) ~ ant' $ hold. The fourth
$\mathsf{invHoldForRule4}~(\mathsf{implyForm}~ ant~ cons)~ r~fs$
says that the
 action of $r$ has
nothing to do with $ant$, and there exists an invariant $f'$ in
the invariant set $fs$ and two formulas $ant'$ and $ant''$ such that $
\mathsf{logicImply}~ f' ~ (\mathsf{implyForm}$~ $ant'~ (\mathsf{neg}
~ant'') ) $, $\mathsf{logicImply}~ ant~ant'',$   $\mathsf{logicImply}~
(\mathsf{andForm}~(\mathsf{pre}~ r)~(\mathsf{preCond}$\ $~ (\mathsf{neg}~cons)~ (\mathsf{act} ~r)))~ ant'$ hold.
$\mathsf{invHoldForRule5}$~$inv~ r~fs$ requires that the pre-condition $\mathsf{preCond}~ inv~ (\mathsf{act}~ r)$
 is directly implied by an invariant $f$ in $fs$.

 %Intuitively, applying rule $\mathsf{invHoldForRule3}$ means
 % that a new antecedent $ant'$ must be found which implies $cons$, $\mathsf{invHoldForRule4}$ that part
 % (or all) of the antecedent of $ant$ is falsified by the negation of the
 % consequent.
%We will also interpret the meaning of these predicates in the following section.

Predicate $\mathsf{consistent}~ invs ~inis~ rs$ specify two aspects:
(1) For any invariant $inv \in invs$, any initializing predicate $ini \in inis$, any
state $s$, if $ini$ is evaluated true at state $s$, then $inv$ is
evaluated true at state $s$.
(2) For any invariant $inv \in invs$, any $r$ in rule set
$rs$, one of the following $\mathsf{invHoldForRule1 }~inv~ r$,
$\mathsf{invHoldForRule2 }~inv~ r$, $\mathsf{invHoldForRule3 }~inv~
r~invs$, $\mathsf{invHoldForRule4 }~inv~ r~invs$, or $\mathsf{invHoldForRule5}~inv~ r~invs$ holds.

Our main theorem~\emph{consistency}
 aims to prove that the invariants
hold for any reachable sate of a  general cache coherence protocol
which is modeled by a set of initializing formulas $inis$ and a set
of rules $rs$. Consider a set of invariants $invs$, and a set of
rules $rs$, and a set of initializing formulas $inis$, our theorem
\emph{consistency} says that for any invariant $inv\in invs$, $inv$
is evaluated true at any reachable state $s \in
\mathsf{reachableSet}~ inis rs$ if the consistency relation
$\mathsf{consistent}~ invs ~inis~ rs$ is satisfied. %Her we also assume that any invariant $inv$
%is of form of $\mathsf{implyForm}$ formula.

\begin{theorem}\label{consistentLemma}
  $\isasymlbrakk \mathsf{consistency}~ invs ~inis~ rs$; $s  \in \mathsf{reachableSet}~ inis~ rs$;
   $\forall inv. inv \in invs \longrightarrow \mathsf{ofImplyForm}~
   inv$
  $\isasymrbrakk\Longrightarrow$ $\forall inv. inv \in invs \longrightarrow
\mathsf{formEval}~ inv ~s$    \end{theorem}

%The proof of Theorem. \ref{consistentLemma} is rather
%straightforward by induction. The base of the induction proof is
%guaranteed by the first part of the definition of
%$\mathsf{consistent}$. The induction step is guaranteed by the
%second part of $\mathsf{consistent}$. %Namely, for any invariant $inv
%\in invs$, any $r$ in rule set $rs$, either $\mathsf{invHoldForRule1
%}~inv~ r$, $\mathsf{invHoldForRule2 }~inv~ r$,
%$\mathsf{invHoldForRule3 }~inv~ r~invs$, or $\mathsf{invHoldForRule4
%}~inv~ r~invs$.
%By induction hypothesis, we have that for a fixed state $s$,
%$\mathsf{formEval}~ inv ~s$ for any $inv \in invs$. Consider a rule
%$r \in rs$, now we need prove that $\mathsf{formEval}~ inv
%~(\mathsf{trans}~(\mathsf{act}~r)~s)$. There are four cases as
%follows:

%\begin{description}
%\item[(1)]If $\mathsf{invHoldForRule1 }~inv~ r$ holds, then we have
%$\mathsf{formEval}~ inv ~(\mathsf{trans}~(\mathsf{act}~r)~s)$
%directly;

%\item[(2)] If
%$\mathsf{invHoldForRule2 }~inv~ r$, and we have $\mathsf{formEval}~
%inv ~ s$ because the execution of rule $r$ has no
%effect in the evaluation of $inv$, then we can conclude
%$\mathsf{formEval}~ inv ~(\mathsf{trans}~(\mathsf{act}~r)~s)$  by
%the induction hypothesis;

%\item[(3)] If
%$\mathsf{invHoldForRule3 }~inv~ r$, then we have $\mathsf{formEval}~
%ant ~(\mathsf{trans}~(\mathsf{act}~r)~s)$ by the definition of
%$\mathsf{invHoldForRule3 }$. Now we need prove $\mathsf{formEval}~
%cons ~(\mathsf{trans}~s)$. Because the execution of rule $r$ has no
%effect in the evaluation of $cons$, and we can conclude
%$\mathsf{formEval}~ cons ~(\mathsf{trans}~(\mathsf{act}~r)~s)$ if we
%can show $\mathsf{formEval}~ cons ~s$.  Because there exists an
%invariant $inv'=\mathsf{implyForm}~ant'~cons'$ and a formula $ant'$
%such that $inv' \in invs $, (1) $\mathsf{logicImply}~ inv'~
%(\mathsf{implyForm}~ ant'~ cons ) $, and
% (2) $  \mathsf{logicImply}~ (\mathsf{pre}~ r) ~ant'$.  By   induction
%hypothesis, we have $\mathsf{formEval}~ inv'~s$, then by (1), we
%also have (3) $\mathsf{formEval}~(\mathsf{implyForm}~ ant'~ cons
%)~s$. Because $\mathsf{formEval} ~(pre~ r)~s$, by (2), we have
%$\mathsf{formEval}~ant'~s$, by (3), we conclude
%$\mathsf{formEval}~cons~s$;

%\item[(4)] If
%$\mathsf{invHoldForRule4 }~inv~ r$, then we have $\neg
%\mathsf{formEval}~ cons ~(\mathsf{trans}~(\mathsf{act}~r)~s)$ by the
%definition of $\mathsf{invHoldForRule4 }$. Now we need prove $\neg
%\mathsf{formEval}~ ant ~(\mathsf{trans}~(\mathsf{act}~r)~s)$.
%Because the execution of rule $r$ has no effect in the evaluation of
%$ant$, and we can conclude $\neg \mathsf{formEval}~
%ant~(\mathsf{trans}~s)$ if we can show $\neg \mathsf{formEval}~ ant
%~s$. Because there exists an invariant
%$inv'=\mathsf{implyForm}~ant'~cons'$ and a formula $ant'$ such that
%$inv' \in invs $, (1) $\mathsf{logicImply}~ inv'~
%(\mathsf{implyForm}~ ant'~ (\mathsf{neg}~ ant) ) $, and
% (2) $ \mathsf{logicImply}~ (\mathsf{pre}~ r) ~ant'$.  By   induction
%hypothesis, we have $\mathsf{formEval}~ inv'~s$, then by (1), we
%also have (3) $\mathsf{formEval}~(\mathsf{implyForm}~ ant'~
%(\mathsf{neg}~ ant) ~s$. Because $\mathsf{formEval} ~(\mathsf{pre}~
%r)~s$, by (2), we have $\mathsf{formEval}~ant'~s$, by (3), we
%conclude $\mathsf{formEval}~(\mathsf{neg}~ ant)~s$, thus $\neg
%\mathsf{formEval} ~ ant~s$.
%
%\end{description}

Theorem~\ref{consistentLemma} gives a general guiding principle to
prove invariants of a cache coherence protocol. Especially it
eliminates the need of directly using the induction proof method
again in ground case studies. It allows us to focus on  the causal
relationship between transition  rules of the protocol and
invariants.
%Furthermore, it allows for dividing the proof of the
%invariants to a series of subproofs to verify whether one of the
%relations $\mathsf{invHoldForRule1}$-$\mathsf{invHoldForRule5}$
%holds for  a rule  and an invariant.
%All the definitions, lemmas, and proofs in this section are
%implemented in a formal theory \texttt{cache.thy}, which provides a
%mechanized library for  analysis of cache coherence protocols. This
%theory comprises 1243 lines.
%
%This divide and conquer strategy is the key to make the series of sub-proofs
%to be automated because the proof patterns for the  subproofs  are similar
%and modular. It is the similarity and modularity that allows us to summarize
%general proof template and instantiate the template with different interpretations.

%=========================================
\section{Using the consistency theorem to prove invariant sets}
\label{sec:provingInvSets}
%=========================================
%\JP{Do we actually need this section?}
This section shows how to apply our consistency theorem to prove an
invariant set of the \texttt{simpleMutual} example. Firstly, we need
a set of auxiliary invariants, which are shown in the following:

\vspace{2mm}
\begin{specification}
%definition mutualInv1::nat $\Rightarrow$ nat $\Rightarrow$ formula\\
%where mutualInv1 i j $\equiv$\\
%  let ant=eqn (IVar (Para  n i)) (Const E)  in\\
%  let cons= neg (eqn (IVar (Para  n j)) (Const C)) in
%      (implyForm ant cons)\\

%definition mutualInv2::nat $\Rightarrow$ nat $\Rightarrow$ formula\\
%where mutualInv2 i j $\equiv$\\
%  let ant=eqn (IVar (Para  n i)) (Const E)  in\\
%  let cons= neg (eqn (IVar (Para  n j)) (Const E)) in
%      (implyForm ant cons)\\

definition invOnX1::nat $\Rightarrow$ formula  \\
where invOnX1 i\\ $\equiv$
  let ant= eqn (IVar (Global  x )) (Const TRUE)  in\\
  let cons= neg  (eqn (IVar (Para  n i)) (Const C))  in
      (implyForm ant cons)\\

%definition invOnX2::nat $\Rightarrow$ formula \\
 % where invOnX2 i
%$\equiv$\\
 % let ant= eqn (IVar (Global  x )) (Const TRUE)   in\\
 % let cons=neg (eqn (IVar (Para  n i)) (Const E))  in
 %     (implyForm ant cons)
% \\
%\\

%invs=\{ f.( $\exists$ i j. (f=mutualInv i j $\vee$ f=mutualInv1 i j
%$\vee$ f=mutualInv2 i j )\\
%\>  $\wedge$ i$\neq$j $\wedge$ i$\le$ N $\wedge$ j $\le$ N)\}$\cup
%$\\
%\>  \{f. $\exists$ i. (f=invOnX1 i$\vee$ f=invOnX2 i) $\wedge$
%i$\le$
%  N\}\\
definition invariants::nat $\Rightarrow$ formula set  where [simp]\\
invariants N$\equiv$ \{f. exTwoLessP N (\% i j.  f = invonX1 i j)  \\
$\vee$exTwoLessP N (\% i j.  f = invOnX2 i j)   \\
$\vee$exLessP N (\% i.  f= mutualInv1 i j)   \\
$\vee$exTwoLessP N (\% i j.  f =  mutualInv2 i j) \\
$\vee$exTwoLessP N (\% i j.  f =  mutualInv3 i j) \}
\end{specification}

%The construction of the auxially invariants is another key point,
%and we will discuss this topic in the latter section.
Invariant set $\mathsf{invariants}~N$ is defined as above, where $\mathsf{exTwoLessP}~N~P\equiv \exists  i_1~ i_2. ( i_1\le
 N  \wedge i_2\le
 N \wedge~i_1\neq i_2\wedge P~ i_1~ i_2 )$, then
  we focus on how to apply the consistency theorem to prove these invariants. In the following sections, we use $i_1$, $i_2$, and $iR$ to denote integer indexes.
 % \JP{Why not $i_R$?}

\begin{lemma} \label{sec:main}
  $\isasymlbrakk s \in \mathsf{reachableSet}~ \{\mathsf{mutualInis}~N\}~ (\mathsf{rules}~N)$; $0<N$
  $\isasymrbrakk\Longrightarrow$ $\forall inv. inv \in (\mathsf{invariants}~N) \longrightarrow
\mathsf{formEval} ~inv ~s$ \end{lemma}
\begin{proof} Let $inis=\{\mathsf{mutualInis}~N\}$, and $invs=
\mathsf{invariants}~N$. By Theorem~\ref{consistentLemma}, we need
to verify that parts (1) and (2) of
 the relation $\mathsf{consistency}$ hold.

%\begin{description}
%\item[(1)]
%(1) For any invariant $inv \in invs$, any initializing predicate
%$ini \in inis$, any state $s$, if $ini$ is evaluated true at state
%$s$, then $inv$ is
%evaluated true at state $s$.\\
%\item[(2)]
%(2) For any invariant $inv \in \mathsf{invs}$, any $r$ in rule set
%$ruleset$, either $\mathsf{invHoldForRule1 }~inv~ r$,
%$\mathsf{invHoldForRule2 }~inv~ r$, $\mathsf{invHoldForRule3 }~inv~
%r~\mathsf{invs}$, or $\mathsf{invHoldForRule4 }~inv~
%r~\mathsf{invs}$ holds.\\
%\end{description}
For (1), the proof is rather straightforward.    For instance,
consider the case where $inv=\mathsf{mutualInv}~ i_1 ~i_2$, we can
 conclude that $\mathsf{formEval}~  (\mathsf{eqn
}~(\mathsf{IVar}~ (\mathsf{Para}~ n~ i_2))$\ $ (\mathsf{Const}~
\mathsf{I}))~ s$ if $\mathsf{formEval}~(\mathsf{mutualInis}~N)~s$,
thus $\mathsf{formEval}~inv~s$ holds. The other invariants can be
proved similarly.

For (2), we show  proof of a typical case where
$inv=\mathsf{mutualInv}~ i_1 ~i_2$, and $r=\mathsf{crit }~iR$, where
$iR\le N$, $i_1\le N$, $i_2\le N$, and $i_1\neq i_2$. Here we
abbreviate $ant= \mathsf{eqn}~ (\mathsf{IVar}~ (\mathsf{Para} ~ n
~i_1))~ (\mathsf{Const}~ C)$,
 $ cons= \mathsf{neg}~ (\mathsf{eqn}~ (\mathsf{IVar} ~(\mathsf{Para}~  n~ i_2))
  ~(\mathsf{Const} ~\mathsf{C}))$. Now we consider three cases analysis on $iR$, $i_1$ and $i_2$:\\
%\begin{description}
%\item[(2-a)]
(2-a) $iR=i_1$, we  show   $\mathsf{invHoldForRule3}~ inv~ r~
\mathsf{invs}$. From $i_1 \neq i_2$, $\mathsf{varOfSent
}~(\mathsf{act}~ r)=\{\mathsf{Para}~ n~ i_1$, $\mathsf{Gobal}~x\}$
and $\mathsf{varsOfForm}~cons =\{\mathsf{Para}~ n~ i_2\}$,  thus
$\mathsf{varOfSent}~ (\mathsf{act}~ r) \cap
\mathsf{varsOfVar}~(cons)=\emptyset$. Second let
$inv'=\mathsf{invOnX1}~ i_2$, $ant'=  (\mathsf{eqn}~
(\mathsf{IVar}~(\mathsf{Global}~ x))$\\
$ ~(\mathsf{\mathsf{Const}}\mathsf{TRUE}))$, we have that
$\mathsf{logicImply}$\ $(\mathsf{invOnX1}~ i_2)
~(\mathsf{implyForm}~ ant' ~cons)$ because they are the same.
Second, we show $\mathsf{logicImply}~ (\mathsf{pre}~ r) ~ant'$. This
is also straightforward because the latter is one of the conjuncts
of the former. Thus $\mathsf{logicImply}~
(\mathsf{andForm}~(\mathsf{pre}~ r)~ (\mathsf{preCond}~ ant~
(\mathsf{act} ~r))) ~ ant' $.\\
(2-b) $iR=i_2$, we  show $\mathsf{invHoldForRule4}~ inv~ r~
\mathsf{invs}$.  From $i_1 \neq i_2$, $\mathsf{varOfSent}~
(\mathsf{act} ~r) \cap \mathsf{varsOfForm}~ ant = \emptyset$ because
$\mathsf{varOfSent}~ (\mathsf{act}~ r)=\{\mathsf{Para}~ n ~i_2$,
$\mathsf{Gobal}~x\}$ and $\mathsf{varsOfForm}\ ant=$
$\{\mathsf{Para}~ n~ i_1\}$. Second, let $inv'=\mathsf{invOnX1}~
i_1$, $ant'=   (\mathsf{eqn}~ (\mathsf{IVar}$\\$(\mathsf{Global}~
x))~ (\mathsf{Const} \mathsf{TRUE}))$, $ant''=\mathsf{eqn}~
(\mathsf{IVar} ~(\mathsf{Para}~  n~ iR)~\mathsf{Const}~
\mathsf{C})$. We can easily show that $\mathsf{logicImply}~
\mathsf{invOnX1}~ i'~(\mathsf{implyForm}~ $ $ ant'~ (\mathsf{neg}
~ant''))$ because the former is equivalent to the latter. Second, we
have $\mathsf{logicImply}~ (\mathsf{pre}~ r) ~( (\mathsf{eqn}~
(\mathsf{IVar}~ (\mathsf{Global}~ x))$\\
$(\mathsf{Const}~
\mathsf{TRUE}))$. This is also straightforward because the latter is
one of the conjuncts of the former, thus we can show
$\mathsf{logicImply}~
(\mathsf{andForm}~(\mathsf{pre}~ r)~(\mathsf{preCond}$\ $~ (\mathsf{neg}~cons)~ (\mathsf{act} ~r)))~ ant'$.\\
(2-c) $iR\neq i_1$ and $iR\neq i_2$, we  show
$\mathsf{invHoldForRule2}~ inv~ r$. The proof is straightforward
because $\mathsf{varOfSent}~(\mathsf{act}~ r)=\{\mathsf{Para}~ n~
iR$, $\mathsf{Gobal}~x\}$ $\mathsf{varOfForm}~inv=\{\mathsf{Para}~
n~ i_1$,
 $\mathsf{Para}~
n~ i_2\}$, and they are disjoint.
% From $i_1 \neq i_2$,
%$\mathsf{varOfSent}~
%(\mathsf{act} ~r) \cap \mathsf{varsOfForm}~ ant = \emptyset$ because
%$\mathsf{varOfSent}~ (\mathsf{act}~ r)=\{\mathsf{Para}~ n ~i_2$,
%$\mathsf{Gobal}~x\}$ and $\mathsf{varsOfForm}\ ant=$
%$\{\mathsf{Para}~ n~ i_1\}$. Second, let $inv'=\mathsf{invOnX1}~
%i_1$, $ant'=   (\mathsf{eqn}~ (\mathsf{IVar}\  (\mathsf{Global}~
%x))~ (\mathsf{Const}~ \mathsf{TRUE}))$, $ant''=\mathsf{eqn}~
%(\mathsf{IVar} ~(\mathsf{Para}~  n~ iR)~\mathsf{Const}~
%\mathsf{C})$. We can easily show that $\mathsf{logicImply}~
%\mathsf{invOnX1}~ i'~(\mathsf{implyForm}~ $ $ ant'~ (\mathsf{neg}
%~ant''))$ because the former is equivalent to the latter. Second, we
%have $\mathsf{logicImply}~ (\mathsf{pre}~ r) ~( (\mathsf{eqn}~
%(\mathsf{IVar}~ (\mathsf{Global}~ x))~(\mathsf{Const}~
%\mathsf{TRUE}))$. This is also straightforward because the latter is
%one of the conjuncts of the former, thus we can show
%$\mathsf{logicImply}~
%(\mathsf{andForm}~(\mathsf{pre}~ r)~(\mathsf{preCond}$\ $~ (\mathsf{neg}~cons)~ (\mathsf{act} ~r)))~ ant'$.\\
%(2-c) $iR\neq i_1$ and $iR\neq i_2$. We  show
%$\mathsf{invHoldForRule2}~ inv~ r$. The proof is straightforward
%because $\mathsf{varOfSent}~(\mathsf{act}~ r)=\{\mathsf{Para}~ n~
%iR$, $\mathsf{Gobal}~x\}$ $\mathsf{varOfForm}~inv=\{\mathsf{Para}~
%n~ i_1$,
% $\mathsf{Para}~
%n~ i_2\}$, and they are disjoint.
 \end{proof}

%\begin{remark}
% Here we analyze the complexity of the proof. For one rule, we need to
%analyze three  cases for each invariant $inv$ in
%$\mathsf{mutualInv}$, $\mathsf{mutualInv1}$, and
%$\mathsf{mutualInv2}$, and two cases for the others.
%in $\mathsf{invOnX1}$ and $\mathsf{invOnX2} $.
%Thus we need in total
%$4\times (3 \times 3 +2\times 2)=52$ cases. Note that the  protocol
%is simple because it has only 4 rules.
%Here we must note that the proof cases are the key measure for
%the complexity of the parameterized verification.  %Let alone a moderate
%protocol such as German and Flash with about 15~50 cases.
%This complexity illustrates the difficulty of parameterized verification of
%cache coherence protocols. %A moderate case study such
%as German protocol has about 15 rules.
%If we only rely human intelligence to guide the theorem prover to
%prove them, the proof will be tedious and error-prone. This gives us the motivation
%to develop an automatic technique to generate the needed proofs.
%\end{remark}
%Our solution is to automate the proof procedure basing on Isabelle's
%strong support for proof programming.

%Luckily, we notice  that our proof preserves
%has a neat modular structure. The proof for part (1) can be just
%finished by Isabelle's automatical command such as $\mathsf{auto}$
%or $\mathsf{metis}$ because it only involves simple predicate
%calculation. The proof for part (2) is also quite routine. First we
%need analyze the cases whether the parameters $i$, $i'$, $j$ are
%equal. For each case, we select a proper obligation from
%$\mathsf{invHoldForRule1}-\mathsf{invHoldForRule4}$. The
% hint to guide the selection is obvious: (1) If the antecedent of
% the invariant $inv$ is invalid or its consequent is valid after the
% execution of the statement of the rule $r$, then we choose $\mathsf{invHoldForRule1}$;
% (2) If the
% execution of the statement of $r$ has nothing with the invariants,
% we choose $\mathsf{invHoldForRule2}$; (3) If the antecedent of
% the invariant $inv$ is valid,  we choose
% $\mathsf{invHoldForRule3}$, and must find another invariant $inv'$
% to prove that the consequent of $inv$ also holds. The proof is
% based on the induction hypothesis and the execution of execution of the statement of $r$ has
%nothing to do with the consequent; (4) If the consequent of
% the invariant $inv$ is invalid,  we choose
% $\mathsf{invHoldForRule4}$, and must find another invariant $inv'$
% to prove that the antecedent of $inv$ also invalid. The proof is
% based on the induction hypothesis and the execution of execution of the statement of $r$ has
%nothing to do with the antecedent.

%\emph{I need help in Isabelle's programming techniques to automate
%this proof method}?

%=========================================
\section{Automatic  generation of parameterized proofs}
%=========================================
%In order to understand

%In this section, we solve the problem of the proof generation.
%In an overview, the parameterized proof for a parameterized protocol
%model w.r.t. a parameterized invariants can be derived from a ground
%proof (which is corresponding to a series of causal relation) for a
%small and finite model. This the core idea of proof generation
%strategy. The intuition behind our approach is that a parameterized
% proof in a parameterized model should share the same
% proof pattern which is suitable for a ground proof in a
%  small protocol instance.

 The architecture of  our automatic proof generation
is illustrated in Fig.~\ref{fig:arch} (a). A small cache coherence
protocol instance {\tt a.fl}, is fed into the \texttt{invFinder}.
The tool \texttt{invFinder} works in a
 counterexample guided iterative  workflow. It works out
 a table {\tt a.tbl}, which stores a set of ground invariants and causal relations
 derived from a finite and
small protocol instance, which will be  used by {\tt proofGen} to
create an Isabelle proof   script which models and verifies in a
parameterized form. At last the Isabelle proof script is fed into
  Isabelle to check the correctness of the protocol.
%\vspace{-1.25cm}
%\begin{center}


%\end{center}
%\vspace{-1.5cm}
  %Namely, the two proofs are "similar" in some sense.
  %The core nevelty of our work is to
  %generalize the ground proof information to a general proof for
  %the parameterized model. Isabelle's locale feature provide good
  %supports  for us to implement the automatically generating
  %procedures.

%Within our automatic proof generation framework,
%first a cache coherence protocol instance $P(N)$ (usually $N$ is a small
%number 3 or 4), is fed into the \texttt{invFinder} and transformed
%into an internal form. The tool \texttt{invFinder} works in a
%counterexample guided iterative
% workflow. It tries to prove the current invariant found up to now,
%  automatically analyzes the counterexample, and generates a new auxiliary
%  invariant, and records the corresponding consistency information for proofs. This work is
%  not
 % finished until no new counterexample is created. The auxiliary invariants and consistency
 % information is recorded in a table $P.tbl$,   which is combined with other information in the
 % $P(N)$, is used to create an Isabelle proof
 % script $P.thy$ in
 % the Isabelle framework. Note that $P.thy$ is a parameterized model which is automatically generated from a causal information
 % of a small protocol instance $P(N)$, which is   stored in $p.tbl$.
 % Here some \emph{invariant generalizing techniques} and \emph{parameter mapping} information must be adopted.
 % At last the Isabelle proof script is fed to
 % Isabelle to check the correctness of the parameterized protocol. %Due to space limitation, how to generate proofs for invariants are discussed here.
  %For the detail of $\mathsf{invFinder}$, readers refer to
 % \cite{LiCache13}.
\begin{table}[!t]
\centering \caption{A fragment of the ground causal relation}\label{label-ground-causal relation} % {\tt
%simpMutual.tbl}
\begin{tabular}{|c|c|c|c|c|c|c|c| }
\hline
{\tt inVum} &invParas& rule& ruleParas&causal relation &   f' & ant' & ant''\\
\hline
.. & .. & ..&.. &..&..&..& \\
\hline
5 &[1,2] & crit  & 1& invHoldForRule3 &f1' &ant1'&\\
\hline
5 &[1,2]& crit & 2& invHoldForRule4 &f2' & ant2'&ant2''\\
\hline
5 &[1,2]& crit & 3& invHoldForRule2 & & &\\
\hline
.. & .. & ..&.. &..&..&.. &\\
\hline
\end{tabular}
\end{table}

\subsection{Ground invariants and ground causal relations}
%As we have mentioned, our parameterized proof generation depends on
%ground invariants and causal relations derived from a finite and
%small protocol instance.  Obviously, the generation is closely
%related with an auxiliary invariants finder, which finds
%in the finite model for all the above.  %not only all the auxiliary invariants to
%prove the main invariant, but also the above kinds of causal
%relation between the invariants and the rules. Note that all the
%invariants and the causal relations are in ground form.
%In fact, we have implemented a tool \texttt{invFinder} to do such a
%task.



%In this paper, we focus on how to automatically generate the parameterized proof
%from the causal information generated from
% \texttt{invFinder}. Therefore, we  only give a fragment of the {\tt simpMutual.tbl}
%for our running example.

%Here we  only have a glimpse over the output of \texttt{invFinder},
%which is shown in Table \ref{comparison of results}.
Each line records the    index of an parameterized invariant, its parameter, name of a parameterized rule, the rule
  parameters to instantiate the rule, a causal relation between
  the ground invariant and a kind of causal relation which involves the kind and proper formulas
  $f'$, $ant'$, and $ant''$  in need (which are used to construct
  one of    causal relations $\mathsf{invHoldForRule}3$-$\mathsf{invHoldForRule}5$. The index
  will be useful to name the invariant in the generation of the
  definitions of the invariants, and reference of the invariant in
  the formal proof in Isabelle. The ground invariant and rule can be obtained by
  an  application of the invariant parameters to the parameterized invariant and rule respectively.
  %The ground rule can be seen as the
  %application of the parameters to the parameter rule.


%for our running example.
%A table, which records not only all the involved invariants, but
%also the causal relation between each rule instance and some
%invariant instance, which is computed from the reference protocol
%model. Here the \texttt{invFinder} will automatically name the
%invariants according to some order. For example,
%$\mathsf{mutualEx}$, $\mathsf{inv}_4$ will be named as
%$\mathsf{inv5}$, $\mathsf{inv2}$, respectively. The names
%``$mutualEx$" in previous section are only used for better
%understanding, an integer index is used to retrieve a lemma for
%mechanical proof. $ant'=\mathsf{eqn}~(\mathsf{IVar}
%~(\mathsf{Global} ~``x"))~(\mathsf{Const}~True)$ is a formula, which
%is needed to construct the causal relation
%$\mathsf{invHoldForRule3}$. Interesting readers can refer
%to~\cite{LiCache13} for details.



%In fact, the above table has clearly represented the standard form
%of the ground causal relation, which is fed into {\sf proofGen} for
%proof generation in our framework.

 \begin{figure}[!ht]
% \centering %
 \vspace{-0.8cm}
\includegraphics[width=1.0\textwidth]{invFinderArchClip.pdf}
%\vspace{-0.5cm}
 \caption{Two figures}
\label{fig:arch}
\end{figure}
 \vspace{1cm}
%Each line in Table \ref{label-ground-causal relation} is
%corresponding to the causal
%  relation  which   holds between the ground invariant and the
%  rule. For instance, the first line says that the causal relation
%  $\mathsf{invHoldForRule3}~(\mathsf{inv5} ~ 1~2)~(\mathsf{crit}~1)~cinvs$ holds,
%   where $cinvs$ is all the ground invariants included in the table,  $\mathtt{f1'}$ and
%   $\mathtt{ant1'}$ provide necessary information to construct the
%   $\mathsf{invHoldForRule3}$ relation. Note that the generated invariants are ground
%   formulas and the
%causal relations are also between  ground terms and  ground rules.
%It cannot be directly used as proofs because we need a parameterized
%proof in a parameterized model
% of a protocol with parameter $N$ because $N$ is symbolic, not a ground value such as 3 or  4.
%

%For instance, for the protocol $\mathsf{mutualEx}$, we try to find
%the new invariants by starting from the first invariant
%$\mathsf{mutualInv}$. We use the invariant instance
%$\mathsf{mutualInv}~1~2$, and verify the causal relation between
%this invariant instance and instances of all parameterized rules.
%For each parameterized rule $pRule$, we only need three rule
%instances with parameter 1, 2, or 3. Here the causal relation
%between $\mathsf{mutualInv}~1~2$ with $pRule~1$ represents causal
%relation between $\mathsf{mutualInv}~i_1~iInv2$ with
%$pRule~iRule$ when $i_1=iRule$; that between
%$\mathsf{mutualInv}~1~2$ with $pRule~2$ represents that  between
%$\mathsf{mutualInv}~i_1~iInv2$ with $pRule~iRule$ when
%$iInv2=iRule$; that between $\mathsf{mutualInv}~1~2$ with
%$pRule~3$ represents that  between
%$\mathsf{mutualInv}~i_1~iInv2$ with $pRule~iRule$ when nether
%$i_1=iRule$ nor $iInv2=iRule$.

%For instance, when the rule is $Try$, the tool checks that
%$\mathsf{invHoldForRule1}~(Try~1)$\ \ $(\mathsf{mutualInv}~1~2)$
%holds because the antecedent of the invariant is false after the
%triggering of the rule $\mathsf{Try}~1$,
%$\mathsf{invHoldForRule1}~(Try~2)~(\mathsf{mutualInv}~1~2)$ holds
%because the consequent of the invariant is false after the
%triggering of the rule $\mathsf{Try}~2$, and
%$\mathsf{invHoldForRule2}~(Try~3)~(\mathsf{mutualInv}~1~2)$ holds
%because nether the state variable $n~1$ in the antecedent nor $n~2$
%in the consequent is changed.

%When the rule is $Crit$,  the tool checks that the antecedent of
%$(\mathsf{mutualInv}~1~2)$ is enabled after the executing of
%$Crit~1$, and the value of the state variable $n~2$ does not change,
%there fore tool will try to find a condition $ant'$ such that
%$\mathsf{implyForm}~ant'~cons$ is also an invariant. There are two
%possible formulas to choose to be $ant'$, $\mathsf{eqn}~
%(\mathsf{IVar}~ (\mathsf{Para} ~ n ~1))~(\mathsf{Const}~ T)$ or
%$\mathsf{eqn}~ (\mathsf{IVar}~ (\mathsf{Global} ~ x ))$\ $
%(\mathsf{Const}~ TRUE)$, now we can use the reachable set of the
%small protocol instance with $NODE=3$ to check which one should be
%$ant'$. The answer is that $ant'$ should be the latter. Then we
%record the information that $\mathsf{invHoldForRule3}$ relation
%holds between $Crit~1$ and $(\mathsf{mutualInv}~1~2)$. Furthermore
%new invariant $\mathsf{implyForm}~ant'~cons$ are added, and will be
%used to find new invariants.

%The invariant generation procedure will not stop until no new
%invariants can not be created again. Here we must point the meaning
%of the word "new" is modulo to the symmetry relation. The intuitive
%meaning of the symmetry relation is that $\mathsf{mutualInv}~1~2$ is
%equivalent to $\mathsf{mutualInv}~2~1$, and $\mathsf{invOnX1}~1$  is
%equivalent to $\mathsf{invOnX1}~1$. If the invariant
%$\mathsf{invOnX1}~1$ is generated, then any formula $f$ satisfying
%$\mathsf{exLessP}~N~(\%i.f=\mathsf{invOnX1}~i)$ can be an invariant.
%$\forall i ~j.~  (i!=j) -> (n[i]=C ->!n[j]=C$, by symmetry
%reduction, we only need prove $(n[1]=C ->!n[2]=C$. Symmetry

%5Our solution to the aforementioned problem in section
%\ref{sec:provingInvSets} is to automatically generate the proof
%procedure basing on Isabelle's locale structure with the help of our
%external invariant finder. Isabelle's locale structure provide a
%strong support for modular proofs for software verification.
%Typically a locale is a parameterized theory which can be repeatedly
% instantiated (or interpreted) in different contexts. Modularity and reuse are the substantial ideal behind locale.



%As we mentioned above, we need consider two parts of proofs by   applying
%the consistency lemma  to verify the invariants $invs$.
%
%\begin{description}
%\item[(1)] For any invariant $inv \in \mathsf{invs}$, any initializing predicate $ini \in \mathsf{inis}$, any
%state $s$, if $ini$ is evaluated true at state $s$, then $inv$ is
%evaluated true at state $s$.
%\item[(2)]  For any invariant $inv \in \mathsf{invs}$, any $r$ in rule set
%$ruleset$, either $\mathsf{invHoldForRule1 }~inv~ r$,
%$\mathsf{invHoldForRule2 }~inv~ r$, $\mathsf{invHoldForRule3 }~inv~
%r~\mathsf{invs}$, or $\mathsf{invHoldForRule4 }~inv~
%r~\mathsf{invs}$ holds.
%\end{description}
%
%Normally, the proofs in both (1) and (2) preserve neatly
%%modular structures. In the next two subsections, we show our proof
%generation strategy to automatically generate them from the information collected by
% \texttt{invFinder}.

%-------------------------------------------------------------------------
%\subsection{Generating proofs for proving invariants holding at the initial state}
%-------------------------------------------------------------------------
%For an invariant $inv=\mathsf{implyForm}~ant~cons$, we only need to
%prove that either $ant$ is evaluated as false or $cons$ is evaluated
%true at an initial state $s$ in order to prove $\mathsf{formEval}
%~inv~s$. Such proof obligations can be automatically solved by
%Isabelle's $\mathsf{auto}$ command. Thus an $\mathsf{auto}$ command
%is  generated for such a proof.

%Thus we design some kinds of
% locales to generalize the proof structure of the sub proof tasks in
 %(1) by the number of parameters of the invariants and the proof method choice of choosing
 %to  prove $\mathsf{neg}~(\mathsf{antof}~inv)$  or $\mathsf{consOf}~inv$.

%According to the parameters of the invariants, and the proof method
%whether the antecedent of the invariant is proved to be false or the
%consequent of the invariant is proved to be true, we design some
%kinds of locales to implement  these kinds of proof patterns.

%For instance, we design a locale $\mathsf{iniImplyOneInvInExTwoLessPByEnableCons}$  to prove that an invariant
%$invariant$ with two parameters (e.g. $\mathsf{mutualEx1}$ has two parameters)   holds at the initial state which satisfies the initial
%predicate $ini$ by proving the consequent  of $invariant$ to be true
%according to the predicate $iniSpecOfAVar$ which is a
%specification of some state variable in the initial state. Here
%$invariant$, $ini$, and $specOfStateVariable$ are the parameters of
%the locale.



%If we can prove an invariant instance $invariantInst$ holds at the
%initial predicate instance $iniInst$ by following the proof pattern
%which is the same as the locale $\mathsf{iniImplyOneInvInExTwoLessPByEnableCons}$, a
%$\mathsf{interpretation}$ to the above locale is created by instantiating the
%formal parameters with the actual ones.

%For example, an interpretation $\mathsf{iniImply\_Inv1}$ is created to prove that the invariant
%$\mathsf{inv1}$ holds at the initial state by a specification formula  $\mathsf{iniStateSpecOfn}$, which is
%   simply defined as $\mathsf{iniStateSpecOfn}~  i \equiv  \mathsf{eqn}~ (\mathsf{IVar}~  (\mathsf{Para} ~ n~  i))~  ( \mathsf{Const}~  \mathsf{I} )
%$. In order to prove the obligation imposed by the interpretation, we also need a lemma $\mathsf{lemmaOnIni\_iniStateSpecOfn}$ which simply
%states that  $\mathsf{formEval}~\mathsf{iniStateSpecOfn}~ s$ if $\mathsf{formEval}~ini~ s$ and $ini $ is a formula to specify the initial state of the protocol.

%-------------------------------------------------------------------------
\vspace{-1cm}
\subsection{Automatical generation of Isabelle proof }
\label{sec:genOfIsabelleProof}
%-------------------------------------------------------------------------
%\begin{description}
%\item[(1)] For any invariant $inv \in \mathsf{invs}$, any initializing predicate
%$ini \in \mathsf{inis}$, any
%state $s$, if $ini$ is evaluated true at state $s$, then $inv$ is
%evaluated true at state $s$.
%\item[(2)]  For any invariant $inv \in \mathsf{invs}$, any $r$ in rule set
%$ruleset$, one of the causal relations  $\mathsf{invHoldForRule1-5}$
%holds.
%\end{description}
%
%Proof of Part (1) is quite simple. For an invariant
%$inv=\mathsf{implyForm}~ant~cons$ in $invs$, we only need to prove
%that either $ant$ is evaluated as false or $cons$ is evaluated true
%at an initial state $s$ in order to prove $\mathsf{formEval}
%~inv~s$. Such a proof  can be automatically solved by Isabelle's
%$\mathsf{auto}$ command.

A formal model in a theorem prover like Isabelle
includes the definitions of constants and rules and invariants,
lemmas, and proofs. An overview of the transformation strategy is
shown in Fig \ref{fig:mapping} from a protocol model in FL to
 the one in Isabelle. Note that the ground invariants and causal relations on the left side in Fig \ref{fig:mapping}, is stroed in the aforementioned table, which is worked out by {\sf invFinder}.


 \begin{figure}[!ht]
% \centering %
 \vspace{-0.8cm}
\includegraphics[width=1.0\textwidth]{graphOfTrans.pdf}
%\vspace{-0.5cm}
 \caption{Two figures}
\label{fig:arch}
\end{figure}
 \vspace{1cm}

%Transformations are discussed here from the ground invariants to
%parameterized ground invariants, and  from causal relations
% to  lemmas on parameterized causal relations and the corresponding proofs, main lemma and its proof.
% The   transformation
 % is just a formula generalization procedure basing on symbolic replacement of actual parameters.
 %  Recall that the principle underlying generalization is symmetry.

  For a ground formula $gInv$ with actual parameters, accordingly we
  define a formal parameterized $pInv$ with the same number of  formal
  parameters. Firstly   a formal parameterized
  invariant $pInv$ is defined by replacing the actual parameters (1,2, or 3, ......) in $gInv$ with
  symbolic variables ($i_1$, $i_2$, $i_3$, ......) accordingly; secondly    all the actual
  invariants which is symmtric to $gInv$, are defined by adopting the $ex1P$ or $ex2p$ or $ex3P$) higher-order functions in the parameterized model. The   transformation result  is illustrated as follows:

\begin{specification}

 definition inv4::nat $\Rightarrow$ formula   where [simp]:\\

       pinv4 iInv1 $\equiv$  neg ( andForm ( eqn ( IVar ( Global ''x'') )  ( Const true ))   \\

          (eqn ( IVar ( Para ''n'' iInv1) )  ( Const C )) )  \\
\\
definition invariants::nat $\Rightarrow$ formula set  where [simp] :\\
invariants N$\equiv$ \{f. ex2P N ($\lambda$ i j.  f = pinv1 i
j)  $\vee$ ex1P N ($\lambda$ i.  f= pinv2 i)  $\vee$ \\
ex2P N
($\lambda$ i j.  f = pinv3 i j)  $\vee$ ex1P N ($\lambda$ i.  f=
pinv4 i)  $\vee$ ex2P N ($\lambda$ i j.  f = pinv5 i j)   \}


\end{specification}\\
Note that $ex1P~ N~ (\lambda i.~  f=
pinv4~ i)$ is the set of all the actual invariants, each of which is symmetric to $inv4$.



 Basing on the generalization of formulas, accordingly we can generalize ground rules to formal parameterized rules and
  define all the actual rules  $ \mathsf{rules} ~N$ in the N-parameterized model.

 %in order to verify the cache coherence protocols. Others are straightforward.
The most difficult of all is the generation of proofs which requires the
highest intelligence to inspect the semantics of the protocol under
study. First we recall our paper proof. The consistency lemma is our
main weapon to prove, which requires proving two parts of
obligations.



\begin{description}
\item[(1)] For any invariant $inv \in (\mathsf{invariants} ~N) $,  any
state $s$, if $ini$ is evaluated true at state $s$, then $inv$ is
evaluated true at state $s$.
\item[(2)]  For any invariant $inv \in (\mathsf{invariants} ~N)$, any $r$ in rule set
$ \mathsf{rules} ~N$ , one of the causal relations
$\mathsf{invHoldForRule}_{1-3}$ holds.
\end{description}

An overview of a formal proof of Part (2) generated by {\tt
proofGen} is illustrated as follows. Here, it is a typically
readable proof in Isar style \cite{}, which uses   calculation
reasoning such as {\tt moreover} and {\tt ultimately} to do  case analysis on
the form of rules and the invariants. Lines 1-5 use proper Isabelle
proof commands to   decompose the main proof goal of forall  and
implication form,  fix a rule {\tt r} and {\tt inv}, then have two
assumptions {\tt  b1: inv$\in$ invariants N  and b2:r $\in$ rules
N}, now  the goal {\tt invHoldForRule inv r (invariants
N)} is  needed show. line 5 splits cases of $r$ into all possible cases according to
the definition of $rules~N$. Line 6 starts the case analysis when
{\tt ex1P N ($\lambda$i.r=try~ i)}. Line 7 again splits cases of $inv$ into all possible cases
according to the definition of $invariants~N$. Line 8-10 proves the
goal at case when {\tt ex1P N ($\lambda$i.r=try~ i)} and {\tt ex1P N $inv=inv_1~i~j$}. At line 10,  a defined
lemma {\tt tryVsInv$_1$}  is directly applied to solve the proof
goal. The generation of a lemma {\tt tryVsInv$_1$} will be
discussed next. Similarly, we can do other case analysis on other kind of $inv$. Lines 12-18 finish the case when {\tt $\lambda$i.r=idle~ i} accordingly.


\begin{specification}
1\twoSpaces  show  $\forall$inv r. inv $\in$ invariants
N$\longrightarrow$
 r $\in$rules N$\longrightarrow$invHoldForRule inv r (invariants N) \\

2\twoSpaces    proof((rule allI)+,(rule impI)+)\\
3\twoSpaces    fix inv r ~~\\

4\twoSpaces   assume b1: inv$\in$ invariants N  and b2:r $\in$ rules N\\

5\twoSpaces   have c1:ex1P N ($\lambda$i.r=crit~ i)$\vee$...$\vee$ex1P N ($\lambda$i.r=idle~i)\\

\twoSpaces ~~ ~~         by(cut$\_$tac  b2,auto)\\

6\twoSpaces  moreover$\{$assume c1:
  ex1P N ($\lambda$i.r=crit~i)\\

7\twoSpaces \twoSpaces   have d1:ex2P N($\lambda$i~j.inv=inv$_{1}$~i~j)$\vee$ex1P N($\lambda$i.inv=inv$_{2}$~i)...$\vee$ex2P N
($\lambda$i~j.inv=inv$_{5}$~i~j)\\
\twoSpaces \twoSpaces   ~by (cut$\_$tac b1, simp )\\
%\twoSpaces \twoSpaces  $\vee$ex3P N
%($\lambda$i~j~k.inv=inv$_{3}$~i~j~k) \twoSpaces \twoSpaces   ~by (cut$\_$tac b1, simp )\\

8\twoSpaces\twoSpaces moreover $\{$assume d1:  ex2P N($\lambda$i~j.inv=inv$_{1}$~ i~j)\\
\twoSpaces\twoSpaces~ from d1 obtain i$_1$ i$_2$ where where d2:inv=inv$_{3}$~i$_1$~i$_2$ ~~by(cut\_tac d1,auto)\\
\twoSpaces\twoSpaces~have invHoldForRule inv~ r (invariants N)
\twoSpaces\twoSpaces by(cut\_tac c1 d1,simp, rule tryVsinv$_1)\}$\\

\twoSpaces\twoSpaces\twoSpaces\twoSpaces ...\\

9\twoSpaces\twoSpaces moreover $\{$assume d1:  ex1P N~($\lambda$i.inv=inv$_{3}$~i).\\
\twoSpaces\twoSpaces ~ from d1 obtain i$_1$  where d2: inv=inv$_{1}$~i$_1$~~by(cut\_tac d1,auto)\\
\twoSpaces\twoSpaces~ have invHoldForRule inv r (invariants N)
\twoSpaces\twoSpaces by(cut\_tac c1 d1,simp, rule tryVsinv$_3$)\}
\\

\twoSpaces\twoSpaces\twoSpaces\twoSpaces ...\\

10\twoSpaces\twoSpaces moreover $\{$assume d1:  ex2P N~($\lambda$i~j.inv=inv$_{5}$~i~j)\\
\twoSpaces\twoSpaces  ~from d1 obtain i$_1$ i$_2$ where d2:inv=inv$_{5}$~i$_1$~i$_2$ ~~by(cut\_tac d1,auto)\\
\twoSpaces\twoSpaces  ~have invHoldForRule inv r (invariants N)
\twoSpaces\twoSpaces by(cut$\_$tac c1 d1,simp, rule
tryVsinv$_5)\}$\\

11\twoSpaces ultimately have invHoldForRule inv r (invariants N)     by blast\}\\
\twoSpaces\twoSpaces ...\\
\twoSpaces\twoSpaces ...\\


12\twoSpaces   moreover $\{$assume c1: ex1P N ($\lambda$i.r=idle~i)\\

13\twoSpaces   from c1 obtain i   where c1: r=idle~i    ~~by(cut\_tac d1,auto)\\

14\twoSpaces \twoSpaces   have d1:ex2P N($\lambda$i~j.inv=inv$_{1}$~i~j)$\vee$ex1P N($\lambda$i.inv=inv$_{2}$~i)...$\vee$ex2P N
($\lambda$i~j.inv=inv$_{5}$~i~j)\\
\twoSpaces \twoSpaces   ~by (cut$\_$tac b1, simp )\\
%\twoSpaces \twoSpaces  $\vee$ex3P N
%($\lambda$i~j~k.inv=inv$_{3}$~i~j~k) \twoSpaces \twoSpaces   ~by (cut$\_$tac b1, simp )\\

15\twoSpaces\twoSpaces moreover $\{$assume d1:  ex2P N($\lambda$i~j.inv=inv$_{1}$~ i~j)\\
\twoSpaces\twoSpaces~ from d1 obtain i$_1$ i$_2$ where where d2:inv=inv$_{3}$~i$_1$~i$_2$ ~~by(cut\_tac d1,auto)\\
\twoSpaces\twoSpaces~have invHoldForRule inv~ r (invariants N)
\twoSpaces\twoSpaces by(cut\_tac c1 d1,simp, rule idleVsinv$_1)\}$\\

\twoSpaces\twoSpaces\twoSpaces\twoSpaces ...\\

16\twoSpaces\twoSpaces moreover $\{$assume d1:  ex1P N~($\lambda$i.inv=inv$_{3}$~i).\\
\twoSpaces\twoSpaces ~ from d1 obtain i$_1$  where d2: inv=inv$_{1}$~i$_1$~~by(cut\_tac d1,auto)\\
\twoSpaces\twoSpaces~ have invHoldForRule inv r (invariants N)
\twoSpaces\twoSpaces by(cut\_tac c1 d1,simp, rule idleVsinv$_3$)\}
\\

\twoSpaces\twoSpaces\twoSpaces\twoSpaces ...\\

17\twoSpaces\twoSpaces moreover $\{$assume d1:  ex2P N~($\lambda$i~j.inv=inv$_{5}$~i~j)\\
\twoSpaces\twoSpaces  ~from d1 obtain i$_1$ i$_2$ where d2:inv=inv$_{5}$~i$_1$~i$_2$ ~~by(cut\_tac d1,auto)\\
\twoSpaces\twoSpaces  ~have invHoldForRule inv r (invariants N)
\twoSpaces\twoSpaces by(cut$\_$tac c1 d1,simp, rule
idleVsinv$_5)\}$\\

18\twoSpaces ultimately have invHoldForRule inv r (invariants N)     by blast\}\\
\twoSpaces\twoSpaces ...\\
\twoSpaces\twoSpaces ...\\

19ultimately show invHoldForRule inv r (invariants N)     by blast\\
20qed
\end{specification}


Due to the unified style in which consistency lemma is applied, the proof
can be generated automatically by a two-levels of loop of analysis
on items of aforementioned $rules~N$ and $invarians~N$. Proof
command of case analysis on rules at line 5 or on invariants at line
7 will  a disjunction of all the formulas in the definition of
$rules~N$ and $invarians~N$ respectively. For each proof of the
subcase when {\tt r =r$_i$} and {\tt inv=inv$_j$} like 16 will be
created according to a simple proof template and  the names of the
rule and invariant. Such a proof template is designed according
according to the parameter numbers of a rule and invariant
respectively.

Now we discuss how to generate each lemma {\tt r$_i$Vsinv$_j$},
which will be applied in the proof of main lemma. First an lemma like
{\tt critVsinv$_1$} and its proof is illustrated as follows:

\begin{specification}
1lemma critVsinv1:\\
2  assumes  a2: iR $\le$ N and a3: i1 $\le$ N and a4: i2 $\le$ N\\
3  shows  invHoldForRule (inv1 i1 i2) (crit iRule) (invariants
  N)\\
4  proof -\\
5  have iR=i1 $\vee$ iR=i2 $\vee$ (iR $\ne$ i1 $\wedge$  iR $\ne$ i2) by auto\\

6  moreover\{assume  b1:iR=i1\\
7  \twoSpaces have invHoldForRule3 (inv1 i1 i2) (crit iR) (invariants N)\\
 \twoSpaces  \twoSpaces   proof(simp, rule\_tac x=$\neg$ (x=true $\wedge$ n[i2]=C)  in exI,auto)qed\\
8  \twoSpaces then have invHoldForRule (inv1 i1 i2) (crit iR)
(invariants
  N)
by auto\}\\

9  moreover\{assume  b1:iR=i2\\
10 \twoSpaces have invHoldForRule3' (inv1 i1 i2) (crit iRule) (invariants N)\\
 \twoSpaces \twoSpaces   proof(simp, rule\_tac x=$\neg$ (x=true $\wedge$ n[i1]=C  in exI,auto)qed\\
11 \twoSpaces then have invHoldForRule (inv1 i1 i2) (crit iR) (invariants
  N)
by auto\}\\

12   moreover\{assume  b1:(iR $\ne$  i1    iR $\ne$  i2)\\
13 \twoSpaces have invHoldForRule2 (inv1 i1 i2) (crit iR) (invariants N)\\
  \twoSpaces \twoSpaces  proof( auto) qed\\
14 \twoSpaces then have invHoldForRule (inv1 i1 i2) (crit iR)
(invariants
  N)
by auto\} \\

15ultimately show invHoldForRule (inv1 i1 i2) (crit iR)
(invariants N)\\
16qed\\
\end{specification}

line 5 splits cases of $iR$ into all possible cases by comparing
$iR$ with $i_1$ and $i_2$. Line 6-9 proves the case   where
$iR=i_1$; Lines  10-12     the case   where $iR=i_2$; Lines 13-16
the case   where neither $iR=i_1$ nor $iR=i_2$.





The aforementioned proof can be generated by instantiating the following pattern by adding {\tt rule},
{\tt inv}, {\tt proof1}, {\tt proof2}, {\tt proof3} with rule name {\tt crit} and invariant name {\tt inv} in proper places of function  creatLemmaRule1Inv2. This pattern works for   a parameterized rule with only one parameter and an invariant
 with two parameters.
%pattern of case analysis on the parameters  is determined by the number of parameters of
%the invariant and rule, which can be formalized by a proof template. Lines 1-5, 6, 9, 10, 13, 14, 17 18,19 can be resused by replacing the names of rule and
% invariant respectively.
Detail proofs such as lines  7, 10, 13 are generated according to the lines on {\tt crit} and {\tt inv1} in Table \ref{}. The mapping is based on the symmetry mapping. Recall the  parameters instantiation policies we discussed in section \ref{},. {\t proof1} ({\t proof2}, {\t proof3}) at line 7(10,13)  is according with the 2nd (3rd, 4th) line in Table because the latter case is the representive of the former case in the sense of symmetry. Lines 17-19 are function {\tt createProof} which are used to create proofs by the causal relations.  Among the three causal relations, the proofs are simple which are according to $\mathsf{invHoldForRule_{1}}$ and $\mathsf{invHoldForRule_{2}}$. an {\tt auto} command is enough because such a goal can be solved automatically in Isabelle. A proof, which is according with $\mathsf{invHoldForRule_{3}}$, needs an existence construction by providing an auxiliary invariant formula {\tt inv}.




\begin{specification}
let creatLemmaRule1Inv1 rule inv=sprintf\\

1"lemma \%sVs\%s:\\
2  assumes  a2: iR $\le$ N and a3: i1 $\le$ N and a4: i2 $\le$ N\\
3  shows  invHoldForRule (\%s i1 i2) (\%s iRule) (invariants
  N)\\
4  proof -\\
5  have iR=i1 $\vee$ iR=i2 $\vee$ (iR $\ne$ i1 $\wedge$  iR $\ne$ i2) by auto\\

6  moreover\{assume  b1:iR=i1\\
7  \twoSpaces \%s\\
8  \twoSpaces then have invHoldForRule (\%s i1 i2) (\%s iR)
(invariants
  N)
by auto\}\\
9  moreover\{assume  b1:iR=i2\\
10  \twoSpaces \%s\\

11 \twoSpaces then have invHoldForRule (\%s i1 i2) (\%s iR)
(invariants
  N)\\

12   moreover\{assume  b1:(iR $\ne$  i1    iR $\ne$  i2)\\
13  \twoSpaces \%s\\
14  \twoSpaces then have invHoldForRule (\%s i1 i2) (\%s iR)
(invariants
  N)  \\

15ultimately show invHoldForRule (\%s i1 i2) (\%s iR) (invariants   N)\\
16qed" ~~~  (rule,inv,\\
       ~~~    inv,rule, \\
       ~~~     proof1,inv,rule,\\
       ~~~    proof2, inv,rule,\\
       ~~~    proof3,inv,rule,\\
       ~~    inv,rule)\\
\\

17let createProof      (invHoldForRule1)=createProofOfKind1\\
18/$\backslash$ createProof     (invHoldForRule2)=createProofOfKind2\\
19/$\backslash$
 createProof  (invHoldForRule3 inv ) = createProofOfKind3 inv \\
 \\
20let createProofOfKind3 inv  =\\
21let invStr=( (formula2Isabellestr   inv))  then sprintf\\
22 "have ?P23\\

23        apply (-,cut\_tac c1 c2 c3, simp)\\
24        by(rule\_tac x=\%s in exI,auto)"~ (invStr)\\


\end{specification}

For other kinds of invariants and rules, we also can design some templates to create proofs accordingly. 

%=========================================
\section{Experiments}
%=========================================
\vspace{-0.2cm}
 Besides the simple mutual exclusion protocol, we have conducted experiments on a number
of cache coherence protocols, including typical bus-snoopy protocols
such as MESI and MOESI,
 directory-based protocols such as  Germanish, and  German protocols.
Table~\ref{Summarization of experiment results} summarizes  our
experimental results below. Among the benchmarks, the German
protocol was posted as a challenge to the formal verification
community by Steven German in 2000. The proof script is about 2.2M,
which is far larger than an usual  proof script and costs more than
56 minutes for Isabelle to check in a 64-bit computing server
platform which has a 160-multicore Intel Xeon CPU with 2.40GHz clock
speed. \footnote{Size of an usual Isabelle proof script is about
20k-50k.}
%
For the proof scripts of the above case studies, interesting readers
are referred to~\cite{LiCache13}.
%The proof script in Isar for the protocol {\tt simpMutual} consists
%of 3211 lines, which is automatically generated by
%\texttt{proofGen}. We refer interested readers to~\cite{LiCache13}
%for details.

\begin{table}[!t] \label{Summarization of experiment results}
\centering \caption{Summarization of experimental results on benchmarks}
\begin{tabular}{|c| r | r | r | r |}
\hline
~~protocol~~ &  ~~\#rules~~ & \#invariants & \#lines of codes & verification time  \\
\hline
simpMutual& 4& 5 & 2,024 & 0:39.623 \\
\hline
MESI & 4& 3 & 1,540 & 0:38.695  \\
\hline
MOESI &  5& 3 &2,942 & 0:37.874  \\
\hline
 German-ish  & 6& 4 &3,670 & 1:05.158  \\
\hline
German & 13 & 48 & 76,500 & 56:18.288   \\
\hline
\end{tabular}
\end{table}

\vspace{-0.5cm}
%=========================================
\section{Conclusion and future work}
%=========================================
In this paper, we have presented an approach
for parameterized verification of cache coherence protocol.
The novelty of our work mainly lies in two aspects: (1)
instead of directly proving the invariants by induction, we propose
a general proof method based on the consistency theorem to decompose the complex
and main proof goal into a large number of small goals which
preserve a similar proof pattern; (2) instead of proving the
decomposed subgoals by hand, we automatically generate proofs for them from the
information computed in a small protocol instance of the protocol.%
%In more details, we automatically generate proof scripts from the
%general proof patterns drawn from the information computed in a
%small  instance of the protocol.
This is mainly due to the fact that parameterized proof of a cache
coherence protocol should share the same proof patterns which are
suitable for a ground proof of a small
protocol instance. %We generalize the ground proof information to a
%general and parametric proof. Isabelle's locale feature provides a
%good support for us to implement the automatically generating
%procedures.

Our work is an excellent case where mechanical provers can do much
better than human being where the proofs are long and tedious but
sharing some typical proof patterns. For instance, the number of
proof cases in German protocol verification are about 1500, and the
proof script contains about 76500 lines. Such a long proof task is
beyond a human's ability. We believe, theorem prover + proof
generator is   promising in applying the theorem prover to the
formal verification of industry scale-case. The former can guarantee
the rigorousness, while the other can release the burden of human's
interaction. In the future, we try to extend our work to the
parameterized verification problems of distributing systems and
cloud-service storing systems. \vspace{-0.5cm}
\bibliographystyle{plain}
\bibliography{cache,refer}
\end{document}

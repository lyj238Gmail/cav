



Help Log out

CAV 2015 (author)


Submission 108 CAV 2015 EasyChair
















Author Response Information for Submission 108


Response Letter(s)

Response Letter
Response: In general, we really appreciate the reviewers¡¯ constructive and inspiring comments. In this letter, we have carefully given our rebuttal answers to the major comments, and we will address all the minor comments in a revised version of our paper.


*Main ideas of our work*

The main motivation of our work is to apply generic interactive theorem provers (ITP) such as Isabelle to real-world verification problems. Higher-order logics, which are supported by ITP, have the expressiveness to model most real-world systems. However, the weakness of ITP lies in the need of much human guidance, which results in the less degree of automation. In our work, we combine proof generation with classic ITP. The latter can guarantee the rigorousness of generated proofs, while the former can bring in automation. Briefly speaking, we design special proof tacticals and the according generation procedures for parameterized verification, which is a novel study in the field of ITP.

We have successfully verified the mutual exclusion property of the FLASH protocol, resulting into an independent and different proof from the literature. As Chou, Mannava, Park pointed out in their FMCAD 2004 paper [6], FLASH is a good benchmark for any proposed method for parameterized verification: ¡°if the method works on FLASH, then there is a good chance that it will also work on many real-world cache coherence protocols¡±. Therefore, our approach has reached this most important landmark. Especially, we demonstrate that ITP combined with automatic proof generation is very promising.


*Answer to 1st Reviewer¡¯s comment*

Comment: My main concern with this paper is that there is no comparison with other approaches.

Answer: The comparison has been implicitly mentioned in Section 1 (the third paragraph). It discussed that many existing approaches need human interaction to search for invariants, while the others need to be justified by providing more sound theoretical foundation, preferably mechanically checked. The originality of our work is to provide a unified, rigorous and automated framework to solve the problem of parameterized verification. No exiting work can provide a framework of all the three features.

We can give more detailed comparison if we have more space in the paper. For instance, in Section 5 of [6], the authors state that the first priority is clearly mechanization. Our work has completely realized their statement. Second, our proof of FLASH is different from the one of Park et al [2], because they introduce the aggressioned Flash protocol model, which is in fact an abstract transaction model of FLASH. Deep human insight for FLASH is needed for both the construction of the aggressioned model and introducing new state variables. Later research on FLASH also relies on these auxiliary state variables for verification. Our work does not need these state variables and require less humans interaction for the verification of FLASH.


*Answer to both 2nd and 3rd Reviewers¡¯ comment*

We thank the reviewers for their positive evaluation of our work. Both reviewers pose a similar question, namely, how invariants are generated within our framework.

Here, let us first emphasize that not only invariants, but also the causal relations between the invariants and the protocol rules must be recorded. In Section 1, we state that ¡°it (invFinder) is heuristics-inspired by trying to construct the consistency relation that guides the tool invFinder to find auxiliary invariants.¡± Later in page 5, we explain the mechanism in more details (not fully detailed due to the page limit). Especially, we mentioned that invFinder is driven by the attempt to construct one of the causal relations, and it adopts NuSMV and Z3 to choose a proper candidate if there exists one. Thus a (newly) constructed invariant must satisfy one of the relations in Definition 1. In our framework, a table, e.g., Tab 1 in the paper, is used to record this information between invariants and protocol rules: for each generated invariant, it records the applied protocol rule and one of the identified causal relation. We hope that the above explanation can clarify how invFinder works.


*Answer to 4th Reviewer¡¯ comment*

Question 1: It is not clear to me why separating invariants into three groups (casual relation 1, 2, 3) is beneficial.

Answer: Note that causal relations, instead of invariants, are categorized into three groups. They capture whether and how the execution of a particular protocol rule changes the protocol state variables appearing in an invariant. More importantly, the relations can be considered as induction proof tactics designed for automatic proof generation, in a way that proofGen only generates proofs of such a style. Generated proofs can be automatically checked by Isabelle.

Question 2: how paraVerifier guides invFinder and how invFinder finds invariants?

Answer: invFinder is one of the two essential parts of paraVerifier, and the other one is proofGen. Please check Figure 1 in our paper for the workflow of paraVerifier. Please find above our answer to the second part of the question.

Question 3: Have you tried checking other safety properties than mutual exclusion?

Answer: Besides mutual exclusion properties, data coherence properties are also studied, for example, in GermanData protocol. Invariants are still the most common properties studied in this field. So far, we have not carried out the work on other safety properties. However, we plan to generalize our framework to safety properties that can be inductively defined. In this way, our approach will be generalized and become more useful.

Question 4: In [14] GermanWithData.zip is not present.

Answer: The link error has been fixed.

Question 5: flash.zip contains 231 thy files -- how they were generated?

Answer: Some explanation on the verification of FLASH was given on the website [14]: FLASH is more complex than the other case studies. Briefly speaking, all the thy files are generated by calling the tool proofGen with proper parameters specified in separated files to generate the proofs. We will re-design the website to explain how to achieve this clearly. This short paper focuses on the main ideas and contributions of our research, without emphasis on demonstrating our tool.
Time:  Mar 26, 12:24 GMT
Letter: Dear [*FIRST-NAME*],

Thank you for your submission to CAV 2015. The CAV 2015 review
response period will be between March 23 and March 26, 2015.

During this time, you will have access to the current state of your
reviews and have the opportunity to submit a response of up to 1000
words. Please keep in mind the following during this process:

* The response must focus on any factual errors in the reviews and
any questions posed by the reviewers. It must not provide new
research results or reformulate the presentation. Try to be as
concise and to the point as possible.

* The review response period is an opportunity to react to the
reviews, but not a requirement to do so. Thus, if you feel the
reviews are accurate and the reviewers have not asked any
questions, then you do not have to respond.

* The reviews are as submitted by the PC members, without any
coordination between them. Thus, there may be inconsistencies.
Furthermore, these are not the final versions of the reviews. The
reviews can later be updated to take into account the discussions
at the program committee meeting, and we may find it necessary to
solicit other reviews after the review response period.

* The program committee will read your responses carefully and take
this information into account during the discussions. On the other
hand, the program committee will not directly respond to your
responses, either before the program committee meeting or in the
final versions of the reviews.

* Your response will be seen by all PC members who have access to
the discussion of your paper, so please try to be polite and
constructive.

The reviews on your paper are attached to this letter. To submit
your response you should log on the EasyChair Web site for CAV 2015
and select your submission on the menu.

[*REVIEWS*]

Best wishes,

Corina & Daniel
Time:  Mar 23, 18:10 GMT

Reviews

Review 1
Overall evaluation: -1: (weak reject)
Reviewer's confidence: 4: (high)
Review: The paper presents paraVerifier, a tool for the verification of parametrized cache coherence protocols. paraVerifier consists of two parts: an invariant finder (invFinder), and a proof generator (proofGen). First, a reference model of the protocol with a fixed parameter is computed and model checked. invFinder searches for interesting auxiliary invariants and causal relations that allow to prove an invariant inv. Then, proofGen constructs a complete and parametrized formal proof in a theorem prover. Some experimental results are reported.

My main concern with this paper is that there is no comparision with other approaches.
Indeed, parametrized verification of protocols was extensively considered in the litterature. So, why use the approach proposed by the authors and not another one?
The authors have to compare their tool and their approach with the existing ones before publication.

Review 2
Overall evaluation: 2: (accept)
Reviewer's confidence: 4: (high)
Review: This short paper describes a tool called paraVerifier that generates
invariants for parameterized protocols (the application in the paper
is cache protocols, but the tools does not seem to be specialized to
this problem). The tool is not when to prove any protocols that cannot
be proved by existing methods, but has the advantage that it is simple
and generates a proof that can be rigorously checked by Isabelle.

The tool works in two steps. First it generates auxiliary invariants
for a finite instance of the protocol. Then it generalizes the ground
formulas to universally quantified formulas, and emits a proof script
to verify that these formulas are in fact inductive.

This is very similar in principle to the invisible invariants method
and similar methods in the literature that generalize from finite
instances. Some difference include that invisible invariants generates
the strongest inductive invariant, while this method is more
property-driven, and invisible invariants uses a small model theorem
to prove the parameterized case while this method uses a theorem
prover.

Two issues with the paper are that it does not property explain how
candidate auxiliary invariants are chosen for the finite instance, and
it does not properly describe the relation to prior work. They may be
partly the fault of the short format.

In a way, the degree of novelty here is not that great, since the
actual invariant generation method is fairly similar to existing
methods. On the other hand, the fact that it generates a checkable
proof seems an advantage in terms of security, and might allow
invariants generated by the tool to be used in context of a larger
manual proof.


Def 1, part 2: Does "=" here mean syntactic equality?

Also, part 3 seems to subsume parts 1 and 2, so long as F is
non-empty. Why do you need parts 1 and 2? Why does part 3 allow only
one f' in F to be used? Isn't that a bit restrictive?

Def 2: formEval is undefined here (so is the term "evaluated").

Lemma 1: you shouldn't really define a term inside your lemma.

running example, line 6: quotation mark problem

Page 5: How does InvGen choose candidate auxiliary invariants? Are
these just the (weakest liberal) preconditions mentioned in Def 1 part
3? Are they simplified in some way? How similar is this to existing
techniques>

Page 6: What do you mean by "symmetry relations"? What if you need an
existential quantifier in the invariant?

Review 3
Overall evaluation: 0: (borderline paper)
Reviewer's confidence: 4: (high)
Review: This paper describes a system, implemented as a combination of Isabelle with NuSMV and Z3, to verify cache coherency protocols in a parametric manner.

The essential idea is as follows: (1) invariants discovered for small instances are generalized to candidate invariants for the parametric case (e.g., by replacing indexes 0 and 1 with i and j), then (2) the candidate invariants, along with a hint as to their invariance proof, are entered into Isabelle and checked automatically. The experiments show that this strategy works for several example protocols.

This method is not new, it is essentially a variant of the "invisible invariant" method of ref [4], which was implemented in a tool [Ittai Balaban, Yi Fang, Amir Pnueli, Lenore D. Zuck: IIV: An Invisible Invariant Verifier. CAV 2005]. The invisible invariant method relies on a small model theorem for step (2); instead, this tool uses a general purpose theorem prover. That allows for more freedom in the choice of invariants, as they do not have to be subject to the restrictions of the small model theorem.

A key omission in this paper is a discussion of how the tool finds the candiate invariants. The only discussion is the rather vague statement that "invFinder repeatedly tries to find new invariants ... by constructing the causal relation between the invariants and the protocol rules." It is hard to figure out what this should mean.

As invariant generation is the central part of the technique (as generalization follows a fixed pattern) this omission is unfortunate.

Review 4
Overall evaluation: -1: (weak reject)
Reviewer's confidence: 3: (medium)
Review: The paper addresses the problem of parameterized model checking of Cache
Coherence (CC) protocols. The authors suggest the approach:

1. instantiate a small instance of a CC protocol
2. find invariants using `invFinder`
3. parameterize invariants found in (2) using `proofGen`
4. generate a proof task of proving parameterized invariants found in (3)
5. prove the task using `Isabelle`

The approach works for safety properties only. In step (3) the authors use the
symmetry argument and parameterize all the concrete indices. The approach and
its implementation are the main contributions.

For the _tool_ paper I would expect a better quality of the tool (the approach
itself is interesting and I like this line of research):
- may be separate implementation files from the protocol descriptions? So it is
 clear where is the implementation (and the main contribution) and where are
 examples.
- may be add a manual smth like 'steps to check your own CC protocol'?


REBUTTAL QUESTIONS:
- It is not clear to me why separating invariants into three groups (casual
 relation 1, 2, 3) is beneficial. Could you elaborate on this?
- _how_ paraVerifier guides invFinder and _how_ infFinder finds invariants?
- Have you tried checking other safety properties than mutual exclusion? (and
 are any other interesting safety properties for CCs?)
- In [13] GermanWithData.zip is not present
- flash.zip contains 231 thy files -- how they were generated?


Minor:
- the paper uses -> and =>, is there a difference?
- expEval is defined but not used
- parameterized invariants are prefixed with \exists -- is this because the
 actual invariants are negated? If not, why do use \exists instead of \forall?
- Are Murphi used in the framework? How?
- Does the timing in the table include Isabelle proof timing?

Copyright ? 2002¨C2015 EasyChair

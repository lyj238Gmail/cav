\documentclass{llncs}
%%%%%%%%%%%%%%%%%%%%%%
%%%%   PACKAGES   %%%%
%%%%%%%%%%%%%%%%%%%%%%
\usepackage{makeidx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{latexsym}
\usepackage{url}
\usepackage{color}
\usepackage{isabelle}
\usepackage{isabellesym}
\usepackage{theorem}
\usepackage{algorithmic}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
%\usepackage{program}
\usepackage{cases}

\newcommand\lyj[1]{\textcolor{red}{ #1} }

\newlength{\fminilength}
\newsavebox{\fminibox}
\newenvironment{fmini}[1][\linewidth]
  {\setlength{\fminilength}{#1\fboxsep-2\fboxrule}%
   \vspace{2ex}\noindent\begin{lrbox}{\fminibox}\begin{minipage}{\fminilength}%
   \mbox{ }\hfill\vspace{-2.5ex}}%
  {\end{minipage}\end{lrbox}\vspace{1ex}\hspace{0ex}%
   \framebox{\usebox{\fminibox}}}

\newenvironment{specification}
{\noindent\scriptsize
\tt\begin{fmini}\begin{tabbing}X\=X12345\=XXXX\=XXXX\=XXXX\=XXXX\=XXXX
\=\+\kill} {\end{tabbing}\normalfont\end{fmini}}
\def \twoSpaces {\ \ }
\def \oneSpace {\ }
\def \eqc {\doteq }
\def \andc {\barwedge }
\def \negc {!}
\def \orc {\veebar }
\def \alt {$/\backslash$ }
\def \cat {\symbol{94}}

\def \dbRight {$\backslash\backslash$}
\def \iInv {iInv}
\def \iR {iR}


\input{tcilatex}

%=========================================
\begin{document}

\title{ Appendix }
\titlerunning{Appendix}
\author{~}
\authorrunning{~}
\institute{~}

\maketitle

\section{Formal Semantics of Expressions and Formulas}

Formal semantics of expressions and formulas are given in HOL (higer-order logics) as Table \ref{table-semantics-exp-formula} shows. \footnote{The  logic to specify parameterized system is a special logic, which can be embedded in HOL supported by Isabelle. Therefore HOL can be seen as the main meta-logic to specify our work.}

\begin{table}[h] \label{table-semantics-exp-formula}
\center\begin{tabular}{|l|l|}
  \hline
   Semantics \\ \hline
  $\mathbb{A}[v,s]\equiv s(v)$, where  $v$ is a variable\\
    $\mathbb{A}[c,s]\equiv c$, where  $c$ is a constant\\
   $\mathbb{A}[f?e_1:e_2,s]\equiv$if ($\mathbb{B}[f,s]$) then $\mathbb{A}[e_1,s]$ else $\mathbb{A}[e_2,s]$ \\
  $\mathbb{B}[ e_1\doteq e_2,s]\equiv   \mathbb{A}[e_1,s]=\mathbb{A}[e_2,s]$  \\
  $\mathbb{B}[\negc f,s]\equiv \neg \mathbb{B}[f,s]$ \\
  $\mathbb{B}[f_1\andc f_2,s]\equiv \mathbb{B}[f_1,s] \land \mathbb{B}[f_1,s]$ \\
  $\mathbb{B}[f_1\orc f_2,s]\equiv \mathbb{B}[f_1,s] \vee \mathbb{B}[f_2,s]$ \\
 $\mathbb{B}[f_1\dashrightarrow f_2,s]\equiv \mathbb{B}[f_1,s]$  implies $\mathbb{B}[f_2,s]$ \\
 %  $\mathbb{B}[f_1\longleftrightarrow f_2,s]\equiv \mathbb{B}[f_1,s]$  if and only if $\mathbb{B}[f_2,s]$ \\
  \hline
\end{tabular}
\end{table}


%=========================================
\section{Computing a Quotient of $\mathsf{perms}_{m}^{n}$}

Algorithm \ref{alg:computeSemiPerms} computes a quotient of $\mathsf{perms}_{m}^{n}$.   Firstly it set $S_0=\mathsf{perms}_m^n$,  then we fetch the head element of $S_0$ into $L$, and find whether there is an element $L'$ in $S$ s.t. $L\sim_m^n L'$. If  yes, then $L$ will be discarded, else $L$ is inserted into $S$. This procedure is repeated until $S$ is empty.


\begin{algorithm}\label{alg:computeSemiPerms}
\caption{Computing quotient of $\mathsf{perms}_{m}^{n}$: $cmpSemiperm$}%\label{alg:invfinderII}

\KwIn{$m$, $n$     }

\KwOut{A permutation set $S$}

{%\label{specialcaseStart}


    %$inv'\leftarrow preCond(inv, S)$\;

 % \If{$m=0 \vee n=0$  }
  %    {
   %   $S\leftarrow \emptyset $\;
  %   \Return $S$\;
  %    }
%\label{specialcaseEnd}
  %  \Else
   %   {
    $S_0\leftarrow \mathsf{perms}_m^n$\;
     $S\leftarrow \emptyset $\;
     \While{$S_0 \neq \emptyset$}
      {$L \leftarrow \mathsf{hd}(S_0)$\;
       $S_0 \leftarrow \mathsf{tl}(S_0)$\;
       \If{$\mathsf{find}(\simeq_m^n(L), S)=NONE$}
        { $S\leftarrow S@[L]$\;}
      }
    \Return $S$\;
  %  }
}

\end{algorithm}

In order to understand this algorithm, we need understand the following:
\begin{itemize}
\item a $n$-permutation of $m$ is ordered arrangement of a $n$--element subset of an $m$-element set $I=\{i. 0<i\le m\}$. We use a list with size $n$ to stand for a $n$-permutation of $m$, whose elements are mutually different from each other and taken from $I$.  For instance, $[1,2]$ is a 2-permuatation of 3.  $\mathsf{perms}_{m}^{n}$ is the set of all $n$-permutations of $m$. There have been a lot of algorithms to compute $\mathsf{perms}_{m}^{n}$, so we only list examples: $\mathsf{perms}_{m}^{0}=[]$, $\mathsf{perms}_{3}^{2}=[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]$. Number of elements in $\mathsf{perms}_{m}^{n}=\frac{m!}{(m-n)!}$.

\item  According to the definition of $simeq_m^n$ in the main paper, we list some examples to illustrate the the above algorithm.

\begin{itemize}
\item When $m=3$ and $n=2$, then the output should be the same as  $\mathsf{perms}_{3}^{2}$.

\item  When $m=3$ and $n=1$, then the output should be the same as  $\mathsf{perms}_{3}^{1}$.

\item  When $m=4$ and $n=2$, then the output should be $[[1,2],[1,3],[2,1],[2,3],$\ $[3,1],[3,2],[3,4]]$, which is a true  subset of $\mathsf{perms}_{4}^{2}=[[1,2],[1,3],[1,4],[2,1],$\ $ [2,3],[2,4],[3,1],[3,2],[3,4],[4,1],[4,2],[4,3]]$.

\item When $m=2$ and $n=0$,  then the output should be [].

\item When $m=2$ and $n=2$, then the output should be [[1,2]], which is a true subset of $\mathsf{perms}_{2}^{2}$.
 \end{itemize}


\end{itemize}

\section{Concepts in the Definition of Isabelle Script}
In order to understand the concepts of generalization, it may be better to read an glimpse of a formal proof script.
 Let us see the definition of this proof scripts at first.

theory n\_mutualEx\_base imports paraTheory\\
begin\\
\subsection{ Definitions of Constants }
definition I::"scalrValueType" where [simp]: "I$\equiv$ enum ''control'' ''I''"\\
definition T::"scalrValueType" where [simp]: "T$\equiv$ enum ''control'' ''T''"\\
definition C::"scalrValueType" where [simp]: "C$\equiv$ enum ''control'' ''C''"\\
definition E::"scalrValueType" where [simp]: "E$\equiv$ enum ''control'' ''E''"\\
definition true::"scalrValueType" where [simp]: "true$\equiv$ boolV True"\\
definition false::"scalrValueType" where [simp]: "false$\equiv$ boolV False"\\
\subsection{  Definitions of Parameterized Rules }
definition n\_Try::"nat $\Rightarrow$ rule" where [simp]:\\
"n\_Try  i$\equiv$\\
let g = (eqn (IVar (Para (Ident ''n'') i)) (Const I)) in\\
let s = (parallelList [(assign ((Para (Ident ''n'') i), (Const T)))]) in\\
guard g s"\\
\\
definition n\_Crit::"nat $\Rightarrow$ rule" where [simp]:\\
"n\_Crit  i$\equiv$\\
let g = (andForm (eqn (IVar (Para (Ident ''n'') i)) (Const T)) (eqn (IVar (Ident ''x'')) (Const true))) in \\
let s = (parallelList [(assign ((Para (Ident ''n'') i), (Const C))), (assign ((Ident ''x''), (Const false)))]) in \\
guard g s"\\
\\
definition n\_Exit::"nat $\Rightarrow$ rule" where [simp]:\\
"n\_Exit  i$\equiv$\\
let g = (eqn (IVar (Para (Ident ''n'') i)) (Const C)) in\\
let s = (parallelList [(assign ((Para (Ident ''n'') i), (Const E)))]) in\\
guard g s"\\
\\
definition n\_Idle::"nat $\Rightarrow$ rule" where [simp]:\\
"n\_Idle  i$\equiv$\\
let g = (eqn (IVar (Para (Ident ''n'') i)) (Const E)) in\\
let s = (parallelList [(assign ((Para (Ident ''n'') i), (Const I))), (assign ((Ident ''x''), (Const true)))]) in\\
guard g s"\\
\subsection{The set of All actual Rules w.r.t. a Protocol Instance with Size $N$}
definition rules::"nat $\Rightarrow$ rule set" where [simp]:\\
"rules N $\equiv$ \{r.($\exists$ i. i$\le$N$\wedge$r=n\_Try  i) $\vee$
($\exists$ i. i$\le$N$\wedge$r=n\_Crit  i) $\vee$\\
($\exists$ i. i$\le$N$\wedge$r=n\_Exit  i) $\vee$
($\exists$ i. i$\le$N$\wedge$r=n\_Idle  i)\}"\\
\subsection{\lyj{Definitions of a Formally Parameterized Invariant Formulas}
\label{subsec:formalinvariant formulas } }
definition inv\_\_1::"nat $\Rightarrow$ nat $\Rightarrow$ formula" where [simp]:\\
"inv\_\_1 p\_\_Inv3 p\_\_Inv4 $\equiv$\\
(neg (andForm (eqn (IVar (Para (Ident ''n'') p\_\_Inv4)) (Const C)) (eqn (IVar (Para (Ident ''n'') p\_\_Inv3)) (Const C))))"\\
\\
definition inv\_\_2::"nat $\Rightarrow$ formula" where [simp]:\\
"inv\_\_2 p\_\_Inv4 $\equiv$\\
(neg (andForm (eqn (IVar (Para (Ident ''n'') p\_\_Inv4)) (Const C)) (eqn (IVar (Ident ''x'')) (Const true))))"\\
\\
definition inv\_\_3::"nat $\Rightarrow$ nat $\Rightarrow$ formula" where [simp]:\\
"inv\_\_3 p\_\_Inv3 p\_\_Inv4 $\equiv$\\
(neg (andForm (eqn (IVar (Para (Ident ''n'') p\_\_Inv3)) (Const C)) (eqn (IVar (Para (Ident ''n'') p\_\_Inv4)) (Const E))))"\\
\\
definition inv\_\_4::"nat $\Rightarrow$ formula" where [simp]:\\
"inv\_\_4 p\_\_Inv4 $\equiv$\\
(neg (andForm (eqn (IVar (Para (Ident ''n'') p\_\_Inv4)) (Const E)) (eqn (IVar (Ident ''x'')) (Const true))))"\\
\\
definition inv\_\_5::"nat $\Rightarrow$ nat $\Rightarrow$ formula" where [simp]:
"inv\_\_5 p\_\_Inv3 p\_\_Inv4 $\equiv$
(neg (andForm (eqn (IVar (Para (Ident ''n'') p\_\_Inv3)) (Const E)) (eqn (IVar (Para (Ident ''n'') p\_\_Inv4)) (Const E))))"
\\

\subsection{\lyj{Definitions of  the Set of Invariant Formula Instances in a $N$-protocol Instance} \label{subsec:invariant formula instances }}
definition invariants::"nat $\Rightarrow$ formula set" where [simp]:\\
"invariants N $\equiv$ \{f.\\
($\exists$ p\_\_Inv3 p\_\_Inv4. p\_\_Inv3$\le$N$\wedge$p\_\_Inv4$\le$N$\wedge$p\_\_Inv3$\neq$p\_\_Inv4$\wedge$f=inv\_\_1  p\_\_Inv3 p\_\_Inv4) $\vee$\\
($\exists$ p\_\_Inv4. p\_\_Inv4$\le$N$\wedge$f=inv\_\_2  p\_\_Inv4) $\vee$\\
($\exists$ p\_\_Inv3 p\_\_Inv4. p\_\_Inv3$\le$N$\wedge$p\_\_Inv4$\le$N$\wedge$p\_\_Inv3$\neq$p\_\_Inv4$\wedge$f=inv\_\_3  p\_\_Inv3 p\_\_Inv4) $\vee$\\
($\exists$ p\_\_Inv4. p\_\_Inv4$\le$N$\wedge$f=inv\_\_4  p\_\_Inv4) $\vee$\\
($\exists$ p\_\_Inv3 p\_\_Inv4. p\_\_Inv3$\le$N$\wedge$p\_\_Inv4$\le$N$\wedge$p\_\_Inv3$\neq$p\_\_Inv4$\wedge$f=inv\_\_5  p\_\_Inv3 p\_\_Inv4)
\}"\\
definition initSpec0::"nat $\Rightarrow$ formula" where [simp]:\\
"initSpec0 N $\equiv$ (forallForm (down N) (\% i . (eqn (IVar (Para (Ident ''n'') i)) (Const I))))"\\
definition initSpec1::"formula" where [simp]:\\
"initSpec1  $\equiv$ (eqn (IVar (Ident ''x'')) (Const true))"\\
definition allInitSpecs::"nat $\Rightarrow$ formula list" where [simp]:\\
"allInitSpecs N $\equiv$ [
(initSpec0 N),
(initSpec1 )
]"\\

\section{Generalization of Normalized Concrete Invariant Formulas with Model Constraints}

\begin{definition}
Let  $f$ be a concrete formula, we define $symbolize(f)$ to be the formula transformed from $f$ by substituting each concrete parameter $j$ with $\mathtt{\iInv_j}$.
\end{definition}

$symbolize(f)$ is called the simple symbolic representation of the formula $f$. For instance, let $f$ be $\neg (n[1]\eqc C \andc n[2]\eqc C)$,   $symbolize(f )$ is $\neg (n[\iInv_1]\eqc C \andc n[iInv_2]\eqc C)$.   $symbolize(f )$ only shows the syntax effect of symbolic index replacement, we also need  model constraints with the symbolic transformation.

\begin{definition}
Let $N$ be a symbolic value representing a size of a parameterized instance of a protocol,   we define:
\begin{enumerate}
\item model constraint-I: $modelConstrI(N,j) \equiv \mathtt{iInv_j} \le N$.
\item model constraint: $modelConstr(N,L) \equiv forallForm(pf,|L|)$, where $pf(i)$ is $=modelConstrI(N ,i)$.
\end{enumerate}
\end{definition}

For instance, $modelConstrI(N,  [1])=\mathtt{iInv_1} \le N$; $modelConstr(N, [1,2])=\mathtt{iInv_1} \le N \wedge \mathtt{iInv_2} \le N$.  Model constraints intuitively represents that any parameter index should be not greater than $N$, which is the  meaning of $N-$paramterized instance.

\begin{definition}
let $L$ be a permutation,
\begin{enumerate}
\item difference constraint between parameter $\mathtt{iInv}_i$ and $\mathtt{iInv}_j$: $diff(i,j) \equiv (\mathtt{iInv}_i \ne \mathtt{iInv}_j)$.
\item mutual difference constraint: $mutualDiff(L) \equiv \bigwedge S$, where $S$ is a set of HOL formulas, and $S=\{f. f=diff(i,j)~ and~ i\le |L| ~and~ j \le |L|~ and ~i < j\}$.
\end{enumerate}
\end{definition}
For instance, $diff(  1,2)= (\mathtt{\iInv_1} \ne \mathtt{\iInv_2})$; $mutualDiff( [1,2])=  (\mathtt{iInv}_1 \ne \mathtt{ iInv}_2)$; $mutualDiff( [1,2,3])= (\mathtt{iInv}_1 \ne \mathtt{iInv}_2) \wedge   (\mathtt{iInv}_1 \ne \mathtt{iInv}_3) \wedge   (\mathtt{iInv}_2 \ne \mathtt{iInv}_3)$. $mutualDiff$ emphasizes that  parameters of an formula   should be different from each other.

By this generalization, we can easily generate a definition of a formal parameterized invariant formula in Isabelle syntax, which is listed in subsection \ref{subsec:formalinvariant formulas }.



For instance, $diff(  1,2)= (\mathtt{\iInv_1} \ne \mathtt{\iInv_2})$; $mutualDiff( [1,2])=  (\mathtt{iInv}_1 \ne \mathtt{ iInv}_2)$; $mutualDiff( [1,2,3])= (\mathtt{iInv}_1 \ne \mathtt{iInv}_2) \wedge   (\mathtt{iInv}_1 \ne \mathtt{iInv}_3) \wedge   (\mathtt{iInv}_2 \ne \mathtt{iInv}_3)$. $mutualDiff$ emphasizes that  parameters of an formula   should be different from each other.

Combining $symbolize$ function with the above  two restrictions, we define:
\begin{definition}
Let $f$ be a normalized concrete formula,  {1,2,..n} are parameter indice occuring in $f$, \\
\begin{numcases}{sym(f',f,N)\equiv }
f'=f, &   $n= 0$\\
\left.
\begin{array}{c}
\exists \mathtt{\iInv_1}...\mathtt{\iInv_n}.  modelConstr(N,ID_n) \\
\wedge mutualDiff(ID_n) \wedge f'=symbolize(f)
\end{array}%
\right. , & otherwise
\end{numcases}
%$sym(f',f,N)\equiv    \exists \mathtt{\iInv_1}...\mathtt{\iInv_n}.  modelConstr(N,ID_n) \wedge mutualDiff(ID_n) \wedge f'=symbolize(f)$. \\
$generalizeS([f_1,..,f_m],N)\equiv \{f'. sym(f',f_1,N) \lor ... \lor sym(f',f_m,N)\}$, where $f_i$ is a concrete normalized formula, $ID_n=1~ upto~ n$.
\end{definition}

We call  that $f'$ is symmetric to $f$  in the $N-$parameterized protocol instance if $sym(f',f,N)$. The intuition underlying function $sym$ is symmetry. %For instance,  $generalize(mutualInv(1,2))
$sym(f',f,N)$  means that there is an index replcaement by which $f'$ can transformed into $f$.  For instance, $mutualInv(3,4)$ satisfies  $sym(mutualInv(3,4),mutualInv(1,2),5)$, $mutualInv(3,4)$ can be
 transformed into $mutualInv(1,2)$ by replacing 3 and 4 with 1 and 2 respectively. $generalize(fs,N)$ defines a set of formulas each of which is symmetric to a  formula $f_i$ in $fs$.

 With the help of $\mathsf{generalizeS}([f_1,..,f_m],N)$, we can generate the definition of the set of
invariant formula instances in a $N$-protocol instance which is listed in \ref{subsec:invariant formula instances }.




\section{Lemms and Their Generation}

\subsection{An Overview of All the Lemmas}
After giving the definitions of rules and invariant formulas, next we show the lemmas and their proofs. First we give the hierarchy of all the Isabelle lemmas generated by {\sf proofGen}, which is shown  in Fig. \ref{fig:thyHierarchy}, the proof of main lemma needs {\tt invs$\_$on$\_$rules} and {\tt on$\_$inis}. The proof  {\tt invs$\_$on$\_$rules} needs {\tt lemma$\_$invi$\_$on$\_$rules}, where $1 \le i\le 5$; and the proof of {\tt lemma$\_$invInst$\_$on$\_$rules}  such as {\tt lemma$\_$inv1$\_$on$\_$rules} needs    a lemma {\tt lemma$\_$invInst$\_$on$\_$ruleInst} such as {\tt critVsinv1}. The proof of Lemma {\sf on$\_$inis} needs lemma {\sf iniImply\_inv4}. We introduce them one by one in a bottom-up order.

 \begin{figure}[!ht]\label{fig:thyHierarchy}
% \centering %
 %\vspace{-0.8cm}
\includegraphics[width=1.0\textwidth]{thy.pdf}
%\vspace{-0.5cm}
 \caption{The hierachy of lemmas}

\end{figure}

 % Now we discuss how to use records on {\tt crit} and {\tt inv$_1$} in the tables   $symbInvs$, $symbRules$, and $symbCausalTab$ to generate a lemma to prove that causal relation hold between   crit and   $inv_1$, which will be applied in the proof of main lemma.
\subsubsection{Lemmas for Causal Relation between Rules and Invariants}
 A lemma at the bottom level, specifies that causal relation hold between  a rule like  {\tt crit} and a parameterized rule like  $inv_1$, An  example lemma
{\tt critVsinv$_1$} and its proof in Isabelle in the {\tt mutualEx} protocol, is illustrated as follows:


\begin{specification}
%\begin{algorithm}
%\caption{Generating a kind of proof which is according with a relation tag of $invHoldForRule_{1-3}$ : rel2proof}\label{lemma:causal relation lemma}
1lemma critVsinv1:\\
2  assumes  a1: $\exists$ \iR1. \iR1 $\le$ N $\wedge$ r=crit \iR1 and \\
  a2: $\exists$  \iInv1 \iInv2. \iInv1 $\le$ N $\wedge$ \iInv2 $\le$ N $\wedge$ \iInv1 $\neq$ \iInv2 $\wedge$ f=inv1  \iInv1 \iInv2\\
3  shows  invHoldForRule s f r (invariants
  N)\\
4  proof -\\
   from a1 obtain \iR1 where a1:\iR1 $\le$ N $\wedge$ r=crit \iR1 \\
\twoSpaces   by blast\\
   from a2 obtain \iInv1 \iInv2 where \\
   a2: \iInv1 $\le$ N $\wedge$ \iInv2 $\le$ N $\wedge$ \iInv1 $\neq$ \iInv2 $\wedge$ f=inv1  \iInv1 \iInv2\\
\twoSpaces   by blast \\
5  have iR1=\iInv1 $\vee$ \iR1=\iInv2 $\vee$ (\iR1 $\ne$ \iInv1 $\wedge$  \iR1 $\ne$ \iInv2) by auto\\

6  moreover\{assume  b1:\iR1=\iInv1\\
7  \twoSpaces have invHoldForRule3 s f r (invariants N)\\
 \twoSpaces  \twoSpaces   proof(cut\_tac a1 a2 b1, simp, rule\_tac x=$\negc$ (x=true $\andc$ n[\iInv2]=C)  in exI,auto)qed\\
8  \twoSpaces then have invHoldForRule s f r
(invariants
  N)
by auto\}\\

9  moreover\{assume  b1:iR1=\iInv2\\
10 \twoSpaces have invHoldForRule3 s f r (invariants N)\\
 \twoSpaces \twoSpaces   proof(cut\_tac a1 a2 b1, simp, rule\_tac x=$\negc$ (x=true $\andc$ n[\iInv1]=C  in exI,auto)qed\\
11 \twoSpaces then have invHoldForRule s f r (invariants
  N)
by auto\}\\

12   moreover\{assume  b1:(\iR1 $\ne$  \iInv1 $\wedge$   \iR1 $\ne$  \iInv2)\\
13 \twoSpaces have invHoldForRule2 s f r  \\
  \twoSpaces \twoSpaces  proof(cut\_tac a1 a2 b1,  auto) qed\\
14 \twoSpaces then have invHoldForRule s f r
(invariants
  N)
by auto\} \\

15ultimately show invHoldForRule s f r
(invariants N) by blast\\
16qed\\
%\end{algorithm}
\end{specification}

A lemma such as {\tt critVsinv1}  is generated by collecting all the records on the invariant {\tt inv1} and rule {\tt crit} in the aforementioned tables.
Line 2 are assumptions on the parameters of the invariant and rule, which are composed of two parts: (1) assumption {\tt a1} specifies that there exists an actual parameter {\tt \iR1} with which {\tt r} is a rule obtained by instantiating {\tt crit}; (2) assumption {\tt a2} specifies that  there exists   actual parameters {\tt \iInv1} and {\tt \iInv2} with which {\tt f} is a formula obtained by instantiating {\tt inv1}.
 %(1) the facts that all parameters of this invariant should be less than the parameter $N$; %(2) the facts that all parameters of this invariant should be less than the parameter $N$; (3) the constraints of he mutual difference between parameters of the invariant (rule), which can %be looked up in the field of those records  from the table $symbInvTab$ ($symbRuleTab$) by the invariant (rule) name {\tt inv1} ({\tt crit}), which specifies that the mutual difference %between two parameters.
Line 4 are two typical  proof patterns forward-style which fixes local variables such as {\tt \iR1} and new facts such as {\tt a1: iR1 $\le$ N $\wedge$ r=crit \iR1}. From line 5, the remaining parts of the proof is a typically readable one in Isar style \cite{Wen99}, which uses calculation
reasoning such as {\tt moreover} and {\tt ultimately} to do  case analysis.
Line 5 splits cases of {\tt iR1} into all possible cases by comparing
{\tt \iR1} with {\tt \iInv1} and {\tt \iInv2}, which is in fact characterized by $partition([1],[2],[3]],[1,2])$. Lines 6-14  proves    these cases one by one: Lines 6-8 proves the case where {\tt iR1=\iInv1}, line 7 first proves that the causal relation $invHoldForRule_3$ holds by supplying a formula, which is $symbolize'(invOnXC(2),[1,2],[1])$. %Notes that $invOnXC(2)$ is the $f'$ which is provided in the last column of the line.
From the conclusion at line 7, line 8 futhermore proves the causal relation $invHoldForRule$ hold; Lines 9-11 proves the case where {\tt iR1=\iInv2}, proof of which is similar to that of case 1; Lines 12-14 the case   where neither {\tt iR1=\iInv1} nor {\tt iR1=\iInv2}. Each proof of a subcase is done in a block {\tt moreover b1:asm1 proof1}, the {\tt ultimately}  proof command in line 15 concludes by summing up all the subcases.




With the help of all the lemmas such as {\sf ruleVsinv1},  we can prove the following lemma  {\sf lemma$\_$inv$\_$1$\_$on$\_$rules} which
specifies that for all $r \in rules ~N$, and $f$ is a formula $f$ which is generated by instantiating inv1 with some parameters $\iInv_1$ and $iInv_2$, $invHoldForRule ~s~ f~ r~ (invariants~ N)$.

\begin{specification}
lemma lemma$\_$inv1$\_$on$\_$rules:
  $\isasymlbrakk$ a1:
r $\in$ rules N
 and a2:
($\exists$ $\_$iInv1 $\_$iInv2. $\_$iInv1$\le$
N$\wedge$$\_$iInv2$\le$\\
N$\wedge$\iInv1$\neq$\iInv2$\wedge$f=inv1  \iInv1 \iInv2)\\

  $\isasymrbrakk\Longrightarrow$
invHoldForRule s f r (invariants N)\\

  proof -\\
\twoSpaces  have
($\exists$ i. i$\le$
N$\wedge$r=try  i)$\vee$
    ($\exists$ i. i$\le$\\
N$\wedge$r=crit  i)$\vee$
    ($\exists$ i. i$\le$
N$\wedge$r=exit  i)$\vee$\\
    ($\exists$ i. i$\le$
N$\wedge$r=idle  i)\\

  apply (cut$\_$tac a1, auto) done\\
    moreover $\{$      assume b1:
($\exists$ i. i$\le$
N$\wedge$r=try  i)\\

\twoSpaces      have invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis tryVsinv1) done
    $\}$\\


    moreover $\{$ assume a1:
($\exists$ i. i$\le$
N$\wedge$r=crit  i)\\

\twoSpaces      have
invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis critVsinv1) done
    $\}$\\


    moreover $\{$
      assume a1:
($\exists$ i. i$\le$
N$\wedge$r=exit  i)\\

\twoSpaces      have
invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis exitVsinv1) done
    $\}$\\


    moreover $\{$ assume a1:
($\exists$ i. i$\le$
N$\wedge$r=idle  i)\\

\twoSpaces      have
invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis idleVsinv1) done
    $\}$\\


  ultimately show invHoldForRule' s f r (invariants N)\\
  by auto\\
qed\\

\end{specification}

With the help of all the lemmas such as {\sf lemma$\_$inv$_i\_$on$\_$rules},  we can prove the following lemma  {\sf invs$\_$on$\_$rules} which
specifies that for all $f \in invariants~ N$ and $r \in rules~ N$,   $invHoldForRule ~s~ f~ r~ (invariants~ N)$.

\begin{specification}
lemma invs$\_$on$\_$rules:
  $\isasymlbrakk$ a1:
f $\in$ invariants N
 and a2:
r $\in$ rules N
  $\isasymrbrakk\Longrightarrow$\\
invHoldForRule' s f r (invariants N)\\

  proof -\\
  have b1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1$\neq$\iInv2$\wedge$f=inv1  \iInv1 \iInv2)$\vee$\\
    ($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv2  \iInv2)$\vee$\\
    ($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1$\neq$\iInv2$\wedge$f=inv3  \iInv1 \iInv2)$\vee$\\
    ($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv4  \iInv2)$\vee$\\
    ($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1$\neq$\iInv2$\wedge$f=inv5  \iInv1 \iInv2)\\

  apply (cut$\_$tac a1, auto) done\\
    moreover $\{$      assume b1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1$\neq$\iInv2$\wedge$f=inv1  \iInv1 \iInv2)\\

\twoSpaces       have
invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis lemma$\_$inv1$\_$on$\_$rules) done
    $\}$\\


    moreover $\{$ assume b1:
($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv2  \iInv2)\\

\twoSpaces       have invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis lemma$\_$inv2$\_$on$\_$rules) done
    $\}$\\


    moreover $\{$      assume b1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1$\neq$\iInv2$\wedge$f=inv3  \iInv1 \iInv2)\\

\twoSpaces       have
invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis lemma$\_$inv3$\_$on$\_$rules) done
    $\}$\\


    moreover $\{$      assume b1:
($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv4  \iInv2)\\

\twoSpaces       have
invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis lemma$\_$inv4$\_$on$\_$rules) done
    $\}$\\


    moreover $\{$
      assume b1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1$\neq$\iInv2$\wedge$f=inv5  \iInv1 \iInv2)\\

\twoSpaces       have
invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis lemma$\_$inv5$\_$on$\_$rules) done
    $\}$\\


  ultimately show
invHoldForRule' s f r (invariants N)\\

\twoSpaces  apply fastforce done\\
qed
end\\
\end{specification}



 % {\tt allSymbRecs } are all symbolic causal relation records on {\tt  invName} and {\tt  ruleName},
% then  {\tt lenPInv} and {\tt lenPRule} which are numbers of the parameters of the invariant formula and rule, then {\tt asms} which are the assumptions part of the lemma such as line 2, {\tt allDisjuncts} the case analysis between the parameters of invariant and rule such as line 5, {\tt allSubProofs} all the proofs of the subcases such as lines 6-14, then fill all these into the blanks of the templates to generate the lemma.


% {\tt namedAsmTrans asm i} adds a name "ai:" to a string of assumption in order to construct a named assumption. {\tt allNamedAsmsGen} generates all the aformentioned  four kinds of assumptions of the lemma in the previous paragrapgh: {\tt asmsLessOnInv} is according with (1) types of assumptions; {\tt asmsLessOnRule} (2) types of assumptions;  {\tt asmsMutualDiffOnInv} (3) types of assumptions; and {\tt asmsMutualDiffOnRule} (4) types of assumptions. After naming any one assumption with a name, {\tt allNamedAsmsGen} returns all the named assumptions which are conned by {\tt and} operator. {\tt symbCausalRec2Proof symbRec} generates a kind of proof in Isabelle according to a symbolic casual relation record {\tt symbRec}: if the tag of {\tt holdTag} is 1(2,3), then kind 1 (2,3) proof are generated accordingly. Here we list the most complex one: {\tt proof3Gen ruleName invName f}, which generates a proof which is according with {\tt invHoldType3} such as lines 6-8, and {\tt f} is another invariant formula which is needed to construct the {\tt invHoldType3} causal relation.
%\twoSpaces  let asmsLessOnRule=asmsGen iRule sN lenPRule in \\
%\twoSpaces  let asmsMutualDiffOnInv=asmsLookUp symbInvs invName gFldName in\\
%\twoSpaces  let asmsMutualDiffOnRule
\subsubsection{Lemmas on initial states}

In this section, we discuss the definition on the initial state of the protocol, and the lemmas specifying that each invariant formula holds at the initial state.

A typical Isabelle definition on the initial state of the protocol is as follows:

\begin{specification}
definition initSpec0::nat $\Rightarrow$ formula where [simp]:\\
initSpec0 N $\equiv$ (forallForm (down N) (\% i . (eqn (IVar (Para (Ident ''n'') i)) (Const I))))\\

definition initSpec1::formula where [simp]:\\
initSpec1  $\equiv$ (eqn (IVar (Ident ''x'')) (Const true))\\

definition allInitSpecs::nat \<Rightarrow> formula list where [simp]:\\
allInitSpecs N $\equiv$ [(initSpec0 N),(initSpec1 )]\\

lemma iniImply\_inv4:
assumes a1: ($\exists$\iInv1. \iInv1$\le$N$\wedge$f=inv4 \iInv1)\\
and a2: formEval (andList (allInitSpecs N)) s\\
shows formEval f s\\
 using a1 a2 by auto\\
\end{specification}

{\tt initSpec0} and {\tt initSpec1} specifies the assignments on each variable {\tt n[i]} where {\tt i $\le$ N} and {\tt x}. The  specifications of the initial state is the list of all the specification definition on related state variables. Lemma {\tt iniImply\_inv4} simply specifies that the invariant formula {\tt inv4} holds at a state {\tt s} which satisfies the conjunction of the   specification of the initial state. Isabelle's {\tt auto} method can solve this goal automatically. Other lemmas specifying that other invariant formulas hold at the initial state are similar.
%The generation of the above code is straightforward: definitions of the specification of initial state variables in Isabelle is a direct syntax transformation from the internal represetation of tool {\tt proofGen} to Isabelle.

With the lemmas such as {\tt iniImply\_inv4}, for any invariant $inv \in (\mathsf{invariants} ~N) $,  any
state $s$, if $ini$ is evaluated true at state $s$, then $inv$ is
evaluated true at state $s$.

\begin{specification}
lemma on$\_$inis:
  $\isasymlbrakk$ a1:
f $\in$ (invariants N)
 and a2:
ini $\in$ $\{$
andList (allInitSpecs N)$\}$\\

 and a3:
formEval ini s

  $\isasymrbrakk\Longrightarrow$
formEval f s\\

  proof -\\
  have c1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1$\neq$\iInv2$\wedge$f=inv$\_$$\_$1  \iInv1 \iInv2)$\vee$\\
    ($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv$\_$$\_$2  \iInv2)$\vee$\\
    ($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1$\neq$\iInv2$\wedge$f=inv$\_$$\_$3  \iInv1 \iInv2)$\vee$\\
    ($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv$\_$$\_$4  \iInv2)$\vee$\\
    ($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1$\neq$\iInv2$\wedge$f=inv$\_$$\_$5  \iInv1 \iInv2)\\

\twoSpaces  apply (cut$\_$tac a1, simp) done\\
    moreover $\{$
      assume b1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1$\neq$\iInv2$\wedge$f=inv$\_$$\_$1  \iInv1 \iInv2)\\

      have
formEval f s\\

\twoSpaces      apply (rule iniImply$\_$inv$\_$$\_$1)\\
\twoSpaces      apply (cut$\_$tac b1, assumption)\\
\twoSpaces      apply (cut$\_$tac a2 a3, blast) done
    $\}$\\


    moreover $\{$
      assume b1:
($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv$\_$$\_$2  \iInv2)\\

      have
formEval f s\\

\twoSpaces      apply (rule iniImply$\_$inv$\_$$\_$2)\\
\twoSpaces      apply (cut$\_$tac b1, assumption)\\
\twoSpaces      apply (cut$\_$tac a2 a3, blast) done\\
    $\}$\\


    moreover $\{$
      assume b1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1$\neq$\iInv2$\wedge$f=inv$\_$$\_$3  \iInv1 \iInv2)\\

      have
formEval f s\\

\twoSpaces      apply (rule iniImply$\_$inv$\_$$\_$3)\\
\twoSpaces      apply (cut$\_$tac b1, assumption)\\
\twoSpaces      apply (cut$\_$tac a2 a3, blast) done
    $\}$\\


    moreover $\{$
      assume b1:
($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv$\_$$\_$4  \iInv2)\\

      have
formEval f s\\

\twoSpaces      apply (rule iniImply$\_$inv$\_$$\_$4)\\
\twoSpaces      apply (cut$\_$tac b1, assumption)\\
\twoSpaces      apply (cut$\_$tac a2 a3, blast) done
    $\}$\\


    moreover $\{$
      assume b1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1$\neq$\iInv2$\wedge$f=inv$\_$$\_$5  \iInv1 \iInv2)\\

      have
formEval f s\\

\twoSpaces      apply (rule iniImply$\_$inv$\_$$\_$5)\\
\twoSpaces      apply (cut$\_$tac b1, assumption)\\
\twoSpaces      apply (cut$\_$tac a2 a3, blast) done
    $\}$\\


  ultimately show formEval f s
  by auto\\
qed\\


\end{specification}

The proof structure of {\sf lemma$\_$inv1$\_$on$\_$rules} and  {\sf invs$\_$on$\_$rules} and {\sf on$\_$inis} are also typical case analysis ones using {\sf moreover} blocks and {\sf ultimately} commands, therefore, a generic program of generating a typical case analysis proof will be adopted in our framework.

%All can be generated by calling the generic template function {\sf doCaseAnalz} with different subproof generation functions.


\subsubsection{The main theorem}

%-------------------------------------------------------------------------
%At last, we discuss how to create automatically the proof for the main lemma, which depends
% on the applying the lemmas which are created in subsection \ref{sec:genOfIsabelleProof}.
With the preparation of lemma  on$\_$inis and  invs$\_$on$\_$rules, the generation of the main lemma is quite easy. Recall that the consistency lemma is our
main weapon to prove the main lemma, which requires proving two parts of
obligations.



\begin{description}
\item[(1)] For any invariant $inv \in (\mathsf{invariants} ~N) $,  any
state $s$, if $ini$ is evaluated true at state $s$, then $inv$ is
evaluated true at state $s$. This can be solved done by applying lemma on$\_$inis.
\item[(2)]  For any invariant $inv \in (\mathsf{invariants} ~N)$, any $r$ in rule set
$ \mathsf{rules} ~N$ , one of the causal relations
$\mathsf{invHoldForRule}_{1-3}$ holds. This can be solved done by  applying lemma invs$\_$on$\_$rules.
\end{description}
%
%Proof of Part (1) is  simple. %%For an invariant
%$inv=\mathsf{implyForm}~ant~cons$ in $invs$, we only need to prove
%that either $ant$ is evaluated as false or $cons$ is evaluated true
%at an initial state $s$ in order to prove $\models
%~inv~s$. Such a proof  can be automatically solved by Isabelle's
%$\mathsf{auto}$ command.



\begin{specification}
lemma main:
  $\isasymlbrakk$  s$\in$ reachableSet \{andList (allInitSpecs N)\} (rules N); 0<N$\isasymrbrakk$\\
  $\Longrightarrow$ $\forall$ inv. inv $\in$ (invariants N) $\longrightarrow$ formEval inv s\\
proof(rule consistentLemma)\\
  show consistent (invariants N) \{andList (allInitSpecs N)\} (rules N)\\
 proof(cut\_tac a1, unfold consistent\_def,rule conjI)\\
   show  $\forall$inv ini s. inv $\in$ (invariants N)
$\longrightarrow$ ini $\in$\{andList (allInitSpecs N)\}$\longrightarrow$formEval
ini s $\longrightarrow$ formEval inv s\\
proof((rule allI)+,(rule impI)+)\\
\twoSpaces   fix inv ini s\\
\twoSpaces   assume b1:inv $\in$ (invariants N) \\
\twoSpaces     and b2:ini $\in$ \{andList (allInitSpecs N)\}  and b3:formEval ini s\\
\twoSpaces   show "formEval f s"\\
\twoSpaces   apply (rule on\_inis, cut\_tac b1, assumption, cut\_tac b2, assumption, cut\_tac b3, assumption) done\\
    qed\\

next   show  $\forall$inv r. inv $\in$ invariants N$\longrightarrow$
 r $\in$rules N$\longrightarrow$invHoldForRule inv r (invariants N) \\

   proof((rule allI)+,(rule impI)+)\\
\twoSpaces      fix f r \\
\twoSpaces         assume b1: f $\in$ invariants N  and b2:r $\in$ rules N\\

\twoSpaces     show "invHoldForRule' s f r (invariants N)"\\
  apply (rule invs\_on\_rules, cut\_tac b1, assumption, cut\_tac b2, assumption) done\\
qed\\
next show "s $\in$ reachableSet {andList (allInitSpecs N)} (rules N)"
  apply (metis a1) done\\
qed\\
\end{specification}

The generation of the main lemma is quite easy because it is in a standard form.
%\vspace{-0.5cm}
 %in order to verify the cache coherence protocols. Others are straightforward.
%The proof is a typically
%readable one in Isar style \cite{}, which uses calculation
%reasoning such as {\tt moreover} and {\tt ultimately} to do  case analysis on
%the form of rules and the invariants. Lines 1-5 use proper Isabelle
%proof commands to   decompose the main proof goal of forall  and
%implication form,    fix a rule {\tt r} and {\tt inv}, then have two
%assumptions {\tt  b1: inv$\in$ invariants N  and b2:r $\in$ rules
%N}, now we need show the goal {\tt invHoldForRule s f r (invariants
%N)}. line 5 splits cases of $r$ into all possible cases according to
%the definition of $rules~N$. %In order to save space, we adopt the following abbreaviation:
% $\mathsf{ex1P}~ N~ P \equiv \exists i. (i \le N \wedge P~
%i)$, $\mathsf{ex2P}~ N~ P \equiv \exists i~j. (i \le N \wedge j \le
%N \wedge i\ne j \wedge P~ i~j)$, and $\mathsf{ex3P}~ N~ P \equiv
%\exists i~j~k. (i \le N \wedge j \le N \wedge k \le N\wedge i\ne j
%\wedge i\ne k \wedge j\ne k \wedge P~ i~j~k)$.
%Line 6 starts the case analysis on
%$r=r_0$. Line 7 again splits cases of $inv$ into all possible cases
%according to the definition of $invariants~N$. Line 8-10 proves the
%goal at case when $r=exit$ and $inv=inv1$. At line 10,  a  proved
%lemma {\tt exitVsInv1}  is directly applied to solve the proof
%goal.  Similiarly, we can do subproofs on other cases on {\tt inv},
%and finish the proof goal accordingly.
% After finishing the proof of the last case  of $inv=inv5$,
% we finish the proof of the first case $r=exit$. Similarly, we can
% finish the proof goal at
%each subcase on {\tt r}. At  lines 19 and  20 we show we have
%finished the proof goal formally.

\subsection{Algorithms of Proof Generator {\sf proofGen}}

In this subsection, we illustrate the key techniques and algorithms of generation of the lemmas and their proofs in subsection \ref{subsection:introOfIsabelleProof}. Being according with the order in which we introduce the above lemmas, we also introduce their generation in a bottom-up order. First let us introduce the generation of a subproof according to a relation tag of $invHoldForRule_{1-3}$, which is shown in Algorithm \ref{alg:proofGenOfReltag}.

\begin{algorithm}
\caption{Generating a kind of proof which is according with a relation tag of $invHoldForRule_{1-3}$ : rel2proof}\label{alg:proofGenOfReltag}
\KwIn{A causal    relation item $relTag$}
\KwOut{  An Isablle proof: $proof$   }

{
 \If{$relTag=invHoldForRule_1$}
  {$proof \leftarrow $ sprintf\\
\twoSpaces"have invHoldForRule1 f r (invariants N)  \\
\twoSpaces         by(cut\_tac a1 a2 b1, simp, auto) \\
\twoSpaces then have invHoldForRule f r (invariants N)  by blast" \; }
 \ElseIf{ $relTag=invHoldForRule_2$}
  {$proof \leftarrow$  sprintf\\
\twoSpaces"have invHoldForRule2 f r (invariants N)
\twoSpaces         by(cut\_tac a1 a2 b1, simp, auto) \\
\twoSpaces then have invHoldForRule f r (invariants N)  by blast" \; }
 \Else{
 \label{label:getFormField}$f' \leftarrow getFormField(relTag)$\;
 $proof \leftarrow$ sprintf\\
\twoSpaces"have invHoldForRule3 f r (invariants N)  \\
\twoSpaces proof(cut\_tac a1 a2 b1, simp, rule\_tac x=\%s  in exI,auto)qed\\
\twoSpaces then have invHoldForRule f r (invariants N)  by blast" (symbf2Isabelle f')"\;}
\Return{proof}
}
\end{algorithm}

In the body of function {\sf rel2proof},  $sprintf$ writes a formatted data to string and returns it.
In line \ref{label:getFormField}, $getFormField(relTag)$ returns $f'$ if $relTag=invHoldForRule_3(f')$.  {\sf rel2proof} transforms a a relation tag into a paragraph of proof.% as shown in lines 7-8, 10-11, or 13-14.
If the tag is among $invHoldForRule_{1-2}$, the transformation is rather straight-forward, else the form $f'$ is assigned by the formula $getFormField(relTag)$, and provided to tell Isabelle the formula which should be used to construct the $invHoldForRule_3$ relation.

\begin{algorithm}
\caption{Generating one sub-proof for a subcase: oneMoreOverGen}\label{alg:MoreOver}

\KwIn{A formula $caseFsm$ standing for the assumption of the subcase, a relation item $relItem$ containing the information of causal relation }
\KwOut{  An Isablle proof: $subProof$ }
{
%$label \leftarrow labelGen(depth) $\;
$proof \leftarrow rel2proof(relItem)$\;
$  subProof \leftarrow$  sprintf\\
%\twoSpaces sprintf\\
\twoSpaces "moreover\{assume  b1:\%s  \\
           \%s    \} "\\
\twoSpaces ( asm, proof)\;
\Return{subproof}
}
\end{algorithm}

In Algorithm \ref{alg:MoreOver}, {\sf oneMoreOverGen} generates a subproof for a subcase in a proof of case analysis. It returns a subproof which is composed by filling an assumption of the subcase such as "\iR1=\iInv1" and a paragraph of proof generated by $rel2proof(relItem)$ into a format of block {\tt morover \{ ...\}}.  %the input $depth$ shows the  the depth of the current proof. Recalling that proof is recursively composed by subproofs. Each level of proofs are tagged with some depth. {\sf labelGen(depth)} returns a label such as $a1:$. {\sf oneMoreOverGen} generates a subproof which is

Due to the common use of case analysis proof of using {\sf moreover} and {\sf ultimately} commands, we design a generic program of generating  doing case analysis {\sf doCaseAnalz}. In algorithm \ref{alg:doCaseAnalz}, %generates a typical proof of doing case analyis.
 formulas standing for case-splitting $partition$, subproofs $subproofs$, and the conclusion $concluding$ are needed  in case analysis to fill the format.
\begin{algorithm}

\caption{Generating a whole proof of doing case analysis: doCaseAnalz}\label{alg:doCaseAnalz}
\KwIn{A formula $partition$ standing for case-splittings, a proof list $subproofs$ standing  all the subproofs of each subcases, concluding parts $concluding$}%, the depth of proof $depth$ }
\KwOut{  An Isablle proof: $proof$ }
{

%\If{$depth=1$}
%{$showOrHave \leftarrow$ "show"\;}
%\Else {$showOrHave \leftarrow$ "have"\;}
$proof \leftarrow $sprintf\\
\twoSpaces \twoSpaces  " have \%s  by auto\\
\twoSpaces \twoSpaces         \%s\\
\twoSpaces \twoSpaces        ultimately show \%s by auto"\\
\twoSpaces     (partition, subproofs,  concluding) \;
\Return{proof}
}
\end{algorithm}


In algorithm \ref{alg:doCaseAnalzI}, {\sf caseAnalzI} generates a typical proof of doing case analysis to  prove some causal relation hold between some rule and invariant. oneMoreOverGenI(case,rel) formula comes from the disjunction of formulas in the {\tt symbCases} field of $rec$, which is returned by $caseField(rec)$, subproofs $subproofs$ are generated by concatenation of all the subproofs, each of which is generated by $oneMoreOverGenI(case,rel)$. The proof is simply composed by  calling $doCaseAnalz(partition,subproofs,concluding)$.

\begin{algorithm}

\caption{Generating a whole proof of doing case analysis on parameters of rule and invariant: caseAnalzI}\label{alg:doCaseAnalzI}
\KwIn{A record $rec$ fetched from $symbCausal$ }
\KwOut{  An Isablle proof: $proof$ }
{
$cases \leftarrow caseField(rec)$\;
$rels \leftarrow relItems(rec)$;
$partition \leftarrow \bigvee cases$\;
$subproofs \leftarrow ""$\;
\While{$(cases \ne [])$}
{ $ case \leftarrow hd(cases)$ \;
  $cases \leftarrow tl(cases)$ \;
  $ rel \leftarrow hd(rels)$ \;
  $rels \leftarrow tl(rels)$ \;
  $subproofs \leftarrow subproofs \cat oneMoreOverGenI(case,rel)$\;
  }
$ concluding \leftarrow $"invHoldForRule s f r (invariants N) "\;
$proof \leftarrow doCaseAnalz(partition,subproofs,concluding)$\;
\Return $proof$
}
\end{algorithm}

Next we discuss how to generate assumptions on an invariant formula of an lemma such as $critVsInv1$. In the body of algorithm \ref{alg:asmGenOnInv}, $tbl\_element(symbInvs,  invName)$  retrieves the record on a invariant formula from $symbInvs$ to $invItem$ by its name $invName$, $invParaNum(invItem  )$ and $constrOfInv(invItem))$ return the field {\tt invNumFld} and {\tt constr} of  $invItem$ respectively. $invParasGen(lenPInv)$ generates a string of a list of actual parameters such as $iInv_1 ... iInv_{lenPInv}$ if $lenPInv>0$, else an empty string "".  At last, the assumption on the invariant is created by filling $invParas$,  $constrOnInv$, and $invName$ into a proper place in the format if needed.

\begin{algorithm}
  \caption{Generating an assumption on an invariant formula: asmGenOnInv}\label{alg:asmGenOnInv}
  \KwIn{An invariant name $invName$,    a table $symInvs$ storing invariant formulas   }

\KwOut{  An assumption on an invariant formula: $asm$   }

 $invItem   \leftarrow tbl\_element( symbInvs,  invName)$\;
  $lenPInv \leftarrow invParaNum(invItem  )$\;
  $invParas \leftarrow invParasGen(lenPInv)$\;
 % $constrOfInv \leftarrow constr(N,lenPInv)$\;
 $constrOnInv \leftarrow symbForm2Isabelle(constrOfInv(invItem))  $\;
 \If {lenPInv = 0}
  {$asm  \leftarrow  "a1: f="\cat invName   $\;}
  \Else{$asm  \leftarrow$ sprintf "a1: $\exists$ \%s. \%s $\wedge$ f=\%s \%s" (invParas,  constrOnInv, invName, invParas)\;}
  \Return{asm}
\end{algorithm}

Similar to {\sf asmGenOnInv}, {\sf obtainGenOnInv}, which is shown in algorithm \ref{alg:obtainGenOnInv}, generates a proof command of {\sf obtain} by retrieving and generating the related information and filling them in a format on {\sf obtain}.  Similar to {\sf asmGenOnInv} and  {\sf obtainGenOnInv}, {\sf asmGenOnRule} and  {\sf obtainGenOnRule} generate an  assumption and {\sf obtain} proof command   on a rule.

\begin{algorithm}
  \caption{Generating an {\sf obtain} proof command on an invariant formula: obtainGenOnInv}\label{alg:obtainGenOnInv}
  \KwIn{An invariant name $invName$,    a table $symInvs$ storing rules    }
  $invItem   \leftarrow tbl\_element( symbInvs,  invName)$\;
  $lenPInv \leftarrow invParaNum(invItem  )$\;
  $invParas \leftarrow invParasGen(lenPInv)$\;
\If {$  lenPInv = 0 $}
    {$obtain \leftarrow  ""$\;}
 \Else {$obtain \leftarrow$ sprintf "from a1 obtain  \%s where a1:\%s $\wedge$ f=\%s \%s by auto"\\
 \twoSpaces           $(invParas,  constrOnInv, invName, invParas)$\;}
 \Return{obtain}
\end{algorithm}



After the above preparing functions, now the generation of a lemma on the causal relation such as    $critVsInv1$ is rather easy, which is shown in algorithm \ref{alg:lemmaOnCausalRuleInv}. After generating an assumption on invariant formula $asm1$,  $asm2$ on a rule, an obtain command  $obtain1$ on the invariant, and  $obtain2$ on the rule,  $symRelItem$ is retrieved from $symCausalTab$ by $ruleName\cat invName$, and a proof $proof$ is generated by calling $caseAnalzI(symRelItem)$. At last these parts are filled into proper places in the lemma format.

\begin{algorithm}
\caption{Generating a lemma on a causal relation: lemmaOnCausalRuleInv}\label{alg:lemmaOnCausalRuleInv}

\KwIn{A parameterized rule name $ruleName$,   a formula name $invName$, a table $symRules$ storing rules , a table $symInvs$ storing invariant formulas,   a table $symCausalTab$  storing causal relation  }

\KwOut{  An Isablle proof script for a lemma: $lemmaWithProof$   }

{


 $asm1 \leftarrow asmGenOnInv(symbInvs,invName)$\;
 $asm2 \leftarrow asmGenOnRule(symbRules,ruleName)$\;
 $obtain1 \leftarrow obtainGenOnInv(symbInvs,invName)$\;
 $obtain2\leftarrow obtainGenOnRule(symbRules,ruleName)  $\;
  $symRelItem \leftarrow tbl\_element( symCausalTab,(ruleName\cat invName))$\;
 $proof \leftarrow caseAnalzI(symRelItem)$\;

$lemmaWithProof \leftarrow$ sprintf \\
\twoSpaces"lemma \%sVs\%s:\\
%2  assumes  a2: iR $\le$ N and a3: i1 $\le$ N and a4: i2 $\le$ N\\ generations assumptions
\twoSpaces assumes \%s and \%s\\
\twoSpaces  shows  invHoldForRule s f r (invariants   N)\\
\twoSpaces  proof -
\twoSpaces \%s~ \%s~  \%s

\twoSpaces qed"\\

\twoSpaces $(ruleName, invName, asm1,asm2, obtain1, obtain2, proof)$ \;
    \Return $lemmaWithProof$
}



\end{algorithm}



\bibliographystyle{splncsnat}
\bibliography{gste,cache,refer}
\end{document}

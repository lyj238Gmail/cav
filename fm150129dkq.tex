\documentclass{llncs}
%%%%%%%%%%%%%%%%%%%%%%
%%%%   PACKAGES   %%%%
%%%%%%%%%%%%%%%%%%%%%%
\usepackage{makeidx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{latexsym}
\usepackage{url}
\usepackage{color}
\usepackage{isabelle}
\usepackage{isabellesym}
\usepackage{theorem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%For Isabelle code
\newlength{\fminilength}
\newsavebox{\fminibox}
\newenvironment{fmini}[1][\linewidth]
  {\setlength{\fminilength}{#1\fboxsep-2\fboxrule}%
   \vspace{2ex}\noindent\begin{lrbox}{\fminibox}\begin{minipage}{\fminilength}%
   \mbox{ }\hfill\vspace{-2.5ex}}%
  {\end{minipage}\end{lrbox}\vspace{1ex}\hspace{0ex}%
   \framebox{\usebox{\fminibox}}}

\newenvironment{specification}
{\noindent\scriptsize
\tt\begin{fmini}\begin{tabbing}X\=X12345\=XXXX\=XXXX\=XXXX\=XXXX\=XXXX
\=\+\kill} {\end{tabbing}\normalfont\end{fmini}}
\def \twoSpaces {\ \ }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%for comments
\newcommand\JP[1]{\textcolor{magenta}{JP: #1}}
\newcommand\lyj[1]{\textcolor{green}{lyj: #1}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Additional math operators
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[colorlinks,
            linkcolor=black,
            anchorcolor=black,
            citecolor=blue,
            urlcolor=black,
            bookmarks=true
            ]{hyperref}

\input{tcilatex}

%=========================================
\begin{document}

\title{ {\sf paraVerifier=Invariant Finder + Formal Proof Generator}}
\titlerunning{paraVerifier: An Invariant Finder and proof generator}
\author{~}
\authorrunning{~}
\institute{~}

\maketitle

%-------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------
Parameterized verification of parameterized protocols like cache coherence protocols is important
but hard.   Our tool {\sf paraVerifier} handles this hard problem in
a unified framework: (1) it  discovers auxiliary invariants and the
corresponding causal information between invariants and rules from a
small reference instance of the verified protocol; (2) the above
invariants and information  can be generalized into parameterized
form to construct a formally parameterized proof in a theorem prover
(e.g., Isabelle). The principle underlying the generalization is the
symmetry mapping. Our method is successfully applied to some typical
benchmarks including some snoopy-based and directory-based. A novel
feature of our method lies in that the last verification result of a
protocol is provided by a formally readable proof in a theorem
prover like Isabelle.

%-------------------------------------------------------------------------
\end{abstract}
%-------------------------------------------------------------------------

%=========================================
Verification of parameterized concurrent systems is interesting in
the area of formal methods, mainly due to the practical importance
of such systems. Parameterized systems exist in many important
application areas: cache coherence protocols, security systems, and
network communication protocols, \emph{etc}. In this work, we will
focus on cache coherence protocols, which plays a key role in modern
computer architecture. They require complex algorithms that must
deal with asynchrony, unpredictable message delays, and multiple
communication paths between many clients. Therefore, the highest
possible assurance for the correctness of these complex
parameterized systems should be guaranteed by formal reasoning
techniques.

The real challenge posed by parameterized verification is that the
desired properties should hold in any instance of the parameterized
system, not just for a single protocol instance. Model checking is
automatical but able to verify just an instance of the parameterized
 system. The correctness of the reference instance  does
not formally suffice to conclude the correctness for all instances.
Due to the extreme importance of many parameterized system, it is
preferable to have a proof that the correctness holds for any
instance.

Some advanced techniques such as compositional and abstraction model
checking are proposed to handle this chanllenge. However, auxiliary
invariants, which is usually provided by  human basing on his
insight to the verification cases, are needed to make these
techniques work. How to find a sufficient and necessary invariants
is the core in the field of parameterized verification.
Besides, the theory foundation of these techniques and their
soundness are only discussed in a paper proof style. For instance,
the theory contains the apparent circularity in reasoning and
applying the auxialiary invariants, and is based on the classical
notion of a so-called simulation proofs. Frankly speaking, the
theory itself is not easy to be understood, and  needs to be
checked mechanically due to its soundness of should be
guaranteed without conditions.

%which are either used for inductive verification or abstraction
%model construction. Therefore, how to find ans use these auxiliary
%invariants is the central problem in the research field of
%parameterized verification.

The aim of tool {\sf paraVerifier} is to solve the parameterized
verification of cache coherence protocols in a unified way. {\sf
paraVerifier} are composed of two parts:  a finder {\tt invFinder}
and a proof generator {\tt proofGen}. In order to verify the that an
invariant $inv$ holds for any parameterizd instance of a protocol.
Firstly,  from a reference model of a protocol with a fixed number
of clients, {\tt invFinder} tries to search
interesting auxialiary invariants and causal relations which is
capable of proving $inv$. Next, {tt proofGen}
 uses the output of {\tt invFinder} in the first stage, and
 construct a a completely parameterized
formal proof which can
be checked automatically in a theorem prover(e.g., Isabelle).

The originality of our work lies the following aspects:
\begin{itemize}
\item Our work is based on a simple but rigrous theory. Three kinds of causal
relations between rules and invariants are introduced, which are
essentially special cases of the general induction rule. Then a
so-called consistency lemma is proposed, which is the cornerstone in
our framework. One one side, it is heuristics inspired by trying to
construct the consistency relation that guides the tool {\sf
invFinder} to find auxiliary invariants. On the other side, the
consistency lemma gives a general guiding principle to prove
invariants  in the parameterized model of a cache coherence
protocol. Especially, the theory foundation itself is  verified as a
formal theory in a well-known and general-purpose theorem prover such as Isabelle, therefore the theoretical foundation is
the most rigourous.

\item Our verification products are a list of interesting invariants
and a formally readable proof script. Our invariants are visible,
 which can characterize the semantical features of the protocol, and aid people to
   precisely
    understand the design of the protocol.
  Furthermore, the formal proof script not  only models the protocol
rigorously and specifies its properties without any ambiguity, but also
proves them mechaniclaly in the theorem prover. A readbale proof script in the theorem prover guranttees the ultimate correctness of the protocol under study.  Therefore, it helps us to achieve the highest possible
assurance for formal reasoning of the protocol.

\item Our work is both automatical and scalable. After the protocol is modelled in {\sf paraVerifier}, auxialiary invariants
 are searched automatically,  the formal proof script in Isabelle is also  automatically generated by {\tt proofGen} , and   checked by Isabelle without human guidance. Thus the most automatical degree is preserved. Furthermore our tool can handle some hard examples from industry like Flash protocols, German2004 protocols, and Godson-t protocols.
\end{itemize}

To the best of our knowledge, {\sf paraVerifier} is the first work
that generates automatically formal proofs in a theorem prover for
verification of cache coherence protocols. Besides, we also generate a new
proof for original flash protocol without adding new auxiliary
variables. This proof is different from those of Park et al \cite{}
because  they introduce the aggressioned Flash protocol model, which
is in fact an abstract transaction model of Flash,   need prove
the correspondence between the abstract model and the original Flash
model, and then prove the correctness of the protocol in the abstract
model, and subsequently derive the correctness of protocol in the
original model by the correspondence. New   auxiliary state variables
like {\tt fwdSrc} are   introduced  for verification. Deep human insight for Flash is needed for both the construction of the aggressioned model  and  introducing new state variables.  Later research on Flash must also rely on these auxiliary
variables for verification. Our work need fewer human's aid in the verifcation of Flash.



%=========================================
%\section{The Design Principle of {\sf paraVerifier}}
%=========================================

\section{Preliminaries}
Consider a set of state variables $V$, $e$, $f$ and $S$ are an
expression, a formula, and a statement over the set of state
variables $V$. $mathsf{andList}~fs$  is an abbreviation of
$fs_1\wedge...\wedge fs_n$, where $n$ is the length of $fs$.
Variables are divided into two categories: array variables or
non-array (global) variables. A state of a protocol $s$ is an
instantaneous snapshot of its behaviour given by a mapping from
variables $V$ to natural numbers.




\paragraph*{Semantics of expressions and formulas}  We write
$\mathsf{expEval}~e~s$ ($\mathsf{formEval}~f~s$) to denote the
evaluation of the expression $e$ (formula $f$) at the state $s$. %\lyj{$\mathsf{formEval}~f~s$)}

\paragraph*{Precondition} Consider a parallel assignment $S=\{x_i:=e_i | i>0\}$,
we define $\mathsf{preCond}~S~f=f[x_i:=e_i]$, which substitutes each
occurrence of $x_i$ by $e_i$.


\paragraph*{Protocols} A protocol is formalized by a pair
$(ini,rules)$, where
%
\begin{itemize}
\item $ini $ is an  initialization predicate;

\item $rules$ is a set of transition rules, each of which is defined as
  $g \vartriangleright  S$, where $g$ is a predicate, and $S$ is a
  parallel assignment to distinct  variables $v_i$ with expressions
  $e_i$. We write $\mathsf{pre}~r=g$, and $\mathsf{act}~r=g$ if $r=g \vartriangleright
  S$.
\end{itemize}

\paragraph*{Parameterized protocols} A parameterized protocol is formalized by a pair
$(pini,prules)$, where $pini$, and each $prule$ in $prules$ are
functions from natural numbers to an actual predicate and  rule.
Usually the number of parameters of a parameterized rule is one. An
instance of a parameterized protocol, which is called the
N-parameterized model, is obtained by instantiating $prule$ with
parameters $i$ such that $i \le N$, where $N$ is an arbitrary
natural number. %Obviously, if $j \le N$ and $i \ne j$, then
%$prule~j$ also exists in the rules of the instance. We can see
%$prule~j$ is the symmetric mirror of $prule~i$ by a permutation
%$[i\mapsto j]$.


\paragraph*{Symmetry and generalization} Here symmetry is defined with respect to
a permutation on the set of natural numbers $\{i. i \le N\}$.We can
define symmetry transformation to a variable w.r.t. a permutation
$\tau$, $symApp~\tau~f~a[i]=a[\tau~i]$; accordingly we can lift the
symmetry transformation to a formula, statement, and rule. Formally
our work  relies on three kinds of predicates to define actual rules
(formulas) from a formal definition of a parameterized rule
(formula): $\mathsf{ex1P}~ N~ P \equiv \exists i. (i \le N \wedge P~
i)$, $\mathsf{ex2P}~ N~ P \equiv \exists i~j. (i \le N \wedge j \le
N \wedge i\ne j \wedge P~ i~j)$, and $\mathsf{ex3P}~ N~ P \equiv
\exists i~j~k. (i \le N \wedge j \le N \wedge k \le N\wedge i\ne j
\wedge i\ne k \wedge j\ne k \wedge P~ i~j~k)$. For instance, let
$prule~i$ is a formal parameterized rule, then the set $\{r.
\mathsf{ex1P}~ N~ \lambda i. prule ~i\}$ is all the actual rules of
the N-paramterized model, each of which are symmetric to  any one of
the others. Namely, the set is the equivalence class of all the
parameterized rules which are symmetric to $prule~1$, thus we can
view the set is an generalization of $prule~1$ in the sense of
symmetry. In this work, symmetry is inherent property of
parameterized cache coherence protocol, which we will fully exploit
in this work.

\paragraph*{Reachable state sets} As usual, the reachable state set
$\mathsf{reachableSet}~ ini ~rules$ of the protocol $(ini,rules)$
can be inductively defined as usual: (1) a state $s$ is in
$\mathsf{reachableSet}~ini~ rules$ if
 $\mathsf{formEval}~ini~s$; (2) a result state $s'$, which is reached by triggering and
 executing a rule $r$ from a state $s$, is also in
 $\mathsf{reachableSet}~ini~ rules$ if  $s$ already is in
 $\mathsf{reachableSet}~ini~ rules$ and $r $ $\in$  $rules$.

\paragraph*{Invariants} In this work, invariants are formulas in a unform: $\neg\mathsf{andList}~atoms$.
Each $atoms_i$ is of the form such that
$cache[1]=\mathsf{exclusive}$. An invariant is required to be
evaluated as true in any one of the reachable state set.

Let $\mathsf{I}$, $\mathsf{T}$, $\mathsf{C}$,  $\mathsf{E}$,
$\mathsf{true}$, and $\mathsf{false}$ are different  constants. $n$
is a parameterized variable, $x$ a global variable. Below we use
abbreviations:
$\mathsf{forallForm}~N~pf\equiv\mathsf{andList}~[pf~0,...,pf~N]$.

\begin{specification}
 pini  N $\equiv$
   x=true $\wedge$ (forallForm N ($\lambda$ i. n[i]=I))\\

    try i $\equiv$ n[i] = I $\vartriangleright$ n[i] := T; \\

    crit i $\equiv$ n[i] = T\& x = true $\vartriangleright$  n[i] := C; x := false;  ;\\

%
   exit i $\equiv$ n[i] = C $\vartriangleright$ n[i] := E; \\


   idle  i $\equiv$  n[i] = E $\vartriangleright$ n[i] := I;  x := true;
  \\% \\
   prules N $\equiv$ \{r. ex1P N ($\lambda$ i. r=crit   i)~$\vee$~ex1P N ($\lambda$ i. r=exit
i)  $\vee$\\
 ex1P N ($\lambda$ i. r=idle i)~$\vee$ ex1P N ($\lambda$ i.r=try i)\}\\
%\\

mutualInv i j $\equiv$
  $\neg$ (n[i]= C $\wedge$ n[j]= C)\\



\end{specification}

Let $N \ge 3$, $(prules~N, pini~N)$ is a parameterized protocol
instance, now we want to prove that mutual exclusion property
$mutualInv~1~2$ holds at any one of the reachable state set of the
protocol.

\paragraph*{Formal proofs inIsabelle/Isar } A formal proof script
will be a product in our formal verification.  A theory is a file
with a named collection of types, functions, and theorems, proofs.
The general format of a theory $T$ is as
follows: \\

$\mathsf{theory}\ T$

${\it declarations\ for\ types,\ definitions,\ lemmas,\ and\
proofs}$

$\mathsf{end}$ \\
A lemma is written as $\mathsf{lemma}~name:
\mathsf{assumes}~a_{1}:``A_{1}~{\sf and} \dots~{\sf and}~a_{n}:
``A_{n}~\mathsf{shows}~B$.


A typical proof  has a more human-readable structure as follows: \\

$\mathsf{proof}$

$\mathsf{assume}~asm_{0}~\mathsf{and}~\ldots~\mathsf{and}~asm_{m}$

$\mathsf{have}~{\it formula_{1}}$

$~~~~\mathsf{proof}$ ....(*proof script for $formula_{1}$*)
$\mathsf{qed}$

...

$\mathsf{have}~{\it formula_{n}}$

$~~~~\mathsf{proof}$ ....(*proof script for $formula_{n}$*)
$\mathsf{qed}$

$\mathsf{show}~{\it thesis}$

$~~~~\mathsf{proof}$ ....(*proof script for $thesis$*)
$\mathsf{qed}$

$\mathsf{qed}$\\

A formal proof theory can be checked automatically by a
theorem-prover. Modern theorem prover have provided good support for
automatical reasoning on many problems which falls in the decidable
theories supported by the prover. However, for a  formalized theory
 which specific to an application like the verification of cache coherence properties,
  the key proof
points which need the most human intelligence such as rule induction
and case analysis, needs the human's insight in this application
field to write them. In our work, our tool {\tt proofGen} generates
these key proof steps automatically.

\section{Consistency Lemma}
A novel feature of our work lies in that three kinds of causal
relations are exploited, which are essentially special cases of the
general induction rule.

 Consider a rule $r$, a formula $f$, and a formula set $fs$, three
 kinds of causal relations are defined as follows:

\begin{definition}  Relation
$\mathsf{invHoldForRule_1} ~f ~r$ if    $ \mathsf{pre}~ r
\longrightarrow \mathsf{preCond}~ f ~(\mathsf{act}~ r)$ ;
$\mathsf{invHoldForRule_2}~ f~ r$ if $f = \mathsf{preCond}~ f
(\mathsf{act}~ r)$; $\mathsf{invHoldForRule_3}~ f~ r ~fs$ if there
exits a formula $f'$ in $fs$ such that
  $(f' \wedge (\mathsf{pre}~ r)) \longrightarrow \mathsf{preCond} ~f ~(\mathsf{act}
  ~r)$; $\mathsf{invHoldForRule}~ f~ r ~fs$ holds if $\mathsf{invHoldForRule_1} ~f
  ~r$, or $\mathsf{invHoldForRule_2} ~f ~r$, or $\mathsf{invHoldForRule_3}~ f~ r
  ~fs$ holds.
\end{definition}

 We can view the relation $\mathsf{invHoldForRule}~ f
r ~fs$ in two ways. Firstly it defines some causality relation
between $inv$, $r$, and $invs$.  $\mathsf{invHoldForRule}_1~f~ r$
  means that after rule $r$ is executed,
 $f$ will be true immediately;   $\mathsf{invHoldForRule}_2~f~ r$ specifies that
 $\mathsf{preCond}~S~f=f$, intuitively this means that none of state variables in $f$ is
 changed, and the execution of statement $S$ does not affect the
 evaluation of $f$.
 $\mathsf{invHoldForRule}_3~f~ r~invs$ states
  that  there exists another invariant $f' \in invs$ such that
  the conjunction of the guard of $r$ and $f'$ implies the precondition  $\mathsf{preCond}~S~f$.
Intuitively, $\mathsf{invHoldForRule} ~f ~r ~fs$ defines a causal
relation, which can guaranttee that if each of formula in $fs$ holds
before the execution of the rule $r$, then  $f$ also holds after the
execution of the rule $r$ f. Secondly the relation
$\mathsf{invHoldForRule} ~f ~r ~fs$ can also be regarded as a
special kind of inductive proof rules, which can be applied to prove
each formula in $fs$ holds at each inductive protocol rule cases.


\begin{definition}
A consistency relation $\mathsf{consistent}~ invs ~ini~ rs$,
 which holds between a protocol $(inis,rs)$ and
a set of invariants $invs=\{inv_1,\ldots, inv_n\}$,  is defined as
follows:
%
\begin{itemize}
\item For any invariant $inv \in invs$,
initializing predicate $ini \in ini$, and state $s$, if $ini$ is
evaluated true at state $s$, then $inv$ is also evaluated true at
state $s$.

\item For any invariant $inv \in invs$, $r$ in the rule set
$rs$, either one of the following five types of relation holds,
i.e., $\mathsf{invHoldForRule_{1-3}}~inv~ r$.

\end{itemize}
\end{definition}


For instance,

\begin{specification}
invOnX$_1$ ~i $\equiv$ $\neg$(x=true $\wedge$ n[i]=C)   \ \ \

invOnX$_2$ ~i $\equiv \neg$ (x=true$\wedge$ n[i]=E)  \\


aux$_1$ ~i~j $\equiv \neg$ ( n[i]=C$\wedge$n[i]=E)   \ \ \

aux$_2$ ~i~j $\equiv \neg$  ( n[i]=E$\wedge$n[i]=C)\\

  pinvs N$\equiv$ \{f. ex2P N ($\lambda$ i j.  f = invonX1 i j) $\vee$ex2P N ($\lambda$ i j.  f = invOnX2 i j)   \\
$\vee$ex1P N ($\lambda$ i.  f= mutualInv i j)    $\vee$ex2P N ($\lambda$ i j.  f =  aux1 i j) \\
$\vee$ex2P N ($\lambda$ i j.  f =  aux2 i j) \}.

\end{specification}

We have  $\mathsf{invHoldForRule_1 }~(\mathsf{invOnX_1} ~1)~
(\mathsf{crit}~1)$, $\mathsf{invHoldForRule2 }~(\mathsf{mutual_1}
~1~2)~ (\mathsf{try}~3)$,
 and $\mathsf{invHoldForRule_3 }~(\mathsf{mutual_1} ~1~2)~ (\mathsf{crit}~1)$.
 The last holds because
 $\mathsf{invOnX_1} ~2 \in invs$, $\mathsf{preCond}~(\mathsf{act}~(\mathsf{crit}~1))~
 (\mathsf{mutual_1} ~1~2)=\neg (\mathsf{C}=\mathsf{C}\wedge n[2]=\mathsf{C})$,
 and $ x=true \wedge \mathsf{invOnX_1}~2 \longrightarrow \mathsf{preCond}~
 (\mathsf{act}~(\mathsf{crit}~1))~~(\mathsf{mutual_1}
 ~1~2)$. It is not diffcult to verify
$\mathsf{consistent}~ (\mathsf{pinvs}~ N) ~(\mathsf{pini}~N)~
(\mathsf{prules}~N)$ also holds.



Now we can formally prove the essence of the aforementioned
causality. Suppose that the consistency relation
$\mathsf{consistent}~ invs ~inis~ rs$ holds, for any $inv \in invs$,
$inv$ holds for any reachable state $s$ such that $s  \in
\mathsf{reachableSet}~ ini~ rs$. This is formalized by a so-called
consistency lemma.

\begin{lemma}\label{consistentLemma}[(consistency lemma)]
  $\isasymlbrakk \mathsf{consistent}~ invs ~ini~ rs$; $s  \in \mathsf{reachableSet}~ ini~ rs$
  $\isasymrbrakk\Longrightarrow$ $\forall inv. inv \in invs \longrightarrow
\mathsf{formEval}~ inv ~s$.
\end{lemma}


%It is the cornerstone in our framework. \JP{No framework is
%mentioned before.} It is \JP{heuristics????} inspired by the
%consistency relation that guides the tool {\sf paraVerifier} to find
%the strengthened invariants, which are used to prove the original
%invariant. The tool \texttt{paraVerifier} works in an iteratively
%semi-proving and semi-searching workflow. In an iterating step, it
%tries to prove some consistent relation exists between an invariant
%and a rule, and automatically generates a new auxiliary invariant if
%there is no such an invariant in the current invariant set, and
%records the corresponding consistency information. This workflow is
%not finished until no new counter example is created.
%\JP{`counter-example' comes from nowhere!}

\section{An overview of problem formulation and our solution to
parameterized verification} Note that almost no invariants but one
$\mathsf{mutualInv}$ in the aforementioned formula set
$\mathsf{pinvs}~ N$ is given initially,  the remaining formulas such
as $aux_i(i>1)$ are needed to find. Only after figuring out all the
auxiriary invariant formula set $\mathsf{pinvs}~ N$ such as
$\mathsf{consistent}~ \mathsf{pinvs}~ N ~(pini~N)~ (prules~N)$, can
we  adopt the consistency lemma to prove all the invariant formulas
in $\mathsf{pinvs}~ N$, which includes the initially given invariant
 $\mathsf{mutualInv}$.

The general architecture of  our solution  to parameterized
verification is illustrated in Fig.~\ref{fig:arch} (a). A small
cache coherence protocol instance {\tt a.fl}, is fed into the
\texttt{invFinder}. The task of tool \texttt{invFinder} is to find
all the necessary ground auxiliary invariants from the reference
protocol instance.
 A table {\tt a.tbl} is worked out  to store the set of ground invariants and
 causal relations, which will be  used by {\tt proofGen} to
create an Isabelle proof   script which models and verifies the
protocol in a parameterized form. In this step, ground invariants
will be generalized into a parameterized form, and accordingly
ground causal relations will be adopted to create parameterized
proof commands which essentially proves the existence of the
parameterized causal relations. At last the Isabelle proof script is
fed into   Isabelle to check the correctness of the protocol.


The consistency lemma is the cornerstone in our framework.  One one
side, it is heuristics to construct a consistency relation that
guides the tool {\sf invFinder} to find auxiliary invariants. On the
other side, the consistency lemma gives a general guiding principle
to prove invariants of a cache coherence protocol. Especially the
consistency lemma eliminates the need of directly using the
induction proof method. It allows us to focus on  the causal
relationship between transition rules of the protocol and
invariants. It allows us to divide the proof of the invariants to a
series of subproofs to verify whether one of the relations
$\mathsf{invHoldForRule_{1-3}}$ hold
  for  a rule  and an invariant. This strategy of dividing and
  conqueing is also the key point to make the series of sub-proofs
  to be automated because the proof patterns for the  subproofs  are similar
  and modular. To sump up, the tool \texttt{proofGen} will
  automatically generates a proof that applies the the consistency
  lemma to prove the correctness of the protocol.


 \begin{figure}[!ht]
% \centering %
 \vspace{-2cm}
\includegraphics[width=1.0\textwidth]{invFinderArchClipA.pdf}
\vspace{-2cm}
 \caption{Two figures}
\label{fig:arch}
\end{figure}
 \vspace{1cm}
%

%It is the task of {\sf paraVerifier} to construct each one of the
%remaining invariants by checking the causal relation between an
%invariant and a rule instance.

\section{The Searching Algorithm of the {\sf invFinder}}
The tool {\sf invFinder} works in a semi-proving and semi-searching
workflow. In an iterating step, it tries to prove some consistent
relation exists between an invariant and a rule, and automatically
generates a new auxiliary invariant if there is no such an invariant
in the current invariant set, and records the corresponding causal
relation information between the current rule and invariant. This
workflow is not finished until no new invariants is created.   The
core part of the searching algorithm of the {\sf invFinder} is given
roughly as follows,
\begin{specification}
1\twoSpaces let findInvsFromRule  chk choose  tautChk isNew rule inv newInvs invs casRel=\\
%2\twoSpaces  let rule=ruleApp pRule paras in\\
3\twoSpaces   val (g $\vartriangleright$ S)=rule in\\

5\twoSpaces   let inv'=preCond S inv in\\


7\twoSpaces   if  inv=inv' then\\

8\twoSpaces  \twoSpaces       let relItem=(rule,
inv,invHoldForRule2~inv~r) in
         (newInvs, relItem:casRel)\\


9\twoSpaces   else if  tautChk (g $\longrightarrow$inv') then\\
10\twoSpaces  \twoSpaces     let relItem=(rule, inv, invHoldForRule1~inv~r) in         (newInvs, relItem:casRel)   \\


11\twoSpaces   else let  candidates= subsets (toAtoms ((dualNeg inv') $\wedge_C$ g ))  in\\

11\twoSpaces  \twoSpaces  let newinv =  choose chk candidates in\\
%12\twoSpaces       val ($\neg$ andList [items])=inv' in\\
%13\twoSpaces       let newinv= $\neg$ (andList ([items]@(and2Ands ant) )) in\\


12\twoSpaces  \twoSpaces     let relItem=(rule, inv,  invHoldForRule3 inv newInv   ) in\\

13\twoSpaces  \twoSpaces   if   ((isNew newInv (newInvs@invs)) then (newInvs@[normalize newInv], relItem\#casRel)\\
14\twoSpaces  \twoSpaces   else (newInvs,  relItem\#casRel)\\


15\twoSpaces  else  error ``no new invariant";\\
\end{specification}


{\sf invFinder} is implemented by FL, which is an excellent STE-tool
of Intel \cite{}. {\sf invFinder} also depends on some oracle. {\tt
chk} is an oracle that checks whether a ground formula  is an
invariant in a given small reference model of the protocol. Such an
oracle can be implemented by firstly translating the formula into a
formula in SMV, and then calling  SMV to check whether it is an
invariant.  {\tt tautChk} is an oracle to check whether a formula is
a tautology. Such a tautology checker for the formula $inv'$  is
implemented translating the formula into a form in SMT (abbrv for
SAT Modulo Theories) format, and then calls an SMT solver such as Z3
to check it.

  The above function {\sf findInvsFromRule} tries to find new
invariants and construct the causal relation between the rule
instance $rule$. %The statement {\tt
%cond => te|fe} is an abbreviation of the if-then-else expression
%that if $cond$ is true then $te$ else $fe$.
Parameters $newInvs$, $invs$, and $casRel$ are new invariants, invariants, and all the
causal relations constructed up to now, the above oracle functions
are also passed as parameters.  % Causal relations  are still not
%checked between the ones in $newInvs$ and rules.
The returned result
is updated new invariants,  and causal relations.
%


\begin{description}
\item[(1)] After computing the pre-condition {\tt inv'=preCond~S~inv} at line 5,
{\sf invFinder} performs case analysis on $inv'$: if {\tt inv=inv'},
 which means that no change made to $inv$ by statement $S$, then the new causal
relation item marked with tag {\tt invHoldForRule$_2$} is recorded
between $rule$ and $inv$, but at this moment there are no new
invariants to be added; for instance, let {\tt rule=crit 3},  {\tt inv=mutualInv~1~2}, thus
{\tt inv'=preCond~S~inv=inv}, thus only a new relation item {\tt (crit 3, inv, invHoldForRule$_2$)} will be added.

\item[(2)] Secondly, if {\tt tautChk g $\longrightarrow$inv'} is true, then
the new causal relation item marked with tag
{\tt invHoldForRule$_1$} is recorded between $rule$ and $inv$, but at this
moment there are no new invariants to be added either; for instance, let {\tt rule=crit~2}, {\tt inv=invOnX$_1$~1 },
{\tt inv'=preCond~S~inv=$\neg_C$(false$=_C$true $\wedge_C$ n[1]$=_C$C)}, obviously, {\tt
g $\longrightarrow_C$ inv'} holds forever because $inv'$ is always evaluated true,
 thus a new relation item {\tt (crit~2, inv, invHoldForRule$_1$)} will be added.


 \item[(3)] Thirdly,  a new auxiliary invariant $newInv$ will be constructed, which will make the causal relation {\tt invHoldForRule$_3$} holds. Function {\tt dualNeg ($\neg_C$ f)} returns f; The function {\tt decompose f } decomposes a formula {\tt f} into a lists of sub-formluas $f_i(i \le N)$ such that each $f_i$ is not of a conjunction form and $f$ is semantically equivalent to $f_1 \wedge_C ...\wedge_C  f_i\wedge_C  ...\wedge_C f_N$. The function {\tt subsets fs} constructs all  subsets of fs, thus
    line 14  decomposes  ((dualNeg inv') $\wedge_C$ g ) into a set of subformulas and constructs a list of candidates. The function {\tt choose} at line 12 chooses a proper  one from candidates, and construct a new invariant $newInv$. {\tt choose} need call {\tt chk} to
guarantee that the constructed formula is an invariant in the given
reference model; and function {\tt isNew} is used to check whether
the invariant is new. If yes, the invariant will be normalized, then be  added into $newInvs$,
 and the new causal relation item marked with tag {\tt invHoldForRule$_3$ } will be added into the causal relations.
Here, the meaning of the word ``new" is modulo to the symmetry
relation. For instance, $\mathsf{mutualInv}~1~2$ is equivalent to
$\mathsf{mutualInv}~2~1$ in symmetry view. The {\tt normalize} function normalize the numbering order of the use of parameters in the invariant $inv$.
The result formula should be   a normal form, whose parameters
  always start from 1, and increase one by one if there are more
  parameters. Namely,  $\neg_C (x=\mathsf{true} \wedge_C n[1]=_C\mathsf{C})$ is normalized, but
  $\neg_C$ (x$=_C\mathsf{true} \wedge_C n[2]=_C\mathsf{C}$  not.    Let {\tt invs=newInvs=$\emptyset$}, {\tt rule=crit~1}, {\tt inv=mutualInv~1~2},
{\tt inv'=preCond~S~inv=$\neg_C$(true$=_C$true $\wedge_C$ n[2]$=_C$C)}, from all the subsets of {\tt \{ n[1]=T, x=true, n[2]$=_C$C\} }, the {\tt choose} oracle selects the subset {\tt \{ x=true, n[2]$=_C$C\}} combines all the item in this candidate, then constructs a new invariant {\tt $\neg$(x=true $\wedge$
   n[2]=C)}. After   normalization, the new invariant {\tt $\neg$(x=true $\wedge$
   n[1]=C)} will be added, and  a new relation item {\tt (crit~1, inv, invHoldForRule3, newInv)} will be added.


\end{description}

\section{The Searching Algorithm of the {\sf invFinder}}
The tool {\sf invFinder} works in a semi-proving and semi-searching
workflow. In an iterating step, it tries to prove some consistent
relation exists between an invariant and a rule, and automatically
generates a new auxiliary invariant if there is no such an invariant
in the current invariant set, and records the corresponding causal
relation information between the current rule and invariant. This
workflow is not finished until no new invariants is created.   The
core part of the searching algorithm of the {\sf invFinder} is given
roughly as follows,
\begin{specification}
1\twoSpaces let findInvsFromRule  chk choose  tautChk isNew pRule paras inv newInvs invs casRel=\\
2\twoSpaces  let rule=ruleApp pRule paras in\\
3\twoSpaces   val (g $\vartriangleright$ S)=rule in\\

5\twoSpaces   let inv'=preCond S inv in\\


7\twoSpaces     inv=inv'=>\\

8\twoSpaces         let relItem=(pRule, paras,
inv,invHoldForRule2~inv~r) in
         (newInvs, relItem:casRel)\\



9\twoSpaces      | tautChk (g $\longrightarrow$inv')\\
10\twoSpaces         =>let relItem=(pRule, paras, inv, invHoldForRule1~inv~r) in         (newInvs, relItem:casRel)   \\


11\twoSpaces       |let newInv=  choose chk  inv' g   then\\


%12\twoSpaces       val ($\neg$ andList [items])=inv' in\\
%13\twoSpaces       let newinv= $\neg$ (andList ([items]@(and2Ands ant) )) in\\


12\twoSpaces       let relItem=(pRule, paras, inv,  invHoldForRule3 inv newInv   ) in\\

13\twoSpaces  \twoSpaces      ((isNew newInv (newInvs@invs))=> (newInvs@[normalize newInv], relItem : casRel)\\
14\twoSpaces  \twoSpaces     |(newInvs,  relItem:casRel)\\


15\twoSpaces   | error no new invariant;\\
\end{specification}

{\sf invFinder} is implemented by FL, which is an excellent STE-tool
of Intel \cite{}. {\sf invFinder} also depends on some oracle. {\tt
chk} is an oracle that checks whether a ground formula  is an
invariant in a given small reference model of the protocol. Such an
oracle can be implemented by firstly translating the formula into a
formula in SMV, and then calling  SMV to check whether it is an
invariant.  {\tt tautChk} is an oracle to check whether a formula is
a tautology. Such a tautology checker for the formula $inv'$  is
implemented translating the formula into a form in SMT (abbrv for
SAT Modulo Theories) format, and then calls an SMT solver such as Z3
to check it.

  The above function {\sf findInvsFromRule} tries to find new
invariants and construct the causal relation between the rule
instance $r=pRule~ para$ and the invariant $inv$. The statement {\tt
cond => te|fe} is an abbreviation of the if-then-else expression
that if $cond$ is true then $te$ else $fe$. Parameters $newInvs$,
$invs$, and $casRel$ are new invariants, invariants, and all the
causal relations constructed up to now, the above oracle functions
are also passed as parameters. Causal relations  are still not
checked between the ones in $newInvs$ and rules. The returned result
is updated new invariants,  and causal relations.
%
\begin{description}
\item[(1)] After computing the pre-condition {\tt inv'=preCond~S~inv} at line 5,
{\sf invFinder} performs case analysis on $inv'$: if {\tt inv=inv'},
 then no change made to $inv$ by statement $S$, the new causal
relation item marked with tag {\tt invHoldForRule2} is recorded
between $r$ and $inv$, but at this moment there are no new
invariants to be added; for instance, let {\tt pRule=crit}, {\tt paras=(3)}, {\tt inv=mutualInv~1~2},
{\tt inv'=preCond~S~inv=inv)}, thus only a new relation item {\tt (crit, (3), inv, invHoldForRule2} will be added.

\item[(2)] Secondly, if {\tt tautChk g $\longrightarrow$inv'} is true, then
the new causal relation item marked with tag
{\tt invHoldForRule1} is recorded between $r$ and $inv$, but at this
moment there are no new invariants to be added either; for instance, let {\tt pRule=crit}, {\tt paras=(3)}, {\tt inv=aux~1 },
{\tt inv'=preCond~S~inv=$\neg$(false=true $\wedge$ n[1]=C)}, obviously, {\tt
g $\longrightarrow$ inv'} holds forever,
 thus a new relation item {\tt (crit, (3), inv, invHoldForRule2)} will be added.

 \item[(3)] Thirdly,  the function {\tt choose} at line 12 chooses the weakest precondition $newInv$
 from the conjuncts of  $g \wedge \neg  inv'$. {\tt choose} need call {\tt chk} to
guarantee that the constructed formula is an invariant in the given
reference model; and function {\tt isNew} is used to check whether
the invariant is new.
 If yes, the invariant will be normalized, then be  added into $newInvs$,
 and the new causal relation item marked with tag {\tt invHoldForRule3 inv'} will be added into the causal relations.
Here, the meaning of the word ``new" is modulo to the symmetry
relation. For instance, $\mathsf{mutualInv}~1~2$ is equivalent to
$\mathsf{mutualInv}~2~1$ in symmetry view. The {\tt normalize} function normalize the numbering order of the use of parameters in the invariant $inv$.
The result formula should be   a normal form, whose parameters
  always start from 1, and increase one by one if there are more
  parameters. Namely, $\neg (x=\mathsf{true} \wedge n[1]=\mathsf{C})$ is normalized, but
  $\neg (x=\mathsf{true} \wedge n[2]=\mathsf{C}$  not.    Let {\tt invs=newInvs=$\emptyset$}, {\tt pRule=crit}, {\tt paras=(1)}, {\tt inv=mutualInv~1~2},
{\tt inv'=preCond~S~inv=$\neg$(true=true $\wedge$ n[2]=C)}, from  two conjunction items {\tt n[1]=T}
 and {\tt x=true} in $g$, the {\tt choose} oracle selects the second, and combines it with $inv'$, then constructs a new invariant {\tt $\neg$(x=true $\wedge$
   n[2]=C)} after necessary simplication by removing {\tt C=C} and normalization, then the new invariant {\tt $\neg$(x=true $\wedge$
   n[1]=C)} will be added, and  a new relation item {\tt (crit, (1), inv, invHoldForRule3 newInv)} will be added.
%In another word,
%$\mathsf{mutualInv}~1~2$  is  one representive of the formula set
%$\{f. ~\mathsf{ex2P}~N~ (\lambda ~i~j. ~f=\mathsf{mutualInv}~i~j )
%\}$.
%The intuitive meaning of the symmetry relation is that $\mathsf{mutualInv}~1~2$ is equivalent to $\mathsf{mutualInv}~2~1$.
%Namely, $\mathsf{mutualInv}~1~2$  is only one representive of the formula set
%$\{f.~ \exists i~j \le 3.f=i\neq j \wedge cache[i]=exclusive\longrightarrow cache[j]=invalid \}$.

\end{description}

For a parameterized rule {\tt pRule}, for an invariant formula $inv$
in $newInvs$, we need a policy to create a list of parameters to
instantiate {\tt pRule} into actual rules {\tt rules}, then call
{\tt findInvsFromRule} to  check causal relations and find new
invariants. How many instantiations are needed? Here the underlying
instantiation principle should guarantee that each typical proof
case in parameterized causal relation analysis, which will be used
in parameterized proofs, should be covered by a ground causal
relation. The samples are enough to cover the proof pattern used in
parameterized  proofs. That is to say, if we regard the finite
instantiations as samplings, we must guarantee that
 the samples are enough to   be generalized in {\sf proofGen}
       to parameterized forms  to finish  parameterized proofs.




%\begin{specification}
%let findInvsFromRule  choose chooses chk tautChk isNew pRule paras inv newInvs\\ invs casRel=\\
%let findInvsFrompRule   choose chooses chk tautChk isNew pRule  inv    invs  casRel=\\
 %   let listOfparas=newParaPolicies  pRule inv in\\
 %   let duppRules=duplicate pRule (length listOfparas) in\\
  %  let RPPairs=zip duppRules listOfparas in\\
 %   findInvsFromRPPairs   choose chooses chk tautChk isNew  RPPairs    invs  casRel;  \\
%\end{specification}

%In code {\sf findInvsFrompRule},  newParaPolicies  pRule inv
%analyzes the forms of pRule and invariant and then generates a list
%of actual parameters to instantiate the $pRule$. $duplicate$
%function
% generates a list of copies of pRules. The line ? zips  duppRules listOfparas into RPPairs which is a list of
% pairs of a parameterized rules and actual paramters to to instantiate the parameterized rule. findInvsFromRPPairs
% is just called to create all new invaraint and according causal relations.
%   The policies, which are used to generate the list of  actual parameters, are also crucial in our framework.
%    Notice that the actual rules, which are instantantiated by the actual parameters, are only a true subset
%      of the set of all possible actual rules, and accordingly the set of ground invariants and causal relations,
%       which are found by {\sf invFinder}, are also true subset of the set all the possible ground invariants and
%       causal relations accordingly.
%       Our parameter instantiation mechanism must guarantee that the computed  ground invariants and causal relations
%         are enough to be generalized
%       to parameterized forms which can be used for parameterized proofs in the parameterized protocol model.
%       That is to say, if we regard the finite   instantiations as samplings, we must guarantee that
%       the samples are enough to cover the proof pattern used in parameterized proofs.
%       Besides, There are restrictions  on the samplings due to the complexity of the protocol under study.
% For instance,

% Generally speaking, according to the numbers of the parameters in  invariant  inv and  rule  pRule,
 %which are formulated by paraNumOfInv and paraNumOfRule,  the policies which newParaPolicies adopts are as follows:
% For instance, for the {\tt simpMutual},
%  the policies which newParaPolicies adopts are as follows:
% \begin{description}
% \item[(1)]  paraNumOfInv inv=1, then we choose 1 and 2 to instantiate paraRule respectively;
% \item[(2)]   paraNumOfInv inv=2, then we choose  1 and 2 and 3 to instantiate paraRule respectively.
% \end{description}
 %\begin{itemize}
 %\item  paraNumOfInv inv=0  , then we choose 1 to instantiate pRule; or choose 1 and 2 to instantiate pRule if paraNumOfRule paraNum=2;
 %\end{itemize}

 Generally speaking, there are two factors which we need consider for working out parameter instantiation policies,
 (a)  the numbers of the parameters in  invariant  $inv$ and  rule  $paraRule$, which are formulated by $\mathsf{paraNumOfInv}~inv$
  and $\mathsf{paraNumOfRule}~r$; (b) the complexity of protocol itself.

Now {\tt invFinder} supports the parameter instantiation policies,
as sown below:

\begin{specification}
1\twoSpaces let newParaPolicy inv r =\\
2\twoSpaces  let pNumOfInv=pNumOfInv inv in let pNumOfR=paraNumOfRule r in\\
3\twoSpaces  (pNumOfR = 0 ) =>[()]\\
4\twoSpaces  |(pNumOfR = 1 ) AND (pNumOfInv  =0)=>[(1)]\\
5\twoSpaces  |(pNumOfR = 2 ) AND (pNumOfInv  =0)=>[(1,2)]\\
6\twoSpaces  |(pNumOfR = 1) AND (pNumOfInv = 1) => [(1),(2)]\\
7\twoSpaces   |((pNumOfR =1) AND (pNumOfInv =2 OR
pNumOfInv =3))  =>
  [(1)],(2),(3)]\\
8\twoSpaces  |(pNumOfR = 2) AND (pNumOfInv = 1) => [(1,2),(2,1),(3,2)]\\
9\twoSpaces   |     [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2) ];\\
\end{specification}

Obviously, {\tt invFinder}  supports restrictions with parameter
numbers of a rule and invariant such that {\tt pNumOfR $\le$
2} and {\tt pNumOfInv $\le$ 3}.
 In the field of cache coherence protocols, most of parameterized
rules have only one parameters. Intuitively, this means that an $i$-th
client (node)'s next action  only depends on the message sent to $i$
, or the flags setting in the directory to indicate $i$'s status. But
in some complex cache coherence protocols like Flash, there are some
rules, which have two parameters $i$ and $j$. These rules are
actions of the protocol depending on two-node's status. For
instance, in a reading-missing action,  $i$ sends a $Get$ request,
if $j$'s cache status is exclusive, then $i$ will be indicated to
fetch the most recent copy from node $j$.

  Due to symmetry property, the above sampling policies cover all parameterized cases by analysing
   the parameters in  invariant  $inv$ and  rule  $paraRule$ when $paraNumOfRule < 2$ or  $paraNumOfInv <
   2$.  Suppose that the invariants searched by {\tt invFinder} are always in a normal form, whose parameters
  always start from 1, and increase one by one if there are more
  parameters. Namely, $\neg (x=\mathsf{true} \wedge n[1]=\mathsf{C}$ is in the invariants found by {\tt invFinder}, but
  $\neg (x=\mathsf{true} \wedge n[2]=\mathsf{C}$ is not.
   For instance, at line 5,
    the sampling case $pInv~1$ and $pRule~ 1$ in the reference instance represents a parameterized case
    $pInv~i_1$ and $pRule~ iR$ where $i_1=iR$ in the parameterized instance; the sampling case
    $pInv~1$ and $pRule~ 2$ in the reference instance represents a parameterized case $pInv~i_1$
    and $pRule~ iR$ where $i_1 \ne iR$ in the parameterized instance. At line 6,
     the sampling case $pInv~1~2$ and $pRule~ 1$ in the reference instance represents a
     parameterized case $pInv~i_1~i_2$ and $pRule~ iR$ where $i_1=iR$ in the parameterized instance;
     the sampling case $pInv~1~2$ and $pRule~ 2$ in the reference instance represents a parameterized
     case $pInv~i_1~i_2$ and $pRule~ iR$ where $i_2=iR$ in the parameterized instance;  the sampling case $pInv~1~2$ and
      $pRule~ 3$ in the reference instance represents a parameterized case $pInv~i_1~i_2$ and $pRule~ iR$
      where neither $i_1=iR$ nor $i_2=iR$ in the parameterized instance.

Both policies at line 5 and 6 can be simplified furthermore if some
conditions is satisfied by the protocol.  If $inv$ does not contain
any global variables, we need not consider the case where we
instantiate $pRule$ with parameter 2 at line 5, and the case where
we instantiate paraRule with parameter 3 at line 6,
 since the causal relation $invHoldForRule_2$ will
hold  in both  cases.

Policies at line 5 and 6 are enough to handle many protocols, whose
rules have at most one parameter. Complex protocols such as Flash
have a small number of rules with 2 parameters. On the other side,
Flash's reachable state set is too large to run a protocol instance
including more than 3 client nodes but a Home node. Therefore, if
$paraNumOfRule~pRule=2$ and $paraNumOf~pInv \ge 2$, we can only
choose a trade-off by using (1,2), (1,3), (2,3), (2,1), (3,1), (3,2)
to instantiate $pRule$. For Flash protocol, the invariants found by
{\tt invFinder} is enough to construct a parameterized proof for
Flash. %Unlike policies (1) and (2), these parameter instantiation
%policies may miss some patterns theoretically. We need some
%additional techniques to ``sum up proof patterns.

For each parameterized rule $prule$, the main body of {\sf
invFinder}'s algorithm generates a list of actual parameters, then
instantiates $prule$ into an actual rule $crule$ with each actual
paramter,  calls the function {\sf findInvsFromRule}  to  search new
invariants and causal relations between $crule$ and $inv$. This
procedure is
 finished until no more new invariants can be created.

 The output of the {\sf invFinder}, is shown in Table
\ref{label-ground-causal relation}. In the table,
$\mathtt{f1'}=\mathsf{inv}_4~2$, $\mathtt{f2'}=\mathsf{inv}_4~1$,
$\mathtt{ant1'}=\mathtt{ant2'}=\mathsf{eqn}~(\mathsf{IVar} ~
 (\mathsf{Global} ~x))~(\mathsf{Const}~True)$, $ant2''= \mathsf{eqn}~
 (\mathsf{IVar}~ ( \mathsf{Para}~ n~ i_1) )  ~(\mathsf{Const} ~C)$.
 \footnote{The names $\mathsf{mutualEx}$ and $\mathsf{invOnX1}$ in
 section \ref{sec:provingInvSets} are just for easy-reading, their
 index in this table is $5$ and $4$ respectively.}

 Each line records the    index of an parameterized invariant, its parameter, name of a parameterized rule, the rule
  parameters to instantiate the rule, a causal relation between
  the ground invariant and a kind of causal relation which involves the kind and proper formulas
  $f'$, $ant'$, and $ant''$  in need (which are used to construct
  one of    causal relations $\mathsf{invHoldForRule}_3$.  The parameterized invariant is drawn from the ground invariant of $invFinder$. The index
  will be useful to name the invariant in the generation of the
  definitions of the invariants, and reference of the invariant in
  the formal proof in Isabelle. The ground invariant and rule can be obtained by
  an  application of the invariant parameters to the parameterized invariant and rule respectively.

%The main body of {\sf paraVerifier}'s algorithm iteratively calls
%the function {\sf findInvsFromRule}  by instantiating each
%parameterized rule with different actual parameters of the finite
%reference protocol model. This procedure is finished until no more
5new invariants can be created.



%-------------------------------------------------------------------------
\section{Automatical generation of Isabelle proof by {\tt proofGen}}
%-------------------------------------------------------------------------

A formal model in a theorem prover like Isabelle
includes the definitions of constants and rules and invariants,
lemmas, and proofs. An overview of the transformation strategy is
shown in Fig \ref{fig:mapping} from a protocol model in FL to
 the one in Isabelle.


 \begin{figure}[!ht]
% \centering %
 \vspace{-0.8cm}
\includegraphics[width=1.0\textwidth]{graphOfTrans.pdf}
%\vspace{-0.5cm}
 \caption{Two figures}
\label{fig:arch}
\end{figure}
 \vspace{1cm}

%Transformations are discussed here from the ground invariants to
%parameterized ground invariants, and  from causal relations
% to  lemmas on parameterized causal relations and the corresponding proofs, main lemma and its proof.
% The   transformation
 % is just a formula generalization procedure basing on symbolic replacement of actual parameters.
 %  Recall that the principle underlying generalization is symmetry.

  For a ground formula $gInv$ with one, two, or three actual parameters, accordingly we
  define a formal parameterized $pInv$ with one, two, or three  formal
  parameters. The first step is to define a formal parameterized
  invariants by replacing the actual parameters (1,2, or 3, ......) with
  symbolic variables ($i_1$, $i_2$, $i_3$, ......) accordingly, then
  use the $ex1P$ or $ex2p$ or $ex3P$) to define all the actual
  invariants
  in the parameterized model. The
  transformation result  is illustrated as follows:

\begin{specification}

 definition pinv4::nat $\Rightarrow$ formula   where [simp]:\\

       pinv4 iInv1 $\equiv$\\

      neg ( andForm ( eqn ( IVar ( Global ''x'') )  ( Const true ))   \\

          ( eqn ( IVar ( Para ''n'' iInv1) )  ( Const C )) )  \\

definition invariants::nat $\Rightarrow$ formula set  where [simp] :\\
invariants N$\equiv$ \{f. ex2P N ($\lambda$ i j.  f = inv1 i
j)  $\vee$ ex1P N ($\lambda$ i.  f= inv2 i)  $\vee$ \\
ex2P N
($\lambda$ i j.  f = inv3 i j)  $\vee$ ex1P N ($\lambda$ i.  f=
inv4 i)  $\vee$ ex2P N ($\lambda$ i j.  f = inv5 i j)   \}


\end{specification}


   For instance, let $gInv_4\equiv \neg (x=true \wedge n[1]=C)$, we define
   a formal parameterized formula:
  $pinv_4~i_1 \equiv
  (x=true \wedge n[i_1]=C)$,
  and $ex1P~N~(\lambda i.pInv~i)$ is all the actual formulas which are symmetric to $gInv$ in the N-parameterized
  model of the protocol, and Spec \ref{} shows its Isabelle syntax of the invariant $pinv_4$ generated by {\tt proofGen}.
 {\tt  invariants N} is the set of all the actual rules. %;  for $gInv= (n[1]=C \wedge n[2]=C)$, we define an
%  $pInv~i_1~i_2=(n[i_1]=C \wedge n[i_2]=C)$, and $ex2P~N~(\lambda i~j.pInv~i~j)$ is all the formulas
%  which are symmetric to $gInv$ in the N-paramterized model of the
 % protocol. At last, we can define the set of all the auxiliary
 % invariants, which will be proved to be consistent with all the
 % rule.
% $ \mathsf{invariants} ~N \equiv \{f. ex1P~ N ~(\lambda i.  f= inv_{11}~ i)  ...\vee ex1P ~N ~(\lambda i.  f = inv_{1m}~ i )
%  \vee
% (ex2P~ N ~\lambda i ~j.  f= inv_{21}~ i~j)  ...\vee ex2P~ N ~(\lambda i~j.  f =inv_{2n}~ i~j
% ) \vee
%(ex3P~ N ~\lambda i ~j~k.  f= inv_{31}~ i~j~k)  ...\vee ex3P~ N
%~(\lambda i~j~k.  f =inv_{3o}~ i~j~k\}$, where $inv_{1i}$,
%$inv_{2j}$, and $inv_{3k}$ are formal invariant formulas with one,
%two three formal parameters respectively.  .


  Basing on the generalization of formulas, accordingly we can generalize ground rules to formal parameterized rules and
  define all the actual rules  $ \mathsf{rules} ~N$ in the N-parameterized model.

 %in order to verify the cache coherence protocols. Others are straightforward.
The most difficult of all is the generation of proofs which require
high intelligence to inspect the semantics of the protocol under
study. First we recall our paper proof. The consistency lemma is our
main weapon to prove, which requires proving two parts of
obligations.



\begin{description}
\item[(1)] For any invariant $inv \in (\mathsf{invariants} ~N) $,  any
state $s$, if $ini$ is evaluated true at state $s$, then $inv$ is
evaluated true at state $s$.
\item[(2)]  For any invariant $inv \in (\mathsf{invariants} ~N)$, any $r$ in rule set
$ \mathsf{rules} ~N$ , one of the causal relations
$\mathsf{invHoldForRule}_{1-3}$ holds.
\end{description}
%
%Proof of Part (1) is  simple. %%For an invariant
%$inv=\mathsf{implyForm}~ant~cons$ in $invs$, we only need to prove
%that either $ant$ is evaluated as false or $cons$ is evaluated true
%at an initial state $s$ in order to prove $\mathsf{formEval}
%~inv~s$. Such a proof  can be automatically solved by Isabelle's
%$\mathsf{auto}$ command.
An overview of a formal proof of Part (2) generated by {\tt
proofGen} is illustrated as follows. Here, it is a typically
readable proof in Isar style \cite{}, which uses   calculation
reasoning such as {\tt moreover} and {\tt ultimately} to do  case analysis on
the form of rules and the invariants. Lines 1-5 use proper Isabelle
proof commands to   decompose the main proof goal with forall  and
implication from, then we fix a rule {\tt r} and {\tt inv}, and have two
assumptions {\tt  b1: inv$\in$ invariants N  and b2:r $\in$ rules
N}, now we need show the goal {\tt invHoldForRule inv r (invariants
N)}. line 5 splits cases of $r$ into all possible cases according to
the definition of $rules~N$. Line 6 starts the case analysis on
$r=r_0$. Line 7 again splits cases of $inv$ into all possible cases
according to the definition of $invariants~N$. Line 8-10 proves the
goal at case when $r=r_0$ and $inv=inv_0$. At line 10,  a defined
lemma {\tt r$_0$VsInv$_0$}  is directly applied to solve the proof
goal. The generation of a lemma {\tt r$_i$VsInv$_i$} will be
discussed next. Similiarly, we can do other case analysis on $inv$,
and finish the proof goal accordingly.
 After finishing the proof of the last case  of $inv=inv_3$ on $inv$,
 we finish the proof of the first case $r=r_0$ on $r$. Similarly, we can
 finish the proof goal at
each subcase of  $r=r_i$. At  lines 19 and  20 we show we have
finished the proof goal formally.


\begin{specification}
1\twoSpaces  show  $\forall$inv r. inv $\in$ invariants
N$\longrightarrow$
 r $\in$rules N$\longrightarrow$invHoldForRule inv r (invariants N) \\

2\twoSpaces    proof((rule allI)+,(rule impI)+)\\
3\twoSpaces    fix inv r ~~\\

4\twoSpaces   assume b1: inv$\in$ invariants N  and b2:r $\in$ rules N\\

5\twoSpaces   have c1:ex1P N ($\lambda$i.r=crit~ i)$\vee$...$\vee$ex1P N ($\lambda$i.r=idle~i)\\

\twoSpaces ~~ ~~         by(cut$\_$tac  b2,auto)\\

6\twoSpaces  moreover$\{$assume c1:
  ex1P N ($\lambda$i.r=crit~ i)\\

7\twoSpaces \twoSpaces   have d1:ex2P N($\lambda$i~j.inv=inv$_{1}$~ i~j)$\vee$ex1P N($\lambda$i.inv=inv$_{2}$~ i)...$\vee$ex2P N
($\lambda$i~j.inv=inv$_{5}$~i~j)\\
\twoSpaces \twoSpaces   ~by (cut$\_$tac b1, simp )\\
%\twoSpaces \twoSpaces  $\vee$ex3P N
%($\lambda$i~j~k.inv=inv$_{3}$~i~j~k) \twoSpaces \twoSpaces   ~by (cut$\_$tac b1, simp )\\

8\twoSpaces\twoSpaces moreover $\{$assume d1:  ex2P N($\lambda$i~j.inv=inv$_{1}$~ i~j)\\
\twoSpaces\twoSpaces~  from d1 obtain i$_1$ i$_2$ where where d2:inv=inv$_{3}$~ i$_1$~i$_2$ ~~by(cut\_tac d1,auto)\\
\twoSpaces\twoSpaces~ have invHoldForRule inv~  r (invariants N)
\twoSpaces\twoSpaces by(cut\_tac c1 d1,simp, rule tryVsinv$_1)\}$\\

\twoSpaces\twoSpaces\twoSpaces\twoSpaces ...\\

9\twoSpaces\twoSpaces moreover $\{$assume d1:  ex1P N~($\lambda$i.inv=inv$_{3}$~i).\\
\twoSpaces\twoSpaces ~  from d1 obtain i$_1$  where d2: inv=inv$_{1}$~ i$_1$~~by(cut\_tac d1,auto)\\
\twoSpaces\twoSpaces~  have invHoldForRule inv r (invariants N)
\twoSpaces\twoSpaces by(cut\_tac c1 d1,simp, rule tryVsinv$_3$)\}
\\

\twoSpaces\twoSpaces\twoSpaces\twoSpaces ...\\

10\twoSpaces\twoSpaces moreover $\{$assume d1:  ex2P N~($\lambda$i~j.inv=inv$_{5}$~i~j)\\
\twoSpaces\twoSpaces  ~ from d1 obtain i$_1$ i$_2$ where d2:inv=inv$_{5}$~ i$_1$~i$_2$ ~~by(cut\_tac d1,auto)\\
\twoSpaces\twoSpaces  ~have invHoldForRule inv r (invariants N)
\twoSpaces\twoSpaces by(cut$\_$tac c1 d1,simp, rule
tryVsinv$_5)\}\\

11\twoSpaces ultimately have invHoldForRule inv r (invariants N)     by blast\}\\
\twoSpaces\twoSpaces ...\\
\twoSpaces\twoSpaces ...\\


12\twoSpaces   moreover $\{$assume c1:  ex2P N~r= r$_2$\\

13\twoSpaces   from c1 obtain i j  where c1: r=r$_{2}$~ i ~j  ~~by(cut\_tac d1,auto)\\

14\twoSpaces   have d1:inv=inv$_0$...$\vee$ex1P N
($\lambda$i.inv=inv$_{1}$~ i)...$\vee$ex2P N
($\lambda$i~j.inv=inv$_{2}$~i~j)...\\
\twoSpaces \twoSpaces  $\vee$ex3P N
($\lambda$i~j~k.inv=inv$_{3}$~i~j~k) \twoSpaces \twoSpaces   ~by (cut$\_$tac b1, simp )\\

15\twoSpaces\twoSpaces moreover $\{$assume d1:  inv= inv$_0$\\
\twoSpaces\twoSpaces~  have invHoldForRule inv r (invariants N)
\twoSpaces\twoSpaces by(cut\_tac c1 d1,simp, rule
r$_2$Vsinv$_0)\}$\\

\twoSpaces\twoSpaces\twoSpaces\twoSpaces ...\\

16\twoSpaces\twoSpaces moreover $\{$assume d1:  ex1P N~($\lambda$i.inv=inv$_{1}$~i).\\
\twoSpaces\twoSpaces~~  from d1 obtain i$_1$  where d2: inv=inv$_{1}$~ i~j~k\\
\twoSpaces\twoSpaces~~  have invHoldForRule inv r (invariants N)
\twoSpaces\twoSpaces by(cut\_tac c1 d1,simp, rule r$_2$Vsinv$_1$)\}
\\

\twoSpaces\twoSpaces\twoSpaces\twoSpaces...\\

17\twoSpaces\twoSpaces moreover $\{$assume d1:  ex3P N~($\lambda$i~j~k.inv=inv$_{3}$~i~j~k)\\
\twoSpaces\twoSpaces  ~ from d1 obtain i$_1$ i$_2$ i$_3$  where d2:inv=inv$_{3}$~ i$_1$~i$_2$~i$_3$ ~~by(cut\_tac d1,auto)\\
\twoSpaces\twoSpaces  ~~have invHoldForRule inv r (invariants N)
\twoSpaces\twoSpaces by(cut$\_$tac c1 d1,simp, rule
r$_2$Vsinv$_3$)\}\\

18\twoSpaces ultimately have invHoldForRule inv r (invariants N)     by blast\}\\
19ultimately show invHoldForRule inv r (invariants N)     by blast\\
20qed
\end{specification}

Due to the unified proof which applies consistency lemma, the proof
can be generated automatically by a two-levels of loop of analysis
on items of aforementioned $rules~N$ and $invarians~N$. Proof
command of case analysis on rules at line 5 or on invariants at line
7 will  a disjunction of all the formulas in the definition of
$rules~N$ and $invarians~N$ respectively. For each proof of the
subcase when {\tt r =r$_i$} and {\tt inv=inv$_j$} like 16 will be
created according to a simple proof template and  the names of the
rule and invariant. Such a proof template is designed according
according to the parameter numbers of a rule and invariant
respectively.

Now we discuss how to generate each lemma {\tt r$_i$Vsinv$_j$},
which will be applied in the proof of main lemma. First an lemma
{\tt critVsinv$_1$} and its proof is illustrated as follows:

\begin{specification}
1lemma critVsinv1:\\
2  assumes  a2: iR $\le$ N and a3: i1 $\le$ N and a4: i2 $\le$ N\\
3  shows  invHoldForRule (inv1 i1 i2) (crit iRule) (invariants
  N)\\
4  proof -\\
5  have iR=i1 $\vee$ iR=i2 $\vee$ (iR $\ne$ i1 $\wedge$  iR $\ne$ i2) by auto\\

6  moreover\{assume  b1:iR=i1\\
7  \twoSpaces have invHoldForRule3 (inv1 i1 i2) (crit iR) (invariants N)\\
 \twoSpaces  \twoSpaces   proof(simp, rule\_tac x=$\neg$ (x=true $\wedge$ n[i2]=C)  in exI,auto)qed\\
8  \twoSpaces then have invHoldForRule (inv1 i1 i2) (crit iR)
(invariants
  N)
by auto\}\\

9  moreover\{assume  b1:iR=i2\\
10 \twoSpaces have invHoldForRule3' (inv1 i1 i2) (crit iRule) (invariants N)\\
 \twoSpaces \twoSpaces   proof(simp, rule\_tac x=$\neg$ (x=true $\wedge$ n[i1]=C  in exI,auto)qed\\
11 \twoSpaces then have invHoldForRule (inv1 i1 i2) (crit iR) (invariants
  N)
by auto\}\\

12   moreover\{assume  b1:(iR $\ne$  i1    iR $\ne$  i2)\\
13 \twoSpaces have invHoldForRule2 (inv1 i1 i2) (crit iR) (invariants N)\\
  \twoSpaces \twoSpaces  proof( auto) qed\\
14 \twoSpaces then have invHoldForRule (inv1 i1 i2) (crit iR)
(invariants
  N)
by auto\} \\

15ultimately show invHoldForRule (inv1 i1 i2) (crit iR)
(invariants N)\\
16qed\\
\end{specification}

line 5 splits cases of $iR$ into all possible cases by comparing
$iR$ with $i_1$ and $i_2$. Line 6-9 proves the case   where
$iR=i_1$; Lines  10-12     the case   where $iR=i_2$; Lines 13-16
the case   where neither $iR=i_1$ nor $iR=i_2$.

The aforementioned proof can be generated by instantiate the following pattern by repalcing {\tt rule},
{\tt inv}, {\tt proof1}, {\tt proof2}, {\tt proof3} with {\tt crit} and the detail proof lines 7-8, 11-12, and 14-15 respectively.
This pattern works for each pair of a parameterized rule with two parameters and an invariant
with two parameters.
%pattern of case analysis on the parameters  is determined by the number of parameters of
%the invariant and rule, which can be formalized by a proof template. Lines 1-5, 6, 9, 10, 13, 14, 17 18,19 can be resused by replacing the names of rule and
% invariant respectively.
Detail proofs such as lines  7, 10, 13 are generated according to the lines on {\tt crit} and {\tt inv1} in Table \ref{}. The mapping is based on the symmetry mapping. Recall the  parameters instantiation policies we discussed in section \ref{},. {\t proof1} at line 7 is according with line in Table because the latter case is the representive of the former case in the sense of symmetry. These proofs are composed of two parts: a middle result to show which kind of causal relation should be choose to prove, then from this the conclusion can be obtained immediately.
Thus  in  {\t proof1} should introduce a middle result $\mathsf{invHoldForRule_{3}}$, whose proof needs an existence construction by providing an auxiliary invariant formula {\tt $\neg$ (x=true $\wedge$ n[i2]=C}. {\t proof2} can be constructed similarly. {\t proof3} chooses $\mathsf{invHoldForRule_{2}}$ to prove,  , an {\tt auto} command is enough because such a goal can be solved automatically in Isabelle.




\begin{specification}
sprintf\\

1"lemma \%sVs\%s:\\
2  assumes  a2: iR $\le$ N and a3: i1 $\le$ N and a4: i2 $\le$ N\\
3  shows  invHoldForRule (\%s i1 i2) (\%s iRule) (invariants
  N)\\
4  proof -\\
5  have iR=i1 $\vee$ iR=i2 $\vee$ (iR $\ne$ i1 $\wedge$  iR $\ne$ i2) by auto\\

6  moreover\{assume  b1:iR=i1\\
7  \twoSpaces \%s\\
8  \twoSpaces then have invHoldForRule (\%s i1 i2) (\%s iR)
(invariants
  N)
by auto\}\\
9  moreover\{assume  b1:iR=i2\\
10  \twoSpaces \%s\\

11 \twoSpaces then have invHoldForRule (\%s i1 i2) (\%s iR)
(invariants
  N)\\

12   moreover\{assume  b1:(iR $\ne$  i1    iR $\ne$  i2)\\
13  \twoSpaces \%s\\
14  \twoSpaces then have invHoldForRule (\%s i1 i2) (\%s iR)
(invariants
  N)  \\

15ultimately show invHoldForRule (\%s i1 i2) (\%s iR)
(invariants
  N)
19qed"\\

 (rule,inv,inv,rule,proof1,inv,rule, proof2, inv,rule, proof3,inv,rule,inv,rule)
\end{specification}



%=========================================
\section{Verification products}
%=========================================

After the auxiliary invariants are found,  the formula set $\mathsf{pinvs}~ N$ in Table \ref{} can be used to analyze
 and verify the design  of the protocol. In fact, they gives a complete
logical characterization of the semantics of the protocol. It will gives a deep insight of the protocol. These properties are divided into two categories: (1) correspondence between
control signals; (2)mutual exclusion between control signals. For instance, the intuitive meaning of the invariants is analyzed as follows:

\begin{table}[htbp] \label{Summarization of invariants}
\centering \caption{Summarization of invariants}
\begin{tabular}{|c|c| }
\hline
invariant &  meaning  \\
\hline
$\mathsf{invOnX_1} ~i$& Once some n[i] is set C, the flag x will be set false \\
\hline
$\mathsf{invOnX_2} ~i$&  Once some n[i] is set E, the flag x will be set false \\
\hline
$\mathsf{mutualInv}~ i ~j$ &  the mutual exclusion between n[i]=C and n[j]=C \\
\hline
$\mathsf{aux}_1~ i ~j$ &  the mutual exclusion between n[i]=C and n[j]=E \\
\hline
$\mathsf{aux}_2~ i ~j$ &  the mutual exclusion between n[i]=C and n[j]=E \\
\hline
\end{tabular}
\end{table}
%$\mathsf{invOnX_1} ~i$ specifies that the flag $x$ shows the
%availability of the critical section. Once some node state variable
%$n[i]$ is set $C$ or $E$, $x$ will be set $true$. Formulas
%$\mathsf{mutualInv}~ i ~j$, $\mathsf{aux_1} ~i~j$, and
%$\mathsf{aux_2} ~i~j$ state the mutual exclusion properties between
%a node's $\mathsf{C}(\mathsf{E})$ state and another different node's
%$\mathsf{C}(\mathsf{E})$ state.
The causal relations listed in Table \ref{} only illustrate why the invariants hold forever at each reachable state set.
That is to say, for a rule $r$ and an $inv$ descriibed in a line, one of the three causal relation $\mathsf{invHoldForRule}_{1\_3}$ holds, so an invariant holds after the execution the rule $r$. The Isabelle proof-script formally generalize these causal relation into parameterized form and proved the existence of the  causal relations. At last, a main lemma formally specifies that why the invariants hold forever at any reachable state set, and is formally proved by using the consistency lemma. In this sense, the Isabelle script can be seen as  a formal analysis document. The script contains 2243 line, and and costs more than 56
minutes for Isabelle to check in a 64-bit computing server platform which has a
160-multicore Intel Xeon CPU with 2.40GHz clock speed.


%=========================================
\section{Experiments}
%=========================================
We implement our tool in Forte \cite{Forte}. More experiments are
done including typical bus-snoopy ones such as MESI and MOESI,
 directory-based ones such as  Germanish, and  German protocols. The detail experiment codes and data can
be found in \JP{\cite{LiCache14}}. Each experiment data includes the
${\sf paraVerifier}$ model, invariant sets found, Isabelle proof
scripts, and the simulation flow graph of one single node. A table
summarizes  our experiments below. Among the benchmarks, the German
protocol   was posted
 as
% Among the benchmarks, a case study is done
%on a directory-based protocol, German protocol, which was posted as
a challenge to the formal verification community by Steven German in
2000. German protocol is a moderate case.
To the best of our knowledge, few people but us give a complete proof to verify
the mutual exclusion  property of the German protocol
 in a theorem prover.

 \begin{table}[htbp] \label{Summarization of experiment results}
\centering \caption{Summarization of results on benchmarks}
\begin{tabular}{|c|c|c|c|c|}
\hline
protocol &  ruleNum & invariantNum & time(s) & memory(M) \\
\hline
simpMutual& 4& 5 & 5.66 & 10.3 \\
\hline
MESI & 4& 3 & 4.66 & 11.5  \\
\hline
MOESI &  5& 3 &3.98 & 11.3  \\
\hline
 German-ish  & 6& 4 &35.8 & 15.1   \\
\hline
German & 13 & 48 & 1222.2 & 16.1   \\
\hline
\end{tabular}
\end{table}

%=========================================
\section{Conclusion}
%=========================================
Our case studies on cache coherence protocols are typical examples
to illustrate the guiding principle of {\sf paraVerifier}. The
 consistency lemma based on the induction approach, is the
core of our work, which gives the heuristics to guide the tool
 to search invariants. Instead of ``invisible invariants in previous work
 (see e.g,~\cite{Pnueli2001}, our invariants are visible,
 which can be further refined to precisely
 analyze the correctness of the protocol both in theoretical and practical aspects.

\bibliographystyle{splncsnat}
\bibliography{gste,cache,refer}
\end{document}

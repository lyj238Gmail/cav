
\documentclass{article}

\usepackage{CJK}

\begin{document}
\begin{CJK}{UTF8}{gbsn} % gbsn: 宋体简化字；gkai 楷体简化字; bsmi 繁体宋书；bkai 繁体楷书

\renewcommand{\abstractname}{摘 \qquad 要}
\renewcommand{\contentsname}{\center 目\qquad\qquad录}
\renewcommand{\listfigurename}{图 \quad 示 \quad 目 \quad 录}
\renewcommand{\listtablename}{表 \quad 格 \quad 目 \quad 录}
\renewcommand{\appendixname}{附录}
\renewcommand{\refname}{\center 参 \quad 考 \quad 文 \quad 献}
%\renewcommand{\bibname}{专著}
\renewcommand{\indexname}{\center 索 \qquad 引}
\renewcommand{\figurename}{图}
\renewcommand{\tablename}{表}
%\renewcommand{\pagename}{页}

%\title{中文题目}
%\author{作者}
%\date{年月日}
%\maketitle




%=========================================
\section{Introduction}
%=========================================
带参协议系统广泛存在于计算机系统的核心模块中，如多处理器体系下的缓存一致性协议、网络安全协议、分布式容错
系统协议、分布式存储协议、高速铁路的列控协议、机场起飞降落控制协议等。这些协议不但在在计算机体系结构的某
个层次上扮演着核心的基础软件角色，而且也应用于重大安全攸关的场合如高铁、航空、航天等。


这里所谓的协议定义了若干角色（role），每个角色都对应着若干规则。扮演各种角色的主体（entity）通过并发执行
这些规则，从而进行交互，达到实现协议目标的功能。所谓的带参指的是：对于参加协议的主体个数并没有限制，理论
上来讲，参加协议、扮演某种角色的主体的个数可以为任意自然数N。对N赋一个具体的值，就构成一个协议实例。形式
化地来讲，一个协议就是一个规则集合R，对于每个r∈R, "r"  是一个带参规则，参数为代表一个主体的自然数标号。
给定参加协议的主体个数N, 一个协议实例就是规则实例集{r（i） | r ∈ R,0<i ≤ N}。 例如，在基于目录的缓存一
致性协议中，有home（目录所在节点）与client（非目录节点）两种角色，每种角色对应着若干条规则，执行这两种角
色的主体就是处理器节点，通过执行这些规则，client节点向home节点发出申请数据缓存副本的命令，根据读写命令的
不同，数据缓存的方式有共享（shared）、独占（exclusive）等方式，home节点要根据当前协议实例具体所处的状态
进行处理，进行必要的主存写回/写穿操作，并在必要的情况下使其他的节点副本失效。缓存协议的目标有安全性以及
活性。安全性主要指的是互斥性与一致性（consistency）：永远不会同时两个不同的节点，它们的缓存的状态都为独
自占有状态；在共享读的系统状态下，主存中的数据与缓存中的数据是一致的；活性指的是一个节点不停地发出缓存数
据申请，它的请求肯定会被满足。在理论上，缓存协议中节点的个数是不受限制的。

带参协议的验证是形式化方法领域的一个极为重要的难题。带参系统的难点在于：一个带参协议具有无穷实例，对任意
实例而言，协议的目标都应该被实现（或者说协议性质应该被满足）。 由于有无穷协议实例，所以人们不可能进行穷
尽的测试或模型检测。对于一个以N为参数的带参协议，假定对N的值为1，2，…，10的情形分别通过了测试（或者检
测），但这并不能保证当N的值为11，12，…时系统也能通过测试。测试或验证人员所难以回答的问题是：究竟要测试或
检测到N的值多大时才能保证所有实例的正确性？另外，随着N的值的增加，协议实例的可达集将呈指数级增长。事实
上，对于较为复杂的带参协议如FLASH 缓存一致性协议，即使基于最好的模型检测工具，也不能枚举出FLASH（N=5）的
协议实例的所有状态进行相关安全性检测。

多年以来，在形式化验证领域的工作主要集中在两个方面：（1）基于定理证明技术的，该技术基于某种逻辑（通常是
高阶逻辑）的形式化系统，将硬件系统的结构以及功能用该逻辑系统的公式表示出来，然后基于该逻辑的推理系统去证
明描述功能定义的公式是结构定义公式的逻辑推论。通常这种推导是在定理证明器的辅助下完成的，比较著名的定理证
明器有剑桥大学的HOL[4][5], Isabelle[6]，INRIA的COQ,以及SRI 的PVS 等[7]。由于高阶逻辑系统有非常强的表达能
力，使用它可以描述带参协议的规则以及性质，把系统参数N看成符号，可以使用诸如归纳法等强有力的数学工具来证
明性质，所以从理论上来讲，定理证明技术非常适合来验证带参
协议的性质。然而在使用归纳法时，必须构造出足够的辅助归纳不变式集才能使得归纳证明能够完成。对于稍微复杂的
一些带参协议，证明相应性质所需的辅助归纳不变式集是非常困难的，这一点极大地阻碍了定理证明技术在带参协议验
证上的应用。（2）基于模型检测技术的，主要又分为基于时态逻辑和自动机的验证技术。如CMU 大学的E.Clarke 等基
于时态逻辑的工作[8]，Kurshan, Holzman 等基于自动机验证的工作[9][10] 。在基于时态逻辑的模型检测技术中，系
统的时序状态转换关系被表示成为有限状态迁移系统，系统的性质由时态逻辑公式来描述，然后验证该有限状态系统是
否满足相应的公式。而基于自动机的验证技术则同时使用自动机表示系统的实现结构与功能规范，然后检查表示实现结
构的自动机与表示功能的自动机所接受的语言是否一致。总的来说，模型检测技术基于有限状态空间的自动搜索，它完
全不需要人的干预，而且随着对称、抽象等技术的引进，模型检测技术的能力在不断提高。由于验证过程的自动化，模
型检测技术更引起工业界的巨大兴趣与投资热情。但是我们已经提到，模型检测只能检测带参协议的一个实例系统，无
法对所有的协议实例系统进行检测。
带参协议的性质验证问题在一般的情况下是不可判定的[3]，所以到目前为止，带参协议的性质验证研究主要针对某一
类具有特别重要价值的协议而展开：如缓存一致性协议，安全协议等。到目前为止，国内外学者所提出的针对带参带参
协议形式化方法大体上可分为几类：
	截止（cutoff）方法。代表性工作有Emerson、Bouajjani、Alan hu以及Daniel Kroening等人的工作。所谓的的
cutoff，指的是一个阈值C，只要Ｎ小于C的所有系统协议实例都满足性质F，那么对参数Ｎ的任意取值时，相应实例都
满足F。即将对任意大小规模的系统协议的性质验证，规约为有限多个小规模协议系统的性质验证，由此给出了一个确
定的判定过程。所以只需对所有规模小于C的实例进行性质C的模型检测，即可检测带参协议的性质F的验证。Emerson最
早提出了cutoff这种将无穷实例转化到有限个实例的规约思想，并对简单广播通讯协议做了实例研究。基于cutoff的思
想，针对不同的应用，不同的学者对cutoff方法进行了扩展与优化。Bouajjani对先进先出队列（FIFO），Alan hu对简
单的目录协议（如GERMAN协议），Daniel Kroening对多线程的进行了形式化验证。cutoff方法的主要问题是阈值C的确
定以及规约到C的正确性证明。阈值C往往依赖于人对某类特定应用领域的知识，由人提出并确定，而且规约问题的正确
性往往是非形式化的纸面证明（paper-proof）。而且即使对某些协议来说，人工确定出来的阈值C 仍然太大，规模等
于C的协议实例仍然超过模型检测工具能够处理的规模。
	抽象（abstraction）方法。给定带参系统P，给定所要验证的性质F，构造出一个抽象带参系统的实例M， M 的主
体个数通常很少（3 到4个），如果性质 F 在M 成立，则 F 在该带参协议的的任何实例M′都成立。在这里，F通常是针
对所有主体而言的安全性质，例如?i.G(i)。M之所以具有这种代表性在于： M 可以模拟M′中与验证性质相关的状态与
转移关系信息，并略去M′中与验证性质无关信息。更形式化地讲，从M′的状态空间到M的状态空间，存在一个抽象函
数，该函数不但保证两个空间状态之间的对应，而且在状态转移关系下抽象函数仍然能够得到保持。所以抽象模型M中
的若干代表进程的行为可以模仿他们在实例M′的行为。抽象方法的另外一个基础就是带参协议P的对称性，对称性对应
的直观意义是构成带参协议的若干主体行为之间的行为相似性，其严格定义基于置换等数学概念[7]。应用对称性，我
们可以推导出F对于代表主体而言在实例M中成立，那么根据协议的对称性，F对于其他主体而言，F同样成立。关于基于
抽象的代表性工作有：
	基于参数抽象与卫式加强（parameter abstraction and guard strengthening）的方法。该方法又被称为CMP方
法，由INTEL的Chou、 Mannava、 Park三人（CMP即为三人名字首字母大写）提出。该方法所构造的抽象模型包括所有
选取的代表主体，以及另外一个附加主体，它代表对所有未选主体的抽象。该抽象模型的构造过程遵循一种反例引导逐
步精化（counter-example guided refinement）的模式，当抽象模型不满足所验证的性质时，需要人工分析反例，找
出一个适当的不变式(invariant)公式去加强某些规则的卫式以约束该模型。重复这个过程直至原验证性质以及所有新
引进的不变式在抽象模型中能够被满足。CMP方法被成功地用于分析GERMAN与FLASH协议[8]，而且被INTEL的验证部门采
用，作为验证INTEL内部的若干多核缓存协议一致性的主要形式化手段。另外Utah大学的Xiaofang Chen等应用该方法分
析了复杂的多核（multicore）缓存一致性协议。FLASH协议与该多核协议都是真正应用于实际的复杂协议，这说明了该
方法的高效及实用性。但这种抽象方法的原理以及正确性证明同样是非形式化的纸面证明。Talupur 与Clarke独立提出
了环境抽象(environment)的概念，类似于CMP以抽象节点来抽象非代表主体的行为。这种方法的缺点在于不变式必需由
人手工提供，这需要对协议语义以及求精过程的反例都要有深刻的理解。为此，吕毅等试图从一个小的协议的实例的可
达集的BDD表示导出的布尔公式作为不变式整体，用于加强协议规则的卫士条件，此方法适用于GERMAN协议，但不适合
FLASH协议的验证。Talupur等提出了FLOW的概念，对不变式的生成起到辅助作用，但不能自动化。
	基于谓词抽象（predicate abstraction）的工作。它要求由给出一组关于协议的变量的谓词（predicate），这些
谓词组成的集合作为抽象模型的抽象状态集合，抽象状态p与p’之间存在迁移关系当且仅当存在协议实例的具体状态s与
s’使得p(s)，p(s’)，并且在实例模型中存在从s到s’的迁移。谓词发现和谓词抽象技术的结合，为非有穷状态系统的安
全性性质给出了一种全自动验证的过程。这里所谓的谓词发现（predicate discovery）技术指的是根据初始几个谓
词，根据所验证性质，根据系统迁移规则，通过经验性的启发式算法自动找到有用谓词集合。应用这种方法Baukus,
Lakhnech与Stahl 分析了GERMAN 协议[10]，Das, Dill和Park分析了简化版本的FLASH协议[11]。应用谓词抽象技术的
关键难点在于: 如何找到一组合适的谓词用于协议抽象。如果仅仅依靠这些谓词并不是很容易就能被发现的。找到这些
合适的谓词实际上等价于找到合适的归纳不变式。
	组合式验证技术。代表性工作有Ken McMillan、Talupur等的的工作。其基本思想是分而治之
(divide-and-conque)。根据被验证模型的特点，将一个无穷的带参验证问题自动或人工地分解为若干有穷的小问题，
并且保证这些小问题能够被模型检测工具自动检测。Ken McMillan使用Cadence SMV工具中实现了相应的组合式验证技
术，并分析了FALSH协议的安全性质与活性性质。该技术同时结合了时态切分（temporal case spliiting）,数据归
约，对称规约等方法。组合式验证的理论基础是针对时序的超限归纳法，它是可靠的(sound)[14]。但是用户必须提供
非干涉引理来分解问题，这就需要使用者不但要对SMV相应的归约证明机制有很好的理解，同时又要对所要验证的带参
协议的语义非常清楚。值得一提的是，McMillan工作验证了FALSH协议的活性性质，这是其他方法不能做到的。
	基于归纳不变式(inductive invariant)的归纳证明方法。代表工作有A. Pnueli,，L.
Zuck，Pandav，Sylvain，Kristic等的工作。此方法来源于定理证明中的归纳方法思想。在这种方法中，可达状态集是
通过归纳定义定义而成：(a)满足协议初始状态谓词的状态s是可达的；(b)若一个状态s是可达的，而且通过一条协议规
则能到达状态s’，那么s’也是可达的。针对归纳定义出来的可达状态s，若要证明s满足性质Inv(s)（在此Inv表示所需
验证的性质），我们自然可以使用归纳法，需要证明两个结论：(c)若s满足协议初始状态谓词，那么Inv(s)成立；(d)
若一个状态s是可达的，Inv(s)成立，而且通过一条协议规则能到达状态s’，那么Inv(s’)也成立。通常为了保证上述命
题成立，仅有 Inv 是不够的，需要找到一些辅助的不变式invs （auxiliary invariants），使得(c)(d)成立。归纳定
义以及归纳证明的具体实现以来于人们选取的工具。Das，Dill 与 Park 等人使用 PVS 定理证明器，基于对 FALSH 协
议本身的深刻理解构造出相应的辅助不变量，并验证了完整的FLASH协议的一致性。值得一提的是，这是人们首次完成
FLASH协议的验证。A. Pnueli 等提出了一种利用带小的协议实例的可达集的BDD符号化表示计算出相应的“不可见不变
量”(invisible)作为辅助不变式，并基于TLV工具实现了不变式计算以及归纳证明。Pandav 等提出了一种启发式的方
法，给出了分析反例，找出不变式的几种模式，人工地找出归纳不变式。并基于UCLID工具实现了归纳证明，手工完成
了GERMAN与简化版的FLASH的验证。Sylvain，Kristic等基于CUBICLE工具，根据一个协议实例的小实例的可达集，自动
地计算出辅助不变式集合，并能够生成相应的Why3证书(certificate)来作为该带参协议的形式化证明，Coq证明器能够
支持Why3证书对应的证明。CUBICLE实现基于两个关键技术：基于并行SMT求解器的一阶逻辑判定工具；BARB的后向
(backward)搜索技术。前者用于表示带参协议的语义模型以及性质的形式化表示；后者用于不变式的生成。这两项技术
使得CUBICLE成为目前为此最好的带参协议验证工具。除了完整版的FLASH协议还未能给出Why3证书，一般的带参协议的
基准测试集(benchmark)都能得到自动验证。

中文 Hello, world!
\end{CJK}
\end{document}

\documentclass{llncs}
%%%%%%%%%%%%%%%%%%%%%%
%%%%   PACKAGES   %%%%
%%%%%%%%%%%%%%%%%%%%%%
\usepackage{makeidx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{latexsym}
\usepackage{url}
\usepackage{color}
\usepackage{isabelle}
\usepackage{isabellesym}
\usepackage{theorem}
\usepackage{algorithmic}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
%\usepackage{program}
\usepackage{cases}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%For Isabelle code
\newlength{\fminilength}
\newsavebox{\fminibox}
\newenvironment{fmini}[1][\linewidth]
  {\setlength{\fminilength}{#1\fboxsep-2\fboxrule}%
   \vspace{2ex}\noindent\begin{lrbox}{\fminibox}\begin{minipage}{\fminilength}%
   \mbox{ }\hfill\vspace{-2.5ex}}%
  {\end{minipage}\end{lrbox}\vspace{1ex}\hspace{0ex}%
   \framebox{\usebox{\fminibox}}}

\newenvironment{specification}
{\noindent\scriptsize
\tt\begin{fmini}\begin{tabbing}X\=X12345\=XXXX\=XXXX\=XXXX\=XXXX\=XXXX
\=\+\kill} {\end{tabbing}\normalfont\end{fmini}}
\def \twoSpaces {\ \ }
\def \oneSpace {\ }
\def \eqc {\doteq }
\def \andc {\barwedge }
\def \negc {!}
\def \orc {\veebar }
\def \alt {$/\backslash$ }
\def \cat {\symbol{94}}

\def \dbRight {$\backslash\backslash$}
\def \iInv {iInv}
\def \iR {iR}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%for comments
\newcommand\JP[1]{\textcolor{magenta}{JP: #1}}
\newcommand\lyj[1]{\textcolor{green}{lyj: #1}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Additional math operators
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[colorlinks,
            linkcolor=black,
            anchorcolor=black,
            citecolor=blue,
            urlcolor=black,
            bookmarks=true
            ]{hyperref}

\input{tcilatex}

%=========================================
\begin{document}

\title{ {\sf A Novel Approach to Parameterized verification of Cache Coherence Protocols}}
\titlerunning{A Novel Approach to Parameterized verification of Cache Coherence Protocols}
\author{~}
\authorrunning{~}
\institute{~}

\maketitle
\vspace{-2.6cm}
%-------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------
Parameterized verification of parameterized protocols like cache coherence protocols is important
but hard.   Our tool {\sf paraVerifier} handles this hard problem in
a unified framework: (1) it automatically  discovers auxiliary invariants and the
corresponding causal relations %between invariants and rules
 from a small reference instance of the verified protocol; (2) the above
invariants and causal relation information  can be also  automatically generalized into a parameterized
form to construct a formally parameterized proof in a theorem prover
(e.g., Isabelle). The principle underlying the generalization is the
symmetry mapping. Our method is successfully applied to typical
benchmarks including  snoopy-based and directory-based. Another novel
feature of our method lies in that the last verification result of a
protocol is provided by a formally readable proof.% in a theorem
%prover like Isabelle.

%-------------------------------------------------------------------------
\end{abstract}
%-------------------------------------------------------------------------
%-------------------------------------------------------------------------
\vspace{-1.5cm}
\section{Introduction }
%-------------------------------------------------------------------------
%=========================================
Verification of parameterized concurrent systems is interesting in
the area of formal methods, mainly due to the practical importance
of such systems. Parameterized systems exist in many important
application areas: cache coherence protocols, security systems, and
network communication protocols, \emph{etc}. %In this work, we will
%focus on cache coherence protocols, which play a key role in modern
%computer architectures. They require complex algorithms that must
%deal with asynchrony, unpredictable message delays, and multiple
%communication paths between many clients. Therefore, the highest
%possible assurance for the correctness of these complex
%parameterized systems should be guaranteed by formal reasoning
%techniques.
The real challenge posed by parameterized verification is that the
desired properties should hold in any instance of the parameterized
system, not just for a single protocol instance. Model checking is
automatical but able to verify just an instance of the parameterized
 system. The correctness of the reference instance  does
not formally suffice to conclude the correctness for all instances.
Due to the extreme importance of many parameterized system, it is
preferable to have a proof that the correctness holds for any
instance.

\paragraph*{Related Work} There have been a lot of research papers in the field of  parameterized
verification~\cite{Pnueli1996,Bj√∏rner1997,Arons2001,Pnueli2001,Tiwari2001,Chou2004,Pandav2005,Lv2007,cubicle2011}.
Among them, the `invisible invariants' method, proposed in~\cite{Arons2001},
is an automatic technique for parameterized verification. In this
method, auxiliary invariants are computed in a finite system
instance to aid inductive invariant checking.  % Work~\cite{Arons2001,Lv2007} attempts to automatically
%find invariants. However, the invisible invariants are raw boolean formulas transferred from the reachable sate set of a small finite instance
%of a protocol, which are BDDs computed by TLV (an variant of BDD\_based SMV model checker). They are too raw to have an intuitive meanings. The capacity of the invisible invariant method is seriously limited when computing the reachable  set of invisible invariants for  the inductive checking is not feasible in the case of a large example like FLASH . Until now, the  examples, which can be handled by the "invisible invariant" method, are quite small,  we still can't find successful experiments  on large examples like FLASH with data paths.
The CMP method, which adopts parameter abstraction and guard strengthening, is proposed
in~\cite{Chou2004} for verifying a safety property $inv$ of
a parameterized system.
 An abstract instance of the parameterized protocol %$, % which consists of m + 1
%nodes $\{P_1, \ldots , P_m, P^*\}$ with $m$ normal nodes and one
%abstract node $P^*$, is constructed iteratively. The abstract system
is constructed by a counter-example-guided refinement process.  %However, this method's soundness is only argued in an
informal way. %To the best of our knowledge, no one has
%formally proved its correctness in a theorem prover although the authors argued for a mechanized proof for all the thing of CMP in \cite{Chou2004}. Besides, the analysis of counter-example and generation of new auxiliary invariants usually
% depend on human's deep insightful understanding of the protocol. It is too laborious for people to do these analysis. %and some effective automatic  tool is needed to help people.
%It was demonstrated in
%[7] that this method is powerful enough to handle complex
%cache coherence protocols such as FLASH effectively.





The degree of scalability and automatic is the most important of all to estimate an approach in the field of parameterized verification. For instance, FLASH is a hard real-world benchmark for any proposed method for parameterized verification. Human guidance still plays a key role in the existing successful verification for FLASH in \cite{Park1996a,McMillan2001,Chou2004} up to now.%: °∞if the method works on FLASH, then there is a good chance that it will also work on many real-world cache coherence protocols°± \cite{Chou2004}. However, the existing approaches, which have verified FLASH, need too much human intervention. The first full verification of safety properties of FLASH is done by work in \cite{Park1996a}. Park and Dill  proved the safety properties of FLASH using  PVS \cite{cade92-pvs}. %They introduce the aggressioned FLASH protocol, which
%is in fact an abstracted transaction version of FLASH,   need prove
%the correspondence between the abstract and the original FLASH
%protocol, and then prove the correctness of the abstracted protocol, and subsequently derive the correctness of  the
%original protocol by the correspondence. New   auxiliary state variables
%like {\tt fwdSrc} are   introduced  for verification. Deep human insight for FLASH is needed for both the construction of the aggressioned model  and  introducing new state variables.  Later research on FLASH must also rely on these auxiliary
%variables for verification.
%McMillan applied compositional
%model checking \cite{McMillan2001}  and used Candence SMV  \cite{cadenceSMV} to the verification of both safety and liveness properties of FLASH. In a different context, safety
%properties of German 2000 and FLASH were proved via
%Murphi tool \cite{alanHuMurphi} by adopting CMP method in \cite{Chou2004}. In
%all the three methods mentioned above, auxiliary invariants
%have to be supplied manually. Predicate abstraction based
%methods were applied to verify
%FLASH in \cite{dillPred}. Users need to manually provide plausible properties
%in predicate abstraction and automated predicate discovery
%techniques to find large predicates. So verifying large protocols
%like FLASH using predicate abstraction is also difficult. In contrast to previous work, our work need fewer human's aid in the verification of FLASH.   Both the auxiliary invariants and formal proof are generated automatically, and these   auxiliary invariants have intuitive meanings which can  be used to analyze FLASH.  %  The abstractions
%we used, the reliance on apparently circular reasoning, and the counterexampleguided
%discovery of noninterference lemmas are all deeply influenced by McMillan°Øs
%work.
There are two central problems which need better solution in the parameterized verification for complex protocols like FLASH.  How to find a set of sufficient and necessary invariants
is the core in the field of parameterized verification. It is desirable that the
invariants are provided with less human intervention.
Besides, the theory foundation of a technique of parameterized verification and its
soundness are only discussed in a paper proof style.  We will compare our approach in \ref{sec:experiments}.%For instance,
%the theory contains the apparent circularity in reasoning and
%applying the auxialiary invariants, and is based on the classical
%notion of a so-called simulation proofs \cite{Chou2004}. Frankly speaking, the
%theory itself is not easy to be understood, and  needs to be
%checked mechanically due to its soundness of should be
%guaranteed without conditions.
It is preferable to make all the verification can be formulated in a publicly-recognized trust-worthy framework like a theorem prover \cite{Chou2004}.

%which are either used for inductive verification or abstraction
%model construction. Therefore, how to find ans use these auxiliary
%invariants is the central problem in the research field of
%parameterized verification.

The aim of tool {\sf paraVerifier} is to solve the parameterized
verification of cache coherence protocols in a unified way. {\sf
paraVerifier} is composed of two parts:  an invariant finder {\tt invFinder}
and a proof generator {\tt proofGen}. In order to verify  that an
invariant $inv$ holds for any parameterizd instance of a protocol.
Firstly,  from a reference model of a protocol with a fixed number
of clients, {\tt invFinder} tries to search
interesting auxiliary invariants and causal relations which is
capable of proving $inv$. Next, {\tt proofGen}
 uses the output of {\tt invFinder} in the first stage, and
 constructs a a completely parameterized
formal proof which can
be checked automatically in a theorem prover(e.g., Isabelle).


The originality of our work lies in the following aspects:
\begin{itemize}
\item Our work is based on a simple but elegant theory. Three kinds of causal
relations are introduced, which are
essentially special cases of the general induction rule. Then a
so-called consistency lemma is proposed, which is the cornerstone in
our framework. On one side, it is heuristics inspired by trying to
construct the consistency relation that guides the tool {\sf
invFinder} to find auxiliary invariants. On the other side, the
consistency lemma gives a general guiding principle to prove
invariants  in the parameterized instance of a cache coherence
protocol. Especially, the theory foundation itself is  verified as a
formal theory in Isabelle, therfore the theoretical foundation is
the most rigourous.

\item Our verification products are a list of interesting invariants
and a formally readable proof script. Our invariants are visible,
 which can characterize the semantical features of the protocol, and help people to
   precisely
    understand the design of the protocol. %This feature distinguish ours from  the so-called ``the invisible invariants" method clearly.
  Furthermore, the formal proof script not  only models the protocol
rigorously and specifies its properties without any ambiguity, but also
proves them mechanically in the theorem prover. Therefore, it helps us to achieve the highest possible
assurance for formal reasoning of the protocol.

\item Our work is both automatical and scalable. After the protocol is modelled in {\sf paraVerifier}, auxiliary invariants
 are searched automatically,  the formal proof script in Isabelle is also  automatically generated by {\tt proofGen} , and   checked by Isabelle without human guidance. Thus the most automatical degree is preserved. Furthermore our tool can handle some hard examples from industry like FLASH protocols, %German2004 protocols,
 and Godson-t protocols.
\end{itemize}

To the best of our knowledge, {\sf paraVerifier} is the first work
that generates automatically formal proofs in a theorem prover for
verification of cache coherence protocols. It is also the first one which automatically verify safety properties of  full version of FLASH without auxiliary invariants manually provided by people.



%=========================================
%\section{The Design Principle of {\sf paraVerifier}}
%=========================================

\section{Preliminaries}
%\subsection{Protocol syntax} \label{sec:protocolSyntax}
%Variable are defined by the following BNF grammar:
%\begin{equation*}
%\left.
%\begin{array}{l}
%\mathtt{
%var ::=id |var[int] |rcd.id}
%\end{array}%
%\right.
%\end{equation*}
There are three kinds of $variables$:
1) simple identifier, denoted by a string;
2) element of an array, denoted by a string followed by a natural inside a square bracket. E.g., $arr[i]$ indicates the $i$th element of the array $arr$;
3) filed of a record, denoted by a string followed by a dot and then another string. E.g., $rcd.f$ indicates the filed $f$ of the record $rcd$.
Each variable is associated with its $type$. There are three types in our model, including enumeration, natural number, and Boolean.

%%Expressions and formulas are defined recursively by the following BNF grammar:
%\begin{equation*}
%\left.
%\begin{array}{l}
%\mathtt{
%exp::=var | const | formula?exp:exp|}\\
%\mathtt{formula::=True| False| exp=exp | formula ~op~ formula | \neg formula }

%\end{array}%
%\right.
%\end{equation*}

$Experssions$ and $formulas$ are define mutually recursively. can be simple or compound. A simple expression is either a variable or a constant, while a compound expression is constructed with the ite(if-then-else) form $f?e_1:e_2$, where $e_1$ and $e_2$ are expressions, and $f$ is a formula.
A $formula$ can be an atomic formula or a compound formula. An atomic formula can be a boolean variable or boolean constant, or in the equivalence form $e_1\eqc e_2$, where $e_1$ and $e_2$ are two expressions. A $formula$ can also be constructed from formulas using the logic connectives, including negation ($\negc$), conjunction ($\andc$), disjunction ($\orc$), implication ($\dashrightarrow$). %, logical equivalence ($\longleftrightarrow$).

An $assignment$ is a mapping from a variable to an expression, and is denoted with the assigning operation symbol ``:=''. A $statement$ $\alpha$ is a set of assignments which are executed in parallel, e.g., $ x_1:=e_1;x_2:=e_2;...;x_k:=e_k $. If an assignment maps a variable to a (constant) value, then we say it is a $value$-$assignment$.  We use $\alpha|_x$ to denote the expression assigned to $x$ under the statement $\alpha$. For example, let $\alpha$ be $\{arr[1]:=C;x:=false\}$, then $\alpha|_x$ returns $false$. A $state$ is an instantaneous snapshot of its behavior given by a set of value-assignments.




For every expression $e$ and formula $f$, we denote the value of $e$ (or $f$) under the state $s::var \Rightarrow valueType $ as $\mathbb{A}[e,s]$ (or $\mathbb{B}[f,s]$)
For   a formula $f$, we write %$s,e\mapsto c$ and
$s\models f$ to mean %$\mathbb{A}[e,s]=c$ and
$\mathbb{B}[f,s]=true$.
Formal semantics of expressions and formulas are given in HOL (higer-order logics) as usual, which is shown in the appendix.   \footnote{The  logic to specify parameterized system is a special logic, which can be embedded in HOL supported by Isabelle. Therefore HOL can be seen as the main meta-logic to specify our work.}


For an expression $e$ and a statement $\alpha= x_1:=e_1;x_2:=e_2;...;x_k:=e_k $, we use $\mathsf{vars(\alpha)}$ to denote the variables to be assigned $\{x_1,x_2,...x_k\}$; and use $e^{\alpha}$ to denote the expression transformed from $e$ by substituting each $x_i$ with $e_i$ simultaneously.
Similarly, for a formula $f$  and a statement $\alpha= x_1:=e_1;x_2:=e_2;...;x_k:=e_k $, we use $f^{\alpha}$ to denote the formula transformed from $f$ by substituting each $x_i$ with $e_i$.
Moreover, $f^{\alpha}$ can be regarded as the weakest precondition of formula $f$ w.r.t. statement $\alpha$, and we denote $preCond(f,\alpha)\equiv f^{\alpha}$. Noting that a state transition is caused by an execution of the statement, formally, we define: $s\overset{\alpha}{\twoheadrightarrow } s' \equiv$ $(\forall x \in \mathsf{vars}(\alpha). s'(x)= \mathbb{A}[\alpha|_x,s])$ $\wedge (\forall x \notin \mathsf{vars}(\alpha). s'(x)= s(x))$ .

A $rule$ $r$ is a pair $<g,\alpha>$, where $g$ is a formula and is called the $guard$ of rule $r$, and $\alpha$ is a statement and is called the $action$ of rule $r$.
 For convenience, we denote a rule with the guard $g$ and the statement $\alpha$ as $g \vartriangleright \alpha$, $\mathsf{act}(g \vartriangleright \alpha)\equiv \alpha$ and $\mathsf{guard}(g \vartriangleright \alpha)\equiv g$. If the guard $g$ is satisfied at state $s$, then $\alpha$ can be executed, thus a new state $s'$ is derived. We call the rule $g \vartriangleright \alpha$ is triggered at $s$, and transitioned into $s'$. Formally we define: $s\overset{r}{\rightarrow } s' \equiv s\models \mathsf{guard}(r) \wedge s\overset{\mathsf{act}(r)}{\twoheadrightarrow } s'$.

A $protocol$ $\mathcal{P}$ is a pair $(I,R)$, where $I$ is a set of $formulas$ and is called the initializing formula  set, and $R$ is a set of rules. %A $state$ is an instantaneous snapshot of its behavior given by a set of assignments.
 As usual, the reachable state set of protocol  $\mathcal{P}=(I,R)$, denoted as $\mathsf{reachableSet}(\mathcal{P})$, can be defined inductively: (1) a state $s$ is in
$\mathsf{reachableSet}(\mathcal{P})$ if there exists a formula $f \in I$, and $s \models  f$; (2) a state $s$ is in
$\mathsf{reachableSet}(\mathcal{P})$ if there exists a  state $s_0$  and a rule $r \in R$ such that $s_0 \in \mathsf{reachableSet}(\mathcal{P})$ and $s_0\overset{r}{\rightarrow } s$.

A parameterized object(T) is simple a function from a natural number to T, namely of type $nat \Rightarrow T$. For instance, a parameterized formula $pf$ is of type $nat \Rightarrow formula$, and we define
$\mathsf{forallForm}(1,pf)\equiv~pf(1)$, and $\mathsf{forallForm}((n+1),pf)\equiv\mathsf{forallForm}(n,pf) \andc pf(n +1)$. $\mathsf{existsForm}(1,pf)\equiv~pf(1)$, and $\mathsf{existsForm}((n+1),pf)\equiv\mathsf{existsForm}(n,pf) \orc pf(n +1)$.





Now we use a simple example to illustrate the above definitions by a simple mutual exclusion protocol with $N$ nodes. Let $\mathsf{I}$, $\mathsf{T}$,
 $\mathsf{C}$, and  $\mathsf{E}$  be three enumerating values, $x$,  and  $n$ are  simple and array variables,

\begin{example}\label{example1}Mutual-exclusion example.

\begin{specification}
assignN(i)$\equiv$n[i]=I\\
 pini(N) $\equiv$
   x=true $\wedge$  forallForm(N,assignN )\\

    try(i) $\equiv$ n[i] $\eqc$ I $\vartriangleright$ n[i] := T \\

    crit(i) $\equiv$ n[i] $\eqc$ T$\wedge$ x = true $\vartriangleright$  n[i] := C; x := false\\

%
   exit(i) $\equiv$ n[i] $\eqc$ C $\vartriangleright$ n[i] := E \\


   idle(i) $\equiv$  n[i] $\eqc$ E $\vartriangleright$ n[i] := I;  x := true
  \\% \\
   prules(N) $\equiv$ \{r. $\exists$ i. i $\le$ N $\wedge$( r=crit(i)~$\vee$ r=exit(i)  $\vee$ r=idle (i)~$\vee$ r=try i)\}\\
%\\

mutualEx(N)$\equiv$ (pIni(N), prules(N))\\

mutualInv(i,j) $\equiv$
  $\negc$ (n[i]$\eqc$ C $\andc$ n[j]$\eqc$ C)\\



\end{specification}
\end{example}


As Hoare logics specifies,  after executing statement $S$, $f$ holds iff $\mathsf{preCond}~f~S$ holds before the execution.
\begin{lemma}\label{lemma-preCond}
Suppose $s\overset{S}{\twoheadrightarrow } s'$,
$s\models (\mathsf{preCond} (f, S))$ if and only if $s'\models f$
\end{lemma}
%definition statementEnableForm:: rule $\Rightarrow$
%formula$\Rightarrow$bool
%\\
% where statementEnableForm r f$\equiv$
%$\forall$s. formEval (pre r) s \\
%$\longrightarrow$ formEval  (preCond f (act r)) s\\
%definition statementDisableForm::rule$\Rightarrow$formula$\Rightarrow$bool\\
%where statementDisableForm r f $\equiv$
 %    $\forall$s. formEval (pre r) s \\
%$\longrightarrow$ $\neg$ formEval  (preCond f (act r)) s
%\end{specification}

%Function $\mathsf{statementEnableForm}$ says that the guard of the rule implies
% the pre-condition of  formula $f$  w.r.t. statement of
% the rule. This means that $f$ must be valid after statement $S$ is executed.
%On the other hand,  $\mathsf{statementDisableForm}$ says that   the
%guard of the rule implies the negation of the pre-condition of
%formula $f$ w.r.t. statement of the rule. This means that $f$ must
%be invalid after statement $S$ is executed.
%For instance,  for the statement $S=\mathsf{assign}~
%((\mathsf{Para}~  n~ 0), (\mathsf{Const} ~\mathsf{T}))$, formula
%$f_1= \mathsf{eqn}~ (\mathsf{IVar}~ (\mathsf{Para}~ n 0))
%(\mathsf{Const}~ \mathsf{T})) $, $f_2= \mathsf{eqn}~ (\mathsf{IVar}~
%(\mathsf{Para}~ n ~0))\mathsf (\mathsf{Const}~ \mathsf{E}))$, we
%have $\mathsf{statementEnableForm}~S~f_1$ and
%$\mathsf{statementDisableForm}~S~f_2$. We also define two functions
%$\mathsf{varOfForm}~f$ and $\mathsf{varOfSent}~S$ to denote the set
%of variables used in the formula $f$ and statement $S$.
\section{Causal relations and consistency lemma} \label{sec:causal_rel}
A novel feature of our work lies in that three kinds of causal
relations are exploited, which are essentially special cases of the
general induction rule.

 Consider a rule $r$, a formula $f$, and a formula set $fs$, three
 kinds of causal relations are defined as follows:\\
 \begin{definition}
We define the following relations: $\mathsf{invHoldForRule_1}::state \times formula\times rule \Rightarrow bool$, $\mathsf{invHoldForRule_2}::state\times  formula\times rule  \Rightarrow bool$,  $\mathsf{invHoldForRule_3}::state \times formula\times rule \times rule set\Rightarrow bool$, and $\mathsf{invHoldForRule_3}::state \times formula\times rule \times rule set\Rightarrow bool$.
\begin{enumerate}
\item $\mathsf{invHoldForRule_1} (s,f,r) \equiv $$s \models \mathsf{pre}(r) \longrightarrow s \models \mathsf{preCond}(f ,\mathsf{act}(r))$;\footnote{Here  $\longrightarrow$ and $\longleftrightarrow$ are HOL connectives.  }
\item $\mathsf{invHoldForRule_2}(s,f,r) \equiv  $$s \models f \longleftrightarrow s \models \mathsf{preCond}( f,(\mathsf{act}( r))$;
\item $\mathsf{invHoldForRule_3}(s,f,r,fs) \equiv$  $\exists f' \in fs$ s.t.
$s \models ( f' \andc (\mathsf{pre}(r))  \longrightarrow s \models \mathsf{preCond}(f ,\mathsf{act}(r))$;
\item $\mathsf{invHoldForRule}(s,f,r, fs) \equiv$   $s \models\mathsf{invHoldForRule_1}(s,f,r) \vee s\models\mathsf{invHoldForRule_2}(s,f,r) \vee s\models \mathsf{invHoldForRule_3}(s,f,r,fs)$.
%\item $\mathsf{invHoldForRule}~ f~ r ~fs \equiv (\mathsf{invHoldForRule_1} ~f
%  ~r) \lor (\mathsf{invHoldForRule_2} ~f ~r) \lor (\mathsf{invHoldForRule_3}~ f~ r~fs)$.
\end{enumerate}
\end{definition}
%\begin{specification}
%definition invHoldForRule1::
%formula $\Rightarrow$ state $\Rightarrow $ rule $\Rightarrow$ bool where\\
%invHoldForRule1 s f  r$\equiv$ %\\
%(  formEval (pre r) s $\longrightarrow$
%  formEval  (preCond f  (act r)) s ) \\ %\\

%definition invHoldForRule2:: state $\Rightarrow$ formula $\Rightarrow$ rule $\Rightarrow$ bool
% where \\

%invHoldForRule2 s f  r $\equiv$  (  formEval  (preCond f  (act r)) s  =  formEval f s\\
%\end{specification}

%\vspace{2mm}
% \begin{specification}
%definition   invHoldForRule3::
%state $\Rightarrow$ formula $\Rightarrow$ rule $\Rightarrow$formula set$\Rightarrow$ bool\\

% invHoldForRule3 s f r fs  $\equiv$\\
%  (let pref=preCond f (act r) in\\
%  ( $\exists$f'. f' $\in$ fs $\wedge$  (formEval   (andForm (pre r)  f') s$\longrightarrow$
% formEval  pref s)))\\
%\\
%abbreviation invHoldForRule::
%state $\Rightarrow$formula $\Rightarrow$ rule $\Rightarrow$ (formula set) $\Rightarrow$ bool
% where\\

%invHoldForRule s inv0 r invs $\equiv$\\
%    invHoldForRule1 s inv0 r $\vee$  invHoldForRule2 s inv0 r $\vee$
 %  invHoldForRule3 s inv0 r invs\\




%\%end{specification}

We can view the relation $\mathsf{invHoldForRule}(s, f,r,fs)$ in two ways. Firstly it defines some causality relation
between $f$, $r$, and $fs$.  $\mathsf{invHoldForRule}_1(s,f, r)$
  means that after rule $r$ is executed,
 $f$ will be true immediately;   $\mathsf{invHoldForRule}_2(s,f, r)$ specifies that
 $\mathsf{preCond}(S,f)$ is equivalent to $f$, intuitively this means that none of state variables in $f$ is
 changed, and the execution of statement $S$ does not affect the
 evaluation of $f$.
 $\mathsf{invHoldForRule}_3(s,f, r,fs)$ states
  that  there exists another invariant $f' \in fs$ such that
  the conjunction of the guard of $r$ and $f'$ implies the precondition  $\mathsf{preCond}(S,f)$.
Intuitively, $\mathsf{invHoldForRule}(s, f, r, fs)$ defines a causal
relation, which can guaranttee that if each of formula in $fs$ holds
before the execution of the rule $r$, then  $f$ also holds after the
execution of the rule $r$. Secondly the relation
$\mathsf{invHoldForRule}(s, f, r, fs)$ can also be regarded as a
special kind of inductive tactics, which can be applied to prove
each formula in $fs$ holds at each inductive protocol rule cases. The most important of all is that the three kind of inductive tactics can be done by a theorem prover, which is the cornerstone of our work.



A consistency relation $\mathsf{consistent}( invs,ini, rs)$,
 which holds between a protocol $(inis,rs)$ and
a set of invariants $invs=\{inv_1,\ldots, inv_n\}$,  is defined as
follows:
\begin{definition}
we define a relation $consistent::formula~ set \times formula~ set
\times rule ~set \Rightarrow bool$.
 $consistent( invs,ini, rs)$ holds if the following conditions hold:
\begin{enumerate}
\item for all formulas $inv\in invs$ and $ini\in inis$ and all states $s$,
$s \models ini$ implies $s \models inv$;
\item for all formulas $inv\in invs$ and rules  $r \in rs$ and all states $s$,  $\mathsf{invHoldForRule}(s, inv, r, invs   )$
\end{enumerate}
\end{definition}

%Intuitively, the above definition specifies that:
%\begin{itemize}
%\item For any invariant $inv \in invs$,
%initializing predicate $ini \in ini$, and state $s$, if $ini$ is
%evaluated true at state $s$, then $inv$ is also evaluated true at
%state $s$.

%\item For any invariant $inv \in invs$, $r$ in the rule set
%$rs$, either one of the following five types of relation holds,
%i.e., $\mathsf{invHoldForRule_{1-3}}inv r$.

%\end{itemize}

%For instance,

\begin{example}\label{example2}
Let us define a set of auxiliary invariants:

\begin{specification}
invOnXC(i)  $\equiv$ $\negc$(x $\doteq$ true $\andc$ n[i]$\doteq$ C)   \ \ \

invOnXE(i)   $\equiv \negc$ (x $\doteq$ true$\andc$ n[i] $\doteq$ E)  \\


aux$_1$(i,j)   $\equiv \negc$ ( n[i]$\doteq$ C$\andc$n[j] $\doteq$ E)   \ \ \

aux$_2$ (i,j) $\equiv \negc$  ( n[i]$\doteq$ E$\andc$n[j]$\doteq$ C)\\

  pinvs(N)$\equiv$ \{f. $\exists$ \iInv1 \iInv2. \iInv1 $\le$ N $\wedge$ \iInv2 $\le$ N $\wedge$ \iInv1 $\ne$ \iInv2 $\wedge$   f =mutualInv   \iInv1 \iInv2) \\
 $ \vee(\exists$ \iInv1. \iInv1 $\le$ N $\wedge$  f =invOnXC  \iInv1)   \\
$\vee(\exists$ \iInv1. \iInv1 $\le$ N $\wedge$  f= invOnXE \iInv1)    \\
$\vee(\exists$ \iInv1 \iInv2. \iInv1 $\le$ N $\wedge$ \iInv2 $\le$ N $\wedge$ \iInv1 $\ne$ \iInv2 $\wedge$ f =  aux1  \iInv1 \iInv2) \\
$\vee(\exists$ \iInv1 \iInv2. \iInv1 $\le$ N $\wedge$ \iInv2 $\le$ N $\wedge$ \iInv1 $\ne$ \iInv2 $\wedge$ f =  aux2  \iInv1 \iInv2) \}.

\end{specification}
\begin{itemize}
\item  $\mathsf{invHoldForRule_1 }(s,\mathsf{invOnXC}( 1),
\mathsf{crit}(1))$ because $\mathsf{preCond}(\mathsf{act}(\mathsf{crit}(1)),
 \mathsf{invOnXC} (1))=\negc (\mathsf{flase}\eqc\mathsf{true}\andc \mathsf{C}\eqc\mathsf{C})$ which is a tautology;

\item  $\mathsf{invHoldForRule_2 }(s,\mathsf{mutual}(
1,2), \mathsf{try}(3))$ because $\mathsf{preCond}(\mathsf{act}(\mathsf{try}(3)),
 \mathsf{mutual}( 1,2))=\mathsf{mutual} (1,2)$;

 \item   $\mathsf{invHoldForRule_3 }(s,\mathsf{mutual} (1,2), \mathsf{crit}(1),(\mathsf{pinvs} (N))$.
   because
 $\mathsf{invOnXC}( 2) \in \mathsf{pinvs} (N)$, $\mathsf{preCond}(\mathsf{act}(\mathsf{crit}(1)),
 \mathsf{mutual} (1,2))=\negc (\mathsf{C}\eqc\mathsf{C}\andc n[2]\eqc\mathsf{C})$,
 and $  s \models \mathsf{guard}(\mathsf{crit}(1)) \andc \mathsf{invOnXC}(2)$ implies
 $ s \models \negc (\mathsf{C}\eqc\mathsf{C}\andc n[2]\eqc\mathsf{C})$. Notice that  the guard condition of
 $\mathsf{crit}(1)$ is $n[1]\eqc T \andc x\eqc\mathsf{true}$.
 \end{itemize}
\end{example}



  %It is not diffcult to verify
%$\mathsf{consistent}~ (\mathsf{pinvs}~ N) ~(\mathsf{pini}~N)~
%(\mathsf{prules}~N)$ also holds.



 Suppose that the consistency relation
$\mathsf{consistent}( invs, inis, rs)$ holds, for any $inv \in invs$,
$inv$ holds for any reachable state $s$ such that $s  \in
\mathsf{reachableSet}( ini, rs)$. A so-called
consistency lemma formalizes the essence of the aforementioned causal relation.

\begin{lemma}\label{consistentLemma}%[(consistency lemma)]
 If $P=(ini,rs)$, $\mathsf{consistent}( invs, ini, rs)$, and $s  \in \mathsf{reachableSet}(P)$, %  $\isasymrbrakk\Longrightarrow$
 then   for all $inv$ s.t. $inv \in invs$, $s \models inv $.
\end{lemma}

%5Now we apply the consistence lemma to prove that the mutual exclusion property holds for each reachable state of the mutual-exclusion protocol. Let us recall example \ref{example1} and  \ref{example2}.
%\begin{lemma} \label{caseSimp}
%  If $ P=(pini(N),prules(N))$,  $s \in \mathsf{reachableSet}(P)$, and $0<N$,
 % then for all $inv$ s.t. $inv \in pinvs(N)$, $s\models inv $.

%\end{lemma}

%Here we must note that the proof cases are the key measure for
%the complexity of the parameterized verification.  Let alone a moderate
%protocol such as German and FLASH with about 15~50 cases.
%This complexity illustrates the difficulty of parameterized verification of
%cache coherence protocols. %A moderate case study such
%as German protocol has about 15 rules.
%If we only rely human intelligence to guide the theorem prover to
%prove them, the proof will be tedious and error-prone. This gives us the motivation
%to develop an automatic technique to generate the needed proofs., we need to
%analyze three  cases for each invariant $inv$ in
%$\mathsf{mutualInv}$, $\mathsf{mutualInv1}$, and
%$\mathsf{mutualInv2}$, and two cases for the others.
%in $\mathsf{invOnX1}$ and $\mathsf{invOnX2} $.
%Thus we need in total
%$4\times (3 \times 3 +2\times 2)=52$ cases. Note that the  protocol
%is simple because it has only 4 rules.
%Here we must note that the proof cases are the key measure for
%the complexity of the parameterized verification.  %Let alone a moderate
%protocol such as German and FLASH with about 15~50 cases.
%This complexity illustrates the difficulty of parameterized verification of
%cache coherence protocols. %A moderate case study such
%as German protocol has about 15 rules.
%If we only rely human intelligence to guide the theorem prover to
%prove them, the proof will be tedious and error-prone. This gives us the motivation
%to develop an automatic technique to generate the needed proofs.



\section{An overview of problem formulation and our framework for
parameterized verification}


In order to solve the  two central problems: finding auxiliary invariants and automatically generating proofs, we propose a general architecture of our parameterized
verification, which is illustrated in Fig.~\ref{fig:arch}. A small
cache coherence protocol instance {\tt protocol.fl}, is fed into the
\texttt{invFinder}. The task of tool \texttt{invFinder} is to find
all the necessary ground auxiliary invariants from the reference
protocol instance. This step solve the first  problem (1).
 A table {\tt protocol.tbl} is worked out  to store the set of ground invariants and
 causal relations, which will be  used by {\tt proofGen} to
create an Isabelle proof   script which models and verifies the
protocol in a parameterized form. In this step, ground invariants
will be generalized into a parameterized form, and accordingly
ground causal relations will be adopted to create parameterized
proof commands which essentially proves the existence of the
parameterized causal relations. This sloves the second problem.  At last the Isabelle proof script is
fed into   Isabelle to check the correctness of the protocol.





 \begin{figure}[!ht]\label{fig:arch}
% \centering %
 %\vspace{-2cm}
\includegraphics[width=1.0\textwidth]{paraVerifier.pdf}
%\vspace{-2cm}
 \caption{The general architecture of our parameterized
verification}

\end{figure}
 %\vspace{1cm}
%

%It is the task of {\sf paraVerifier} to construct each one of the
%remaining invariants by checking the causal relation between an
%invariant and a rule instance.


\section{  {\sf invFinder}}
%The core of  tool {\sf invFinder} works in a semi-proving and semi-searching
%way. It tries to prove some consistent
%relation exists between a concrete invariant and a concrete rule, and automatically
%generates a new auxiliary invariant if there is no such an invariant
%in the current invariant set, and records the corresponding causal
%relation information between the current rule and invariant. %This
%workflow is not finished until no new invariants is created.

\paragraph{The InvSearch Algorithm}
{\sf invFinder} works in a semi-proving and semi-searching
way. Given some protocol reference model as oracles, 
it tries to prove some consistent
relation exists between a concrete invariant and a parameterized rule. It need analyze the numbers of the actual parameters occurring in the invariant and the numbers of the formal parameters in the parameterized rule, automatically generates a list of actual parameters to instantiate the parameterized rule into a list of concrete rules. For such a concrete rule, and the concrete invariant, {\sf invFinder}
generates a new auxiliary invariant if there is no such an invariant
in the current invariant set, and records the corresponding causal
relation information between the current parameterized rule  and invariant in such a setting of a parameter instantiation to the rule. Comparing the parameter used to instantiate the parameterized rule  with the parameter occuring in the concrete invariant results in the key information needed in a typical case where  the parameterized proof is shown for the  consistency relation holding between the parameterized rule and invariant.


\paragraph{The Parameter Instantiation Policy}
%According to a parameter instantiation policy, main body of {\sf invFinder} generates a group of actual parameters to instantiate a parameterized rule $pr$ into a set of actual rules $R$, and call Algorithm \ref{alg:invfinderI} to compute new invariant and causal relation between each rule   $r\in rs$ and an invariant formula $inv$.
In order to formulate our parameter instantiation policy, we need introduce the concept of permutation modulo to symmetry relation $\sim_m^n$,  and a quotient set of $\mathsf{perms}_{m}^{n}$ (the set of all $n$-permutations of $m$) under the  relation.  Here a $n$-permutation of $m$ is ordered arrangement of a $n$--element subset of an $m$-element set $I=\{i. 0<i\le m\}$. We use a list with size $n$ to stand for a $n$-permutation of $m$, whose elemnts are mutually different from each other and taken from $I$. For instance, $[1,2]$ is a 2-permuatation of 3. If $xs_{[i]}=i$ for all $i \le |xs|$, we call it identical permutation. %, and sometimes is denoted by $1~ \mathsf{upto}~ n$ if $n=|xs|$.
\begin{definition}
Let $m$ and $n$ be two natural numbers, where $n \le m$,  $L$ and $L'$ are two lists which stand for two  $n$-permutations of $m$,
\begin{enumerate}
\item
$L \sim_m^n L' \equiv (|L| =|L'|=n) \wedge (\forall i. i<|L| \wedge L_{[i]} \le m-n \longrightarrow L_{[i]}=L'_{[i]}) $.

\item $L \simeq_m^n L' \equiv L \sim_m^n L' \wedge   L' \sim_m^n L$.

%\item$[[L]]_{m}^{n} \equiv \{L'. L \in \mathsf{perms}_{m}^{n} \wedge L \sim_m^n L'\}$.

\item $\mathsf{semiP}(m,n,S)\equiv (\forall  L \in \mathsf{perms}_{m}^{n} \exists  L' \in S. L \simeq_m^n L' ) \wedge (\forall  L\in S. \forall L'\in S. L \neq L' \longrightarrow \neg  (L \simeq_m^n L' )$.

\item    A set $S$ is called a quotient of the set $\mathsf{perms}_{m}^{n}$ under the relation $\simeq_m^n$ if and only if    $\mathsf{semiP}(m,n,S)$.
\end{enumerate}
\end{definition}








%\noindent {\bf Our Parameter Instantiation Policy:}
Let $cinv$  be a concrete invariant, which can be regarded as being obtained by  using an identical permutation; $pr$ be a parameterized rule, $\mathsf{aPNumOfInv}(cinv) $ be the number of actual parameters occurring in $cinv$, and $\mathsf{fpNumOfRule}(pr) $  be the number of formal parameters occurring in $pr$,  our policy is to compute the set  $\mathsf{cmpSemiperm}(\mathsf{aPNumOfInv}(cinv)+\mathsf{fpNumOfRule}(pr),\mathsf{fpNumOfRule}(pr) )$, and use elements of it as a group of parameters to instantiate $pr$ into a set $R$ of actual rules. Recall that a group of parameters to instantiate a parameterized rule represents a symbol case which can be generalized into groups of parameters to instantiate a parameterized rule and a parameterized invariant.  We are care of the completeness of our parameter instantiation policy. Namely, can any combination of parameters, which are used to instantiate the rule and invariant respectively, be reflected by a group of? First we need  define: %Here the underlying
%instantiation principle should guarantee that each typical proof
%case by comparing parameters occurring in a rule and an invariant in parameterized protocol instance,  should be covered by a sampling case in our
%parameter instantiation policy. That is to say, if we regard the finite
%instantiations as samplings, we must guarantee that
% the samples are enough to   be generalized in {\sf proofGen}
%to parameterized forms  to finish  parameterized proofs. Here we firstly explain the concept of ``typical proof
%case by comparing parameters occurring in a rule and an invariant".  Let $LR=[2]$, $LI=[1,2]$, we compare an element in $LR$ with another of $LI$, $LR_{[1]} = LI_{[2]}$ is a formula characterizing the comparation between the first element in $LR$ with the second element in $LI$.
\begin{definition}
let $LR \in \mathsf{perms}_N^{|LR|}$ and $LI \in \mathsf{perms}_N^{|LI|}$ are two permutations s.t. $0<|LR|\le N$ and $0<|LI|\le N$
\begin{enumerate}
\item $\mathsf{equality}(LR,LI,i,j) \equiv LR_{[i]} = LI_{[j]}$. Recall that $LR_{[i]}$ is the $i-$th element of $LR$.
\item $LR' \in \mathsf{perms}_{N'}^{\mathsf|LR|)}$ and $LI' \in \mathsf{perms}_{N'}^{|LI'|}$ are two permutations s.t. $0<|LR'|\le N$, $0<|LI'|\le N$, $|LR|=|LR'|$, and $|LI|=|LI'|$, $\mathsf{reflection}((LR,LI),(LR',LI')) \equiv \forall i \le |LR|. \forall j\le |LI|. (\mathsf{equality}(LR,LI,i,j) \longleftrightarrow \mathsf{equality}(LR',LI',i,j))$

\end{enumerate}
\end{definition}

$\mathsf{reflection}((LR,LI),(LR',LI'))$ means that each equality comparation between $LR_{[i]}$ and $LI_{[j]}$ is reflected by that between $LR'_{[i]}$ and $LI'_{[j]}$. Namely, if we do case analysis by comparing elements in $LR$ and in $LI$, the case pattern are the same with that by comparing those in $LR'$ and in $LI'$. Luckily, the following lemma gives a positive answer.


%Recall our parameter instantiation policy:  for a parameterized rule $pR$, a concrete  formula $cinv$, we use permutations in $paras=\mathsf{cmpSemiperm}(\mathsf{fpNumOfRule}(pr)+\mathsf{aPNumOfInv}(cinv),\mathsf{fpNumOfRule}(pr))$ to instantiate $pR$; and the concrete invariant $cinv$ is normalized, and the normalized one can be regarded as being obtained by  using an identical permutation $ID=1~\mathsf{upto}~\mathsf{aPNumOfInv}(cinv)$ to instantiate some parameterized formula $pinv$.  We are interested in the completeness of parameter instantiation policy:    let $LR$ and $LI$ are some actual parameters to instantiate $pR$ and $pInv$ respectively, the case analysis pattern between $LR$ and  $LI$ can be reflected by that between some $LR'$ and $ID$, where $LR' \in paras$.



%relation $LR_i=LI_j$  can be kept by a comparing  $LR'_i=ID_j$, where $LR'$ is a permutation in  $\mathsf{cmpSemiperm}(\mathsf{len}(LR)+\mathsf{len}(LI),\mathsf{len}(LR))$, $ID$ is identical permutation such that $ID_i=i$.
\begin{lemma}[completeness of parameter instantiation]\label{lemma:completeness}
let $LR \in \mathsf{perms}_N^{\mathsf{len}(LR)}$ and $LI \in \mathsf{perms}_N^{\mathsf{len}(LI)}$ are two permutations s.t. $|LR|>0$ and $|LI|)>0$ and $N=|LR| +|LI| $, let $ID$ be an identical permutation which has the same length with $LI$, there exists a permutation $LR' \in \mathsf{cmpSemiperm}(|LR|+|LI|,|LR|)$ s.t. $\mathsf{reflection}((LR,LI),(LR',ID))$.
\end{lemma}

Here we use two examples to explain this lemma. Let $LR=[2]$, $LI=[2,1]$, there exists $LR'=[1]\in \mathsf{cmpSemiperm}(3,1)$ s.t. $reflect((LR,LI),(LR',ID))$; let $LI=[5,6]$, there exists $LR'=[3]\in \mathsf{cmpSemiperm}(3,1)$ s.t. $\mathsf{reflect}((LR,LI),(LR',ID))$.

The core part of the {\sf invFinder} tool is shown in Algorithm \ref{alg:invfinderI}. It needs to call two oracles. The first one, denoted by {\tt chk}, checks whether a ground formula is an invariant in a given small reference model of the protocol. Such an oracle can be implemented by firstly translating the formula into a formula in SMV, and then calling SMV to check whether it is an invariant. The second oracle, denoted by
{\tt tautChk}, checks whether a formula is a tautology. Such a tautology checker is implemented by translating the formula into a form in the SMT (abbreviation for SAT Modulo Theories) format, and then calls an SMT solver such as Z3 to check it.

Besides the two oracles which are passed as parameters, there are also other parameters in the algorithm {\tt InvFinder}, including a rule instance $rule$, an invariant $inv$, a sets of invariants $invs$. The algorithm {\tt InvFinder} searches for new invariants and    constructs the causal relation between the rule instance $r$ and the invariant $inv$. The sets $invs$   stores the auxiliary invariants constructed up to now.
The returned result is a pair of formula option,    and causal relation item between $r$ and $inv$. A formula option value $NONE$ denotes that no new invariant is found; and $SOME(f)$ that a new auxiliary invariant $f$ is searched.



\begin{algorithm}\label{alg:invFinder-I}

\caption{Core Searching Algorithm-I: $InvFinderI$}\label{alg:invfinderI}

\KwIn{$chk$, $tautChk$, $rule$, $inv$, $invs$   }

\KwOut{A formula  option $f$, a new causal relation $rel$}

{
    $g\leftarrow $the guard of rule, $S\leftarrow $the statement of rule\;

    $inv'\leftarrow preCond(inv, S)$\; \label{line:preCondComp}

    \If{$inv=inv'$}
    {
    $relItem\leftarrow (rule, inv, invRule_2,-)$\;
    \Return $(NONE,  relItem )$\;
    }
    \ElseIf{$tautChk(g\rightarrow inv')=true$}
    {
    $relItem\leftarrow (rule, inv, invRule_1,-)$\;
    \Return $(NONE,  relItem )$\;
    }
    \Else
    {
    $candidates\leftarrow subsets(dualNeg(inv')\andc g)$\;
    $newInv\leftarrow choose(chk,candidates)$\;
    $relItem\leftarrow (rule, inv, invRule_3,newInv)$\;
    \If{$isNew(newInv,  invs)$}
    {
    $newInv \leftarrow  normalize(newInv)$\;%$ and insert it into the head of $newInvs$\;
    \Return $(SOME(newInv),   relItem )$\;
    }
    \Else{\Return $(NONE,  relItem )$\;}
    }
}

%}

\end{algorithm}


%{\sf invFinder} is implemented by FL, which is an excellent STE-tool
%  The above function {\sf findInvsFromRule} tries to find new
%invariants and construct the causal relation between the rule
%instance $rule$. %The statement {\tt
%cond => te|fe} is an abbreviation of the if-then-else expression
%that if $cond$ is true then $te$ else $fe$.
%Parameters $newInvs$, $invs$, and $casRel$ are new invariants, invariants, and all the
%causal relations constructed up to now, the above oracle functions
%are also passed as parameters.  % Causal relations  are still not
%checked between the ones in $newInvs$ and rules.
%

Now let us explain the body of $InvFinderI$. After computing the pre-condition $ inv'$ in line \ref{line:preCondComp}, which is the weakest precondition of the input formula $inv$ w.r.t. $S$, and takes further operations according to the cases it faces with:
{\sf invFinder-I} performs case analysis on $inv'$:

\begin{description}
\item[(1)]  if $ inv=inv'$,
 which means that statement $S$ does not change $inv$, then no new invariant is created, and  new causal
relation item marked with tag {\tt invHoldForRule$_2$} is recorded
between $rule$ and $inv$, but at this moment there are no new
invariants to be added; for instance, let $ rule=\mathsf{crit} (3)$,  $ inv=\mathsf{mutualInv}(1,2)$, thus
$inv'=\mathsf{preCond}(S,inv)=inv$, then a pair  $ (\mathsf{NONE}, ( crit(3), inv, \mathsf{invHoldForRule}_2,\_))$ will be returned, where $NONE$ means no new invariant formula is returned.

\item[(2)] Secondly, if $\mathsf{ tautChk}$ verifies that $g \dashrightarrow inv'$ is a tautology, then  no new invariant is created, and
the new causal relation item marked with tag
$ \mathsf{invHoldForRule}_1$ is recorded between $rule$ and $inv$. For instance, let $rule=\mathsf{crit}(2)$, $inv=\mathsf{invOnXC}(1)$,
 $inv'=\mathsf{preCond}(S,inv)=\neg(\mathsf{false }\eqc \mathsf{true} \andc n[1] \eqc \mathsf{C})$, obviously, $
g \dashrightarrow inv'$ holds forever because $inv'$ is always evaluated true,
 thus a pair $(\mathsf{NONE},  (\mathsf{crit}(2), inv, \mathsf{invHoldForRule}_1,\_))$ will be returned.


 \item[(3)] Thirdly, if neither of the above two cases holds, then a new auxiliary invariant $newInv$ will be constructed, which will make the causal relation $ \mathsf{invHoldForRule}_3$  to hold.


%The construction of the auxiliary invariant is introduced better after giving some definitions. A formula $f$ can be composed into a set of sub-formulas $f_i$, denoted as $decompose(f)$, such that each $f_i$ is not of a conjunction form and $f$   is semantically equivalent to $f_1 \andc f_2 \andc ... \andc f_N$.  $f_i$ usually is an atomic formula in our work after decomposition. For a formula $f$, we use $subsets(f)$ to denote the power set of $decompose(f)$, which contains all subsets of $decompose(f)$. $dualNeg(\negc f)$ returns $f$. The $\mathsf{ normalize}(f)$ function normalizes the numbering order of the use of parameters in the invariant $inv$.
%The result formula should be in  a normal form, whose parameters
%  always start from 1, and increase one by one if there are more
%  parameters. E.g.,  $\negc (x\eqc\mathsf{true} \andc n[1]\eqc\mathsf{C})$ is normalized, but
%  $\negc (x\eqc\mathsf{true} \andc n[2]\eqc\mathsf{C})$  not. The implementation of $\mathsf{ normalize}$ firstly compute a protype of $f'$,  which is obtained by substituting concrete parameters with different  e index variables $i_1$, ...$i_n$ in a pre-order traversal of the syntax of $f$, where $n$ is  the number of concrete parameters occurring in $f$ , then the returned result by $normalize$ is the formula which is obtained by substituting index variables $i_1$, ...$i_n$ with concrete indexes 1,...,$n$. Namely, we can see a normalized formula is obtained by substituting formal index variables with an identical permutation $1~ \mathsf{upto}~ n$.
A proper formula is chosen from the candidate set $subsets(dualNeg(inv')\andc g)$ to construct a new invariant $newInv$. This is accomplished by the {\tt choose} function, which calls the oracle {\tt chk} to verify whether a formula is an invariant in the given reference model. After $newInv$ is chosen, the function $isNew$ checks whether this invariant is new w.r.t. $newInvs$ or $invs$. If this is the case, the invariant will be normalized, and then be  added into $newInvs$, and the new causal relation item marked with tag {\tt invRule$_3$} will be added into the causal relations. Here, the meaning of the word ``new" is modulo to the symmetry relation. For instance,   $\mathsf{mutualInv}(1,2)$ is equivalent to
$\mathsf{mutualInv}(2,1)$ in a symmetry view.  Let $ invs=\emptyset$, $ rule=\mathsf{crit}(1)$, $ inv=\mathsf{mutualInv}(1,2)$,
$ inv'= \mathsf{preCond}(S,inv)=\negc(true\eqc true \andc n[2]\eqc C)$, from all the subsets of $\{n[1]\eqc T, x\eqc true, n[2]\eqc C\}$, the $ \mathsf{choose}$ oracle selects the subset $\{ x=true, n[2]\eqc C\}$ combines all the item in this candidate, then constructs a new invariant $inv_0= \negc(x\eqc true \andc
   n[2]\eqc C)$. After   normalization, the new invariant   $\negc(x=true \andc
   n[1]\eqc C)$  and  a  relation item $ (crit(1),   \mathsf{invHoldForRule}_3, inv_0)$ will be returned.


\end{description}


For instance, let $PR=\{try, crit, exit, idle\}$, $invs=\{mutualInv(1,2)\}$,    {\sf invFinder} is called to compute invariant formulas and causal relations.  The output of the {\sf invFinder}, which is stored in file {\tt mutual.tbl},  is shown in Table
\ref{table:groundCausalRelation}. In the table,  each line records the    index of a normalized   invariant, name of a parameterized rule, the rule
  parameters to instantiate the rule, a causal relation between
  the ground invariant and a kind of causal relation which involves the kind and proper formulas
  $f'$   in need (which are used to construct
      causal relations $\mathsf{invHoldForRule}_3$). The auxiliary invariants found by {\sf invFinder} includes: $\mathsf{inv_2}  \equiv  \negc (\mathsf{x} \eqc true  \andc  n[1]=C)$, $\mathsf{inv_3}    \equiv \negc  ( n[1]=C \andc n[2]=E)$,
$\mathsf{inv_4}  \equiv  \negc (x \eqc \mathsf{true}  \andc  n[1]\eqc \mathsf{E})$,   $\mathsf{inv_5}    \equiv \negc  ( n[1]\eqc \mathsf{C} \andc n[2] \eqc \mathsf{C})$.  \footnote{The names $\mathsf{mutualEx}$ and $\mathsf{invOnX1}$ in
  this work are just for easy-reading, their
 index here is generated  in some order by {\sf invFinder}}.



 \begin{table}[!t]\label{table:groundCausalRelation}
\centering \caption{A fragment of output of {\sf invFinder}} % {\tt
%simpMutual.tbl}
\begin{tabular}{|c|c|c|c|c|  }
\hline
  rule& ruleParas&inv&causal relation &   f'  \\
\hline
  .. & ..&.. &..&.. \\

\hline
  crit  & [1]&mutualInv(1,2)& invHoldForRule3 &invOnXC(2) \\
\hline
  crit &[2]& mutualInv(1,2)& invHoldForRule3 &invOnXC(1)  \\
\hline
  crit & [3]& mutualInv(1,2) & invHoldForRule2  & \\
\hline
  .. & ..&.. &..&.. \\

\hline
  crit  & [1]&invOnXC(1) & invHoldForRule1 &\_ \\
\hline
  crit &[2]& invOnXC(1) & invHoldForRule1 &\_  \\
\hline
\end{tabular}
\end{table}



\section{Generalization}
%From this section, our modelling language has been extended to HOL (Higher-order Logic) provided by Isabelle, which not only include the language in Section \ref{sec:protocolSyntax}, but also higher-order logic features. This is not surprising because our formal theory for a parameterized instance of a protocol is done in HOL/Isabelle.  In order to include the theory formally in section \ref{sec:protocolSyntax} and \ref{sec:causal_rel}, we define a Isabelle theory {\tt cache.thy}.

Intuitively, generalization means that a concrete index (formula or rule) is generalized into a set of concrete indice (formulas or rules), which can be formalized  by a symbolic index (formula or rules) with side conditions  specified by the constraint formulas. There are two
main kinds generalization in our work: (1) generalization on model constraints; (2) generalization to instantiation parameters for generation of case-splittings in the proofs, e.g., $iR_1 = \iInv_1$ or $iR_1 = \iInv_2$  stand for case splitting by comparing  a symbolic rule parameter $iR_1$ and invariant parameters $\iInv_1$ and $\iInv_2$. These formulas should be formalized in HOL.    In order to do this, we  adopt a symbolic value $\mathsf{symb}(str)$, where $str$ is   a special identifier. In this work, we use  special symbolic values $\mathtt{\iInv_i}$  to denote parameters of an parameterized   formula,  and $\mathtt{\iR_i}$ parameters of an parameterized rule, and $\mathtt{N}$   size of an parameterized protocol instance. Generalization in (1) is rather straightforward, and is put in the appendix; here we focus on (2).


\begin{definition}
Let $LR$ be a permutation s.t. $|LR|>0$, which represents a list of actual parameters to instantiate a rule,    let $LI$  be an identical permutation $|LI|>0$,  which  represents a list of actual parameters to instantiate a normalized invariant, we define:
\begin{enumerate}
\item symbolic equality  between $LR_i$ and $LI_j$: \\
\begin{numcases}{symbEq(LR,LI,i,j)\equiv }
 \mathtt{\iR_i} = \mathtt{\iInv_j} &    $equality(LR,LI,i,j)$\\
\mathtt{\iR_i} \ne \mathtt{\iInv_j} , & otherwise
\end{numcases}
%$symbEq(LR,LI,i,j)\equiv$ if $equality(LR,LI,i,j)$ then $\mathtt{\iR_i} = \mathtt{\iInv_j}$ else $ (\mathtt{\iR_i} \ne \mathtt{\iInv_j})$

\item symbolic case on a parameter $i$ between $LR_i$ and $LI$ :\\
\begin{numcases}{ symbcaseI(LR,LI,i)\equiv }
   symbEq(LR,LI,i,j)& $\exists! j.  equality(LR,LI,i,j)$\\
   forallForm(|LI|,pf)& otherwise
 \end{numcases}
 where  $pf(j)= symbEq(LR,LI,i,j)$, and $\exists!j.P$ is an qualifier meaning that  there exists a unique $j$ s.t. property $P$.

\item symbolic case  between $LR$ and $LI$ : $symbcaseI(LR,LI )\equiv forallForm(|LR|,pf)$, where $pf(i)= symbcaseI(LR,LI,i )$

\item symbolic partition decided by a $LRS$ and $LI$, where $LRS$ is a set of permutations with the same length: $partition(LRS,LI) \equiv existsForm(|LRS|,pf)$,  where $pf(i)= symbcase(LRS_i,LI)$

\end{enumerate}
\end{definition}

$symbEq(LR,LI,i,j)$ defines a symbolic formula according to the condition $equality(LR,LI,i,j)$, which represents the semantics of the equality between $LR_i$ and $LI_j$; $symbEq(LR,LI,i)$  a symbolic formula equality matching conditions between $LR_{[i]}$  and all $LI_{[j]}$ such that $j \le |LI|$; $symbcaseI(LR,LI )$ a subcase decided by all $LR_{[i]}$  and all $LI_{[j]}$; $partition(LRS,LI)$  is a disjunction of subcases $symbcase(LRS_{[i]},LI )$.  Recall the examples in the previous section:
\begin{itemize}
\item when   $LI=[1]$ is a list of parameters occuring in $invOnXC(1)$
\begin{itemize}
  \item $LR=[1]$ is the actual parameter list to instantiate $crit$, $symbEq(LR,LI,1,1)=(\mathtt{\iR_1} = \mathtt{\iInv_1})$, $symbcase(LR,LI)=symbcaseI(LR,LI,1)=(\mathtt{\iR_1} = \mathtt{\iInv_1})$.

  \item  $LR=[2]$ is the actual parameter list to instantiate $crit$, $symbEq(LR,LI,1,1)= (\mathtt{\iR_1} \ne \mathtt{\iInv_1})$, $symbcase(LR,LI)=symbcase(LR,LI,1)=(\mathtt{\iR_1} \ne \mathtt{\iInv_1})$

   \item let $LRS=[[1],[2]]$, $partition(LRS,LI)= (\mathtt{\iR_1} = \mathtt{\iInv_1}) \vee  (\mathtt{\iR_1} \ne \mathtt{\iInv_1})$
\end{itemize}
\item when   $LI=[1,2]$ is a list of parameters occuring in $mutualEx(1,2)$
\begin{itemize}

  \item $LR=[1]$ is the actual parameter list to instantiate $crit$, $symbEq(LR,LI,1,1)=(\mathtt{\iR_1} = \mathtt{\iInv_1})$, $symbcase(LR,LI,1)=(\mathtt{\iR_1} = \mathtt{\iInv_1})$.

  \item  $LR=[2]$ is the actual parameter list to instantiate $crit$, $symbEq(LR,LI,1,1)= (\mathtt{\iR_1} \ne \mathtt{\iInv_1})$, $symbcase(LR,LI)=(\mathtt{\iR_1} = \mathtt{\iInv_2})$ becasue $LR_{[1]}=LI_{[2]}$.


 \item  $LR=[3]$ is the actual parameter list to instantiate $crit$, $symbEq(LR,LI,1,1)=\neg(\mathtt{\iR_1} = \mathtt{\iInv_1})$, $symbcase(LR,LI)=symbcaseI(LR,LI,1)= (\mathtt{\iR_1} \ne \mathtt{\iInv_1}) \wedge  (\mathtt{\iR_1} \ne \mathtt{\iInv_2})$ because neither $LR_{[1]}=LI_{[1]}$ nor $LR_{[1]}=LI_{[2]}$.

  \item let $LRS=[[1],[2],[3]]$, $partition(LRS,LI)= (\mathtt{\iR_1} = \mathtt{\iInv_1}) \vee (\mathtt{\iR_1} = \mathtt{\iInv_2}) \vee ( (\mathtt{\iR_1} \ne \mathtt{\iInv_1}) \wedge  (\mathtt{\iR_1} \ne \mathtt{\iInv_2}))$
\end{itemize}
\end{itemize}

Note that $partition(LRS,LI)$ is a complete partition if it is a tautology. In the above example, the two partitions are both complete.

If we see a line as a concrete test case for some concrete causal relation in table \ref{table:groundCausalRelation},  then $symbcase(LR, ID)$ is an abstraction predicate to generalize the concrete case, where $LR$ and $ID$ are the concrete rule and invariant parameters in the line. %If another $LR'$ and $LI'$ are permutations s.t.  $symbcase(LR', LI')$, then the same kind of causal relation  should hold, thus we can apply the same proof tactics to prove.
The last thing is how to transform the formula $f'$ in a line of table \ref{table:groundCausalRelation} where the causal relation $\mathsf{invHoldForRule_3}$ holds. An index occuring in $f'$ can   occur in the invariant formula, or in the rule. We need look up the parameters occurring in the formula  or in the rule to determine the   transformation.

\begin{definition}
Let $LI$ and $LR$ are two permutations,\\
$lookup(LI,LR, i)\equiv$
 if $i\in LI$ then $\iInv_{find\_first(LI,i)}$ else $iR_{find\_first(LR,i) }$\\
$symbolize'(f,LI,LR)$ is a formula transformed from $f$ by substituting each $i$ with $lookup(LI,LR, i)$.
\end{definition}

For instance, let $LI=[1,2]$, $LR=[2]$, then $symbolize'(invOnXC(2),LI,LR)$ is $\neg(x\eqc true \wedge n[\iInv_2]\eqc C)$. %Let $LI=[1]$, $LR=[1,2]$, then $symbolize'(mutualInv(1,2),LI,LR)$ is $\neg(n[\iInv_1]\eqc C \wedge n[\iR_2]\eqc C)$. Here the latter exmple is only  artificial because there is no rule which will be instantiated by $[1,2]$. But for complex protocols like FLASH, the case exits where a rule with two parameters and an invariant with only a parameter exits.
For convenience in generating Isabelle proofs,      %a formula $\mathsf{diffConGen}~(\mathsf{paraMumsOfInv}~cr~"iR"$ to specify with the assumptions that mutual difference between the parameters of the symbolic invariant.  Here we assume that the string $"iR"$ does not occur in $cr$.
 A table $symbCausalTab$ is generated, which  stores causal relation between a parameterized rule and an  invariant w.r.t. a  size $N$. An entry of the table is referenced by concatation of the name of a rule and an invariant formula. Such an entry is a record containing fields {\tt symbCases} and  {\tt relationItems}, and created by collecting all the lines on the concrete relation items between the rule and the invariant. {\tt symbCases}  stores the list of symbolic cases each of which is derived by $\mathtt{symbcase}(LR, 1~\mathsf{upto}~n)$, where $LR$ is the rule parameters, and $n$ the number of parameters occuring in the invariant. relations store a list of generalized causal relation items.  For instance, for the rule $crit$ and $inv5$, a record $(|\mathtt{symbcases}=[\mathtt{\iR_1} = \mathtt{\iInv_1},\mathtt{\iR_1} = \mathtt{\iInv_2},(\mathtt{\iR_1} \ne \mathtt{\iInv_1}) \wedge  (\mathtt{\iR_1} \ne \mathtt{\iInv_2})]$; $\mathtt{relationItems}= [invHoldForRule_3(f_1')$,$invHoldForRule_3(f_2')$,$invHoldForRule_2]|)$, where $f_1'=symbolize'([1,2],[1],invONXC(2))$, and $f_2'=symbolize'([1,2],[2],invONXC(1))$.
%-------------------------------------------------------------------------
\section{Automatical generation of Isabelle proof by {\tt proofGen}}
%-------------------------------------------------------------------------
%\subsection{An  Example of Generated Isabelle/Script} \label{subsection:introOfIsabelleProof}
A formal model in a theorem prover like Isabelle
includes the definitions of constants and rules and invariants,
lemmas, and proofs. An overview of the hierachy  of the formal proof scripts of  is
shown in Fig \ref{fig:arch}.% \begin{figure}[!ht]\label{fig:isabelleProofIntro}
% \centering %
 %\vspace{-0.8cm}
%\includegraphics[width=1.0\textwidth]{isabelleScript.pdf}
%\vspace{-0.5cm}
% \caption{An overview of an Isabelle proof}

%\end{figure}

In detail, the proof script is divided into   parts as follows:
\begin{description}
\item[1] Definitions of formally parameterized invariant formulas, which are generalized from concrete invariants.   An actual N-parameterized invariant can be obtained by instantiating a formal invariant formula with symbolic indexes.

\item[2] Definitions of formally parameterized rules,  which can be directly transformed from the  Murphi rules of FLASH.

\item[3] Definitions of specification of the initial state, which can be directly transformed from the {\tt startstate} part of Murphi's code;

\item[4] A lemma  such as {\tt ruleName\_Vs\_invName} on a causal relation of a rule and a parameterized invariant, which is proved by a formal proof automatically generated by {\tt proofGen}. There are 20 such lemmas , which is the product of the numbers of rules and invariants.


\item[5]  A  Lemma  such as {\tt rules\_invName} on causal relations for  all rules and an invariant.%,  which is proved by a formal proof automatically generated by {\tt proofGen}.


\item[6] A lemma {\tt rules\_invs} on a causal relation for all rules and all invariants.%, which is proved by a formal proof automatically generated by {\tt proofGen}.

\item[7] A Lemma such as {\tt iniImply\_inv\_i} on a fact that an invariant  hold at the initial state defined by the specification of the initial state. %There are 161 such lemmas, each of which can be proved by an {\tt auto} command.

\item[8] A lemma {\tt on\_inits} proves that for all invariants they hold at the initial state of the protocol.

\item[9] Main theorem  proving that any invariant formula  holds at any reachable state of the  N-parameterized FLASH protocol instance.
\end{description}

%\subsubsection{Lemmas for Causal Relation between Rules and Invariants}
 % Now we discuss how to use records on {\tt crit} and {\tt inv$_1$} in the tables   $symbInvs$, $symbRules$, and $symbCausalTab$ to generate a lemma to prove that causal relation hold between   crit and   $inv_1$, which will be applied in the proof of main lemma.
 A lemma at the bottom level, specifies that causal relation hold between  a rule like  {\tt crit} and a parameterized rule like  $inv_1$, An  example lemma
{\tt critVsinv$_1$} and its proof in Isabelle in the {\tt mutualEx} protocol, is illustrated as follows:


\begin{specification}
%\begin{algorithm}
%\caption{Generating a kind of proof which is according with a relation tag of $invHoldForRule_{1-3}$ : rel2proof}\label{lemma:causal relation lemma}
1lemma critVsinv1:\\
2  assumes  a1: $\exists$ \iR1. \iR1 $\le$ N $\wedge$ r=crit \iR1 and \\
  a2: $\exists$  \iInv1 \iInv2. \iInv1 $\le$ N $\wedge$ \iInv2 $\le$ N $\wedge$ \iInv1 $\neq$ \iInv2 $\wedge$ f=inv1  \iInv1 \iInv2\\
3  shows  invHoldForRule s f r (invariants
  N)\\
4  proof -\\
   from a1 obtain \iR1 where a1:\iR1 $\le$ N $\wedge$ r=crit \iR1 \\
\twoSpaces   by blast\\
   from a2 obtain \iInv1 \iInv2 where \\
   a2: \iInv1 $\le$ N $\wedge$ \iInv2 $\le$ N $\wedge$ \iInv1 $\neq$ \iInv2 $\wedge$ f=inv1  \iInv1 \iInv2\\
\twoSpaces   by blast \\
5  have iR1=\iInv1 $\vee$ \iR1=\iInv2 $\vee$ (\iR1 $\ne$ \iInv1 $\wedge$  \iR1 $\ne$ \iInv2) by auto\\

6  moreover\{assume  b1:\iR1=\iInv1\\
7  \twoSpaces have invHoldForRule3 s f r (invariants N)\\
 \twoSpaces  \twoSpaces   proof(cut\_tac a1 a2 b1, simp, rule\_tac x=$\negc$ (x=true $\andc$ n[\iInv2]=C)  in exI,auto)qed\\
8  \twoSpaces then have invHoldForRule s f r
(invariants
  N)
by auto\}\\

9  moreover\{assume  b1:iR1=\iInv2\\
10 \twoSpaces have invHoldForRule3 s f r (invariants N)\\
 \twoSpaces \twoSpaces   proof(cut\_tac a1 a2 b1, simp, rule\_tac x=$\negc$ (x=true $\andc$ n[\iInv1]=C  in exI,auto)qed\\
11 \twoSpaces then have invHoldForRule s f r (invariants
  N)
by auto\}\\

12   moreover\{assume  b1:(\iR1 $\ne$  \iInv1 $\wedge$   \iR1 $\ne$  \iInv2)\\
13 \twoSpaces have invHoldForRule2 s f r  \\
  \twoSpaces \twoSpaces  proof(cut\_tac a1 a2 b1,  auto) qed\\
14 \twoSpaces then have invHoldForRule s f r
(invariants
  N)
by auto\} \\

15ultimately show invHoldForRule s f r
(invariants N) by blast\\
16qed\\
%\end{algorithm}
\end{specification}

A lemma such as {\tt critVsinv1}  is generated by collecting all the records on the invariant {\tt inv1} and rule {\tt crit} in the aforementioned tables.
Line 2 are assumptions on the parameters of the invariant and rule, which are composed of two parts: (1) assumption {\tt a1} specifies that there exists an actual parameter {\tt \iR1} with which {\tt r} is a rule obtained by instantiating {\tt crit}; (2) assumption {\tt a2} specifies that  there exists   actual parameters {\tt \iInv1} and {\tt \iInv2} with which {\tt f} is a formula obtained by instantiating {\tt inv1}.
 %(1) the facts that all parameters of this invariant should be less than the parameter $N$; %(2) the facts that all parameters of this invariant should be less than the parameter $N$; (3) the constraints of he mutual difference between parameters of the invariant (rule), which can %be looked up in the field of those records  from the table $symbInvTab$ ($symbRuleTab$) by the invariant (rule) name {\tt inv1} ({\tt crit}), which specifies that the mutual difference %between two parameters.
Line 4 are two typical  proof patterns forward-style which fixes local variables such as {\tt \iR1} and new facts such as {\tt a1: iR1 $\le$ N $\wedge$ r=crit \iR1}. From line 5, the remaining parts of the proof is a typically readable one in Isar style \cite{Wen99}, which uses calculation
reasoning such as {\tt moreover} and {\tt ultimately} to do  case analysis.
Line 5 splits cases of {\tt iR1} into all possible cases by comparing
{\tt \iR1} with {\tt \iInv1} and {\tt \iInv2}, which is in fact characterized by $partition([1],[2],[3]],[1,2])$. Lines 6-14  proves    these cases one by one: Lines 6-8 proves the case where {\tt iR1=\iInv1}, line 7 first proves that the causal relation $invHoldForRule_3$ holds by supplying a formula, which is $symbolize'(invOnXC(2),[1,2],[1])$. %Notes that $invOnXC(2)$ is the $f'$ which is provided in the last column of the line.
From the conclusion at line 7, line 8 futhermore proves the causal relation $invHoldForRule$ hold; Lines 9-11 proves the case where {\tt iR1=\iInv2}, proof of which is similar to that of case 1; Lines 12-14 the case   where neither {\tt iR1=\iInv1} nor {\tt iR1=\iInv2}. Each proof of a subcase is done in a block {\tt moreover b1:asm1 proof1}, the {\tt ultimately}  proof command in line 15 concludes by summing up all the subcases.



\subsection{Algorithms of Proof Generator {\sf proofGen}}

In this subsection, we illustrate the key techniques and algorithms of generation of the lemmas and their proofs in subsection \ref{subsection:introOfIsabelleProof}. Being according with the order in which we introduce the above lemmas, we also introduce their generation in a bottom-up order. First let us introduce the generation of a subproof according to a relation tag of $invHoldForRule_{1-3}$, which is shown in Algorithm \ref{alg:proofGenOfReltag}.

\begin{algorithm}
\caption{Generating a kind of proof which is according with a relation tag of $invHoldForRule_{1-3}$ : rel2proof}\label{alg:proofGenOfReltag}
\KwIn{A causal    relation item $relTag$}
\KwOut{  An Isablle proof: $proof$   }

{
 \If{$relTag=invHoldForRule_1$}
  {$proof \leftarrow $ sprintf\\
\twoSpaces"have invHoldForRule1 f r (invariants N)  \\
\twoSpaces         by(cut\_tac a1 a2 b1, simp, auto) \\
\twoSpaces then have invHoldForRule f r (invariants N)  by blast" \; }
 \ElseIf{ $relTag=invHoldForRule_2$}
  {$proof \leftarrow$  sprintf\\
\twoSpaces"have invHoldForRule2 f r (invariants N)
\twoSpaces         by(cut\_tac a1 a2 b1, simp, auto) \\
\twoSpaces then have invHoldForRule f r (invariants N)  by blast" \; }
 \Else{
 \label{label:getFormField}$f' \leftarrow getFormField(relTag)$\;
 $proof \leftarrow$ sprintf\\
\twoSpaces"have invHoldForRule3 f r (invariants N)  \\
\twoSpaces proof(cut\_tac a1 a2 b1, simp, rule\_tac x=\%s  in exI,auto)qed\\
\twoSpaces then have invHoldForRule f r (invariants N)  by blast" (symbf2Isabelle f')"\;}
\Return{proof}
}
\end{algorithm}

In the body of function {\sf rel2proof},  $sprintf$ writes a formatted data to string and returns it.
In line \ref{label:getFormField}, $getFormField(relTag)$ returns $f'$ if $relTag=invHoldForRule_3(f')$.  {\sf rel2proof} transforms a a relation tag into a paragraph of proof.% as shown in lines 7-8, 10-11, or 13-14.
If the tag is among $invHoldForRule_{1-2}$, the transformation is rather straight-forward, else the form $f'$ is assigned by the formula $getFormField(relTag)$, and provided to tell Isabelle the formula which should be used to construct the $invHoldForRule_3$ relation.

\begin{algorithm}
\caption{Generating one sub-proof for a subcase: oneMoreOverGen}\label{alg:MoreOver}

\KwIn{A formula $caseFsm$ standing for the assumption of the subcase, a relation item $relItem$ containing the information of causal relation }
\KwOut{  An Isablle proof: $subProof$ }
{
%$label \leftarrow labelGen(depth) $\;
$proof \leftarrow rel2proof(relItem)$\;
$  subProof \leftarrow$  sprintf\\
%\twoSpaces sprintf\\
\twoSpaces "moreover\{assume  b1:\%s  \\
           \%s    \} "\\
\twoSpaces ( asm, proof)\;
\Return{subproof}
}
\end{algorithm}

In Algorithm \ref{alg:MoreOver}, {\sf oneMoreOverGen} generates a subproof for a subcase in a proof of case analysis. It returns a subproof which is composed by filling an assumption of the subcase such as "\iR1=\iInv1" and a paragraph of proof generated by $rel2proof(relItem)$ into a format of block {\tt morover \{ ...\}}.  %the input $depth$ shows the  the depth of the current proof. Recalling that proof is recursively composed by subproofs. Each level of proofs are tagged with some depth. {\sf labelGen(depth)} returns a label such as $a1:$. {\sf oneMoreOverGen} generates a subproof which is

Due to the common use of case analysis proof of using {\sf moreover} and {\sf ultimately} commands, we design a generic program of generating  doing case analysis {\sf doCaseAnalz}. In algorithm \ref{alg:doCaseAnalz}, %generates a typical proof of doing case analyis.
 formulas standing for case-splitting $partition$, subproofs $subproofs$, and the conclusion $concluding$ are needed  in case analysis to fill the format.
\begin{algorithm}

\caption{Generating a whole proof of doing case analysis: doCaseAnalz}\label{alg:doCaseAnalz}
\KwIn{A formula $partition$ standing for case-splittings, a proof list $subproofs$ standing  all the subproofs of each subcases, concluding parts $concluding$}%, the depth of proof $depth$ }
\KwOut{  An Isablle proof: $proof$ }
{

%\If{$depth=1$}
%{$showOrHave \leftarrow$ "show"\;}
%\Else {$showOrHave \leftarrow$ "have"\;}
$proof \leftarrow $sprintf\\
\twoSpaces \twoSpaces  " have \%s  by auto\\
\twoSpaces \twoSpaces         \%s\\
\twoSpaces \twoSpaces        ultimately show \%s by auto"\\
\twoSpaces     (partition, subproofs,  concluding) \;
\Return{proof}
}
\end{algorithm}


In algorithm \ref{alg:doCaseAnalzI}, {\sf caseAnalzI} generates a typical proof of doing case analysis to  prove some causal relation hold between some rule and invariant. oneMoreOverGenI(case,rel) formula comes from the disjunction of formulas in the {\tt symbCases} field of $rec$, which is returned by $caseField(rec)$, subproofs $subproofs$ are generated by concatenation of all the subproofs, each of which is generated by $oneMoreOverGenI(case,rel)$. The proof is simply composed by  calling $doCaseAnalz(partition,subproofs,concluding)$.

\begin{algorithm}

\caption{Generating a whole proof of doing case analysis on parameters of rule and invariant: caseAnalzI}\label{alg:doCaseAnalzI}
\KwIn{A record $rec$ fetched from $symbCausal$ }
\KwOut{  An Isablle proof: $proof$ }
{
$cases \leftarrow caseField(rec)$\;
$rels \leftarrow relItems(rec)$;
$partition \leftarrow \bigvee cases$\;
$subproofs \leftarrow ""$\;
\While{$(cases \ne [])$}
{ $ case \leftarrow hd(cases)$ \;
  $cases \leftarrow tl(cases)$ \;
  $ rel \leftarrow hd(rels)$ \;
  $rels \leftarrow tl(rels)$ \;
  $subproofs \leftarrow subproofs \cat oneMoreOverGenI(case,rel)$\;
  }
$ concluding \leftarrow $"invHoldForRule s f r (invariants N) "\;
$proof \leftarrow doCaseAnalz(partition,subproofs,concluding)$\;
\Return $proof$
}
\end{algorithm}

Next we discuss how to generate assumptions on an invariant formula of an lemma such as $critVsInv1$. In the body of algorithm \ref{alg:asmGenOnInv}, $tbl\_element(symbInvs,  invName)$  retrieves the record on a invariant formula from $symbInvs$ to $invItem$ by its name $invName$, $invParaNum(invItem  )$ and $constrOfInv(invItem))$ return the field {\tt invNumFld} and {\tt constr} of  $invItem$ respectively. $invParasGen(lenPInv)$ generates a string of a list of actual parameters such as $iInv_1 ... iInv_{lenPInv}$ if $lenPInv>0$, else an empty string "".  At last, the assumption on the invariant is created by filling $invParas$,  $constrOnInv$, and $invName$ into a proper place in the format if needed.

\begin{algorithm}
  \caption{Generating an assumption on an invariant formula: asmGenOnInv}\label{alg:asmGenOnInv}
  \KwIn{An invariant name $invName$,    a table $symInvs$ storing invariant formulas   }

\KwOut{  An assumption on an invariant formula: $asm$   }

 $invItem   \leftarrow tbl\_element( symbInvs,  invName)$\;
  $lenPInv \leftarrow invParaNum(invItem  )$\;
  $invParas \leftarrow invParasGen(lenPInv)$\;
 % $constrOfInv \leftarrow constr(N,lenPInv)$\;
 $constrOnInv \leftarrow symbForm2Isabelle(constrOfInv(invItem))  $\;
 \If {lenPInv = 0}
  {$asm  \leftarrow  "a1: f="\cat invName   $\;}
  \Else{$asm  \leftarrow$ sprintf "a1: $\exists$ \%s. \%s $\wedge$ f=\%s \%s" (invParas,  constrOnInv, invName, invParas)\;}
  \Return{asm}
\end{algorithm}

Similar to {\sf asmGenOnInv}, {\sf obtainGenOnInv}, which is shown in algorithm \ref{alg:obtainGenOnInv}, generates a proof command of {\sf obtain} by retrieving and generating the related information and filling them in a format on {\sf obtain}.  Similar to {\sf asmGenOnInv} and  {\sf obtainGenOnInv}, {\sf asmGenOnRule} and  {\sf obtainGenOnRule} generate an  assumption and {\sf obtain} proof command   on a rule.

\begin{algorithm}
  \caption{Generating an {\sf obtain} proof command on an invariant formula: obtainGenOnInv}\label{alg:obtainGenOnInv}
  \KwIn{An invariant name $invName$,    a table $symInvs$ storing rules    }
  $invItem   \leftarrow tbl\_element( symbInvs,  invName)$\;
  $lenPInv \leftarrow invParaNum(invItem  )$\;
  $invParas \leftarrow invParasGen(lenPInv)$\;
\If {$  lenPInv = 0 $}
    {$obtain \leftarrow  ""$\;}
 \Else {$obtain \leftarrow$ sprintf "from a1 obtain  \%s where a1:\%s $\wedge$ f=\%s \%s by auto"\\
 \twoSpaces           $(invParas,  constrOnInv, invName, invParas)$\;}
 \Return{obtain}
\end{algorithm}



After the above preparing functions, now the generation of a lemma on the causal relation such as    $critVsInv1$ is rather easy, which is shown in algorithm \ref{alg:lemmaOnCausalRuleInv}. After generating an assumption on invariant formula $asm1$,  $asm2$ on a rule, an obtain command  $obtain1$ on the invariant, and  $obtain2$ on the rule,  $symRelItem$ is retrieved from $symCausalTab$ by $ruleName\cat invName$, and a proof $proof$ is generated by calling $caseAnalzI(symRelItem)$. At last these parts are filled into proper places in the lemma format.

\begin{algorithm}
\caption{Generating a lemma on a causal relation: lemmaOnCausalRuleInv}\label{alg:lemmaOnCausalRuleInv}

\KwIn{A parameterized rule name $ruleName$,   a formula name $invName$, a table $symRules$ storing rules , a table $symInvs$ storing invariant formulas,   a table $symCausalTab$  storing causal relation  }

\KwOut{  An Isablle proof script for a lemma: $lemmaWithProof$   }

{


 $asm1 \leftarrow asmGenOnInv(symbInvs,invName)$\;
 $asm2 \leftarrow asmGenOnRule(symbRules,ruleName)$\;
 $obtain1 \leftarrow obtainGenOnInv(symbInvs,invName)$\;
 $obtain2\leftarrow obtainGenOnRule(symbRules,ruleName)  $\;
  $symRelItem \leftarrow tbl\_element( symCausalTab,(ruleName\cat invName))$\;
 $proof \leftarrow caseAnalzI(symRelItem)$\;

$lemmaWithProof \leftarrow$ sprintf \\
\twoSpaces"lemma \%sVs\%s:\\
%2  assumes  a2: iR $\le$ N and a3: i1 $\le$ N and a4: i2 $\le$ N\\ generations assumptions
\twoSpaces assumes \%s and \%s\\
\twoSpaces  shows  invHoldForRule s f r (invariants   N)\\
\twoSpaces  proof -
\twoSpaces \%s~ \%s~  \%s

\twoSpaces qed"\\

\twoSpaces $(ruleName, invName, asm1,asm2, obtain1, obtain2, proof)$ \;
    \Return $lemmaWithProof$
}



\end{algorithm}


%=========================================
\section{Verification products}
%=========================================

After the auxiliary invariants are found,  the formula set $\mathsf{pinvs}~ N$ in Table \ref{Summarization of invariants} can be used to analyze
 and verify the design  of the protocol. In fact, they gives a complete
logical characterization of the semantics of the protocol. It  gives a deep insight of the protocol. These properties imply correspondence between
control signals or mutual exclusion between control signals. For instance, the intuitive meaning of the invariants is analyzed as follows:

\begin{table}[htbp] \label{Summarization of invariants}
\centering \caption{Summarization of invariants}
\begin{tabular}{|c|c| }
\hline
invariant &  meaning  \\
\hline
$\mathsf{invOnX_1} ~i$& Once some n[i] is set C, the flag x will be set false \\
\hline
$\mathsf{invOnX_2} ~i$&  Once some n[i] is set E, the flag x will be set false \\
\hline
$\mathsf{mutualInv}~ i ~j$ &  the mutual exclusion between n[i]=C and n[j]=C \\
\hline
$\mathsf{aux}_1~ i ~j$ &  the mutual exclusion between n[i]=C and n[j]=E \\
\hline
$\mathsf{aux}_2~ i ~j$ &  the mutual exclusion between n[i]=C and n[j]=E \\
\hline
\end{tabular}
\end{table}
%$\mathsf{invOnX_1} ~i$ specifies that the flag $x$ shows the
%availability of the critical section. Once some node state variable
%$n[i]$ is set $C$ or $E$, $x$ will be set $true$. Formulas
%$\mathsf{mutualInv}~ i ~j$, $\mathsf{aux_1} ~i~j$, and
%$\mathsf{aux_2} ~i~j$ state the mutual exclusion properties between
%a node's $\mathsf{C}(\mathsf{E})$ state and another different node's
%$\mathsf{C}(\mathsf{E})$ state.
The causal relations listed in Table \ref{} only illustrate why the invariants hold forever at each reachable state set.
That is to say, for a rule $r$ and an $inv$ descriibed in a line, one of the three causal relation $\mathsf{invHoldForRule}_{1\_3}$ holds, so an invariant holds after the execution the rule $r$. The Isabelle proof-script formally generalize these causal relation into parameterized form and proved the existence of the  causal relations. At last, a main lemma formally specifies that why the invariants hold forever at any reachable state set, and is formally proved by using the consistency lemma. In this sense, the Isabelle script can be seen as  a formal analysis document. The script contains 2243 line, and and costs more than 56
minutes for Isabelle to check in a 64-bit computing server platform which has a
160-multicore Intel Xeon CPU with 2.40GHz clock speed.


%=========================================
\section{Experiments} \label{sec:experiments}
%=========================================
We implement our tool in Forte \cite{Forte}. More experiments are
done including typical bus-snoopy ones such as MESI and MOESI,
 directory-based ones such as  Germanish, and  German protocols. The detail experiment codes and data can
be found in \JP{\cite{LiCache14}}. Each experiment data includes the
${\sf paraVerifier}$ instance, invariant sets found, Isabelle proof
scripts, and the simulation flow graph of one single node. A table
summarizes  our experiments below. Among the benchmarks, the German
protocol   was posted
 as
% Among the benchmarks, a case study is done
%on a directory-based protocol, German protocol, which was posted as
a challenge to the formal verification community by Steven German in
2000. German protocol is a moderate case.
To the best of our knowledge, few people but us give a complete proof to verify
the mutual exclusion  property of the German protocol
 in a theorem prover.  We also have successfully verified the important properties of the FLASH protocol, resulting into an independent and different proof from the literature. As Chou, Mannava, Park pointed out in \cite{}, FLASH is a good benchmark for any proposed method for parameterized verification: °∞if the method works on FLASH, then there is a good chance that it will also work on many real-world cache coherence protocols°±. Therefore, our approach has reached this most important landmark. From the line on the statistics on the FLASH, we can see the huge resource consumed by this case study. Such a big proof project is also a great challenge to a theorem prover like Isabelle. The total size of the proof scripts for FLASH verification is about 16M, which cann't be directly processed by Isabelle if we put all the proof scripts in a file. A file with 5000k is too large to be processed by Isabelle. Instead we have to divided   the proofs into small pieces, which are processed in some order. Therefore we work out a proof project control script in a {\tt ROOT} file to control the proof sessions. The proof consumptions of resources are according with the complexity of the problems. By the FLASH experiment, we demonstrate that ITP combined with automatic proof generation can handle industry-scale case like FLASH.


\begin{table}[!t] \label{Summarization of experiment results}
\centering
\caption{Verification results on benchmarks.}
\vspace{-2mm}
\begin{tabular}{|c|r|r|r|r|}
\hline
Protocols &  \#rules & \#invariants & time (seconds) & Memory (MB) \\
\hline\hline
MESI & 4& 3 & 0.68 & 11.5  \\
\hline
MOESI &  5& 3 &0.65 & 23.2  \\
\hline
Germanish~\cite{cubicle2011}  & 6&3&0.68 & 23.0   \\
\hline
German~\cite{Chou2004} & 13 & 24 & 4.09 & 26.7   \\
\hline
German with data~\cite{Chou2004} & 15 & 50 & 12.05 & 29.4   \\
\hline
FLASH~\cite{Park1996a,McMillan2001} & 73 & 112 & 1457.42 & 169.4   \\
\hline
\end{tabular}
\vspace{-5mm}
\end{table}

%=========================================
\section{Conclusion}
%=========================================
Within {\sf paraVerifier},
our automatic framework for parameterized verification of cache coherence protocol,
(1) instead of directly proving the invariants of a protocol by induction, we propose a general
proof method based on the consistency lemma to decompose the proof goal into a number of small ones;
(2) instead of proving the decomposed subgoals by hand,
we automatically generate proofs for them based on the information computed in a small protocol instance.\footnote{Technical details
of {\sf paraVerifier} will be made available in a technical report.}

As we demonstrate in this work, combining theorem proving with
automatic proof generation is promising in the field of formal
verification of industrial protocols. Theorem proving can guarantee the rigorousness of the verification results,
while automatic proof generation can release the burden of human interaction.


\bibliographystyle{splncsnat}
\bibliography{gste,cache,refer,bib-proanyIsabelle}


In this work we need some functions on lists, which will be used in later sections: $x\#xs$ for the list that extends $xs$ by adding $x$ to the
front of $xs$, $\left[ x_{1},..x_{n}\right] $ for a list
$x_{1}\#..x_{n}\#[]$, $xs@ys$ for the result list by concatenating
$xs$ with $ys$, $xs_{[i]}$ for the $i^{th}$ element of the list $xs$
(counting from 1 as the first element), $\mathsf{set}~xs$ for the
set of all the elements in $xs$, $|xs|$ for the length
of the list $xs$, $hd(xs)$ for the head element of a non-empty list, $tl(xs)$ for the tail of $xs$ but the head element. A list, whose elements are different from each other, is used as a group of actual parameters to instantiate a parameterized object. Such a list can also be seen as a permutation.


\begin{table}[h] \label{table-semantics-exp-formula}
\center\begin{tabular}{|l|l|}
  \hline
   Semantics \\ \hline
  $\mathbb{A}[v,s]\equiv s(v)$, where  $v$ is a variable\\
    $\mathbb{A}[c,s]\equiv c$, where  $c$ is a constant\\
   $\mathbb{A}[f?e_1:e_2,s]\equiv$if ($\mathbb{B}[f,s]$) then $\mathbb{A}[e_1,s]$ else $\mathbb{A}[e_2,s]$ \\
  $\mathbb{B}[ e_1\doteq e_2,s]\equiv   \mathbb{A}[e_1,s]=\mathbb{A}[e_2,s]$  \\
  $\mathbb{B}[\negc f,s]\equiv \neg \mathbb{B}[f,s]$ \\
  $\mathbb{B}[f_1\andc f_2,s]\equiv \mathbb{B}[f_1,s] \land \mathbb{B}[f_1,s]$ \\
  $\mathbb{B}[f_1\orc f_2,s]\equiv \mathbb{B}[f_1,s] \vee \mathbb{B}[f_2,s]$ \\
 $\mathbb{B}[f_1\dashrightarrow f_2,s]\equiv \mathbb{B}[f_1,s]$  implies $\mathbb{B}[f_2,s]$ \\
 %  $\mathbb{B}[f_1\longleftrightarrow f_2,s]\equiv \mathbb{B}[f_1,s]$  if and only if $\mathbb{B}[f_2,s]$ \\
  \hline
\end{tabular}
\end{table}

%The main body of {\sf paraVerifier}'s algorithm iteratively calls
%the function {\sf findInvsFromRule}  by instantiating each
%parameterized rule with different actual parameters of the finite
%reference protocol model. This procedure is finished until no more
%5new invariants can be created.
There are three key technique points in our invariant candidate choosing policy. Recalling that our candidate choosing problem can be formulated as follows: Among a set $S$ of invariant formulas, we need choose a set $S_1$ of formulas from $S$ such that $S_1$ is the minimal set that satifies $\neg \bigwedge S_1$ is an invariant. Meanwhile, for any formula set $S_2$ such that $|S_2|<|S_1|$,  $\neg \bigwedge S_2$ is not an invariant.
\begin{itemize}
\item An oracle {\tt chk  } will check whether a formula $\neg \bigwedge S_1$ is an invariant. In our implementation, the oracle firstly tries to use a reachable set of a simplified reference protocol instance with a small size   to check the validity of the formula if each variable of $\neg \bigwedge S_1$ exists in this small instance; otherwise, the oracle uses MURPHI or  BMC feature of NUSMV to rule out the non-invariant formulas within another reference protocol instance where all the variables of $\neg \bigwedge S_1$ exists, and regard the formula as an invariant if MURPHI or  BMC procedure time-outs. For verification of a complex protocol, the combination of the two choosing strategies are important because we cann't solely enumerate a complete reachable set of a reference protocol instance even with a small size where all the variables of $\neg \bigwedge S_1$ exists. For FLASH with data paths, it is not feasible to enumerate a complete reachable set of a reference protocol instance with size $3$  to check the validity of the  candidate; however we can use the  reachable set of a reference instance of simplified FLASH protocol without data paths with size $3$ to conjecture control properties, and use the second strategy from a full FLASH protocol with data with size $3$ to guess the properties on data properties or control properties involving a parameter which is greater than 3.

\item Choosing policy are done in an augmenting way. Firstly, we initialize $size=1$ choose a set $S$ with $|S_1|=size$, if {\tt chk $S_1$}, then stops; otherwise increases $size$; this process repeats until $S=S_1$ or  {\tt chk $S_1$}.

\item Some heuristics choosing policy can be done which are basing on some experience in this field. For instance, if the pre-condition {\tt inv'} contains only a parameterized variable $a[i]$, and $f$ is an atomic formula in $S$ in which another variable $a'[i]$ occurs, then $f$ in $S$ will be chosen with some priority w  because both $a[i]$ and $a'[i]$ are on the parameter $i$; if   such a formula $f$ still is not the candidate,  another formula $g$ in $S$ which contains a global variable $v'$ will be chosen. $\{ f,g \}$ usually is the desired set $S_1$. Namely, $!(f \andc g)$ will usually be the new invariant in much probability.
\end{itemize}

For instance, let $m=5$, $n=2$, $[1,2]\not\sim_5^2[2,1]$, $[1,3]\not \sim_5^2[1,4]$ and  $[5,4]\sim_5^2 [4,5]$. It is easy to see that, $[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2],[3,4]]$ is a quotient set of $\mathsf{perms}_{m}^{n}$ under $\sim_5^2$.

If $m>0$,   $\mathsf{perms}_{m}^{1}$ is the quotient set of itself under $\sim_m^1$.

Algorithm \ref{alg:computeSemiPerms} computes a quotient of $\mathsf{perms}_{m}^{n}$. Lines Firstly it deals with the special case when $m=0$ or $n=0$; otherwise, we set $S_0=\mathsf{perms}_m^n$ and $S= \emptyset $ respectively, then we fetch the head element of $S_0$ into $L$, and find whether there is an element $L'$ in $S$ s.t. $L\sim_m^n L'$. If  yes, then $L$ will be discarded, else $L$ is inserted into $S$. This procedure is repeated until $S$ is empty.
\begin{algorithm}\label{alg:computeSemiPerms}

\caption{Computing quotient of $\mathsf{perms}_{m}^{n}$: $cmpSemiperm$}%\label{alg:invfinderII}

\KwIn{$m$, $n$     }

\KwOut{A permutation set $S$}

{%\label{specialcaseStart}


    %$inv'\leftarrow preCond(inv, S)$\;

  \If{$m=0 \vee n=0$  }
    {
    $S\leftarrow \emptyset $\;
   \Return $S$\;
    }
%\label{specialcaseEnd}
  \Else
    {
    $S_0\leftarrow \mathsf{perms}_m^n$\;
     $S\leftarrow \emptyset $\;
     \While{$S_0 \neq \emptyset$}
      {$L \leftarrow \mathsf{hd}(S_0)$\;
       $S_0 \leftarrow \mathsf{tl}(S_0)$\;
       \If{$\mathsf{find}(\sim_m^n(L), S)=NONE$}
        { $S\leftarrow S@[L]$\;}
      }
    \Return $S$\;
    }
}

%}

\end{algorithm}


\subsection{The Top-level Algorithm}
Now we discuss the top level of {\sf invFinder}. First we show how to search
new invariants and causal relations between  a parameterized  rule   $pr$ and an invariant formula. The algorithm of parameter instantiation to the $pr$ and calling {\sf invFinderI} to search  auxiliary invariants are listed in \ref{alg:invFinder-II}:

\begin{algorithm}\label{alg:invFinder-II}

\caption{parameter instantiations: invFinderII }\label{alg:parameterInstantiate}

\KwIn{parameterized rule $pr$,  a concrete invariant $cinv$, two formula set $invs$ and $newInvs$, a relation set $rel$ }

\KwOut{  two formula set $invs'$ and $newInvs'$, a relation set $rel'$ }

{  $ni\leftarrow \mathsf{aPNumOfInv}(cinv) $\;
   $nr \leftarrow \mathsf{fpNumOfRule}(pr)$\;

   $S \leftarrow \mathsf{cmpSemiperm}(ni+nr,nr)$\;
   $invs' \leftarrow invs$\;
   $newInvs' \leftarrow newInvs$\;
   $rel' \leftarrow rel$\;
     \While{$S  \neq \emptyset$}
     {
       $L \leftarrow \mathsf{hd}(S )$\;
        $S  \leftarrow \mathsf{tl}(S )$\;
        $r \leftarrow \mathsf{apply}(pr,L)$\;
        $(invOpt,relItem) \leftarrow  \mathsf{InvFinderI}(chk,tauto,r,cinv,invs')$\;
      $rel' \leftarrow rel'@[relItem]$\;
       \If{$invOpt \neq NONE$}
        {$newInv \leftarrow \mathsf{getReal}(invOpt) $\;
        $invs' \leftarrow invs'@[newInv]$\;
         $newInvs' \leftarrow newInvs'@[newInv]$\;
        }
     }
    \Return $invs', newInvs'$  and  $rel'$
}



\end{algorithm}

Input formula set $invs$ and $newInvs$, a relation set $rel$ are the invariant formula set, and new invariant formula set and causal relation computed up to now. The meaning of ``new" is that a formula in $newInvs$ has not been used to search new invariants yet. The generated groups of parameters are stored in $S$, and are repeatedly  used to instantiate $pr$ into a rule $r$, and to search new invariants and causal relation items by calling $\mathsf{InvFinderI}$.  The searched new invariant formulas are added into $invs'$ and $newInvs'$; new rlation item $relItem$ into items $rel'$.

For a parameterized rule set $PR$ of a protocol, and a set of invariant set $invs$ under verification, top level algorithm of {\sf invFinder} works as shown in algorithm \ref{alg:topInvFinder}: $invs'$ and $newInvs'$ are initialized by $invs$, and $rel'$ by $\emptyset$. There are two level of loops in the top level of {\sf invFinder}. Head element of $newInvs'$ is pushed into a new invariant $cinv$, and head of $PR$ into $pr'$, then $\mathsf{InvFinderII}$ is iteratively called to compute new invariant formulas and relation items. This searching procedure is not finished until no new invariant is searched.

\begin{algorithm}\label{alg:topInvFinder}

\caption{top level algorithm of invFinder: invFinder}

\KwIn{parameterized rule set $PR$,   a formula set $invs$  }

\KwOut{  a formula set $invs'$, a relation set $rel'$ }

{ % $ni\leftarrow \mathsf{aPNumOfInv}(cinv) $\;
  % $nr \leftarrow \mathsf{fpNumOfRule}(pr)$\;

  % $S \leftarrow \mathsf{cmpSemiperm}(ni+nr,nr)$\;
    $invs' \leftarrow invs$\;
    $newInvs' \leftarrow invs$\;
    $rel' \leftarrow \emptyset$\;
     \While{$newInvs'  \neq \emptyset$}
     { $cinv \leftarrow hd(newInvs')$\;
       $newInvs' \leftarrow tl(newInvs')$\;
       $PR' \leftarrow PR$\;
       \While{$PR'  \neq \emptyset$}
       {
        $pr\leftarrow \mathsf{hd}(PR' )$\;
        $PR'  \leftarrow \mathsf{tl}(PR' )$\;
        $(invs',newinvs',rel') \leftarrow  \mathsf{InvFinderII}$($pr$,    $cinv$,   $invs'$, $newInvs'$,$rel')$\;
       }

     }
    \Return $invs'$  and  $rel'$
}



\end{algorithm}

Recall the examples in the previous section:
\begin{itemize}
\item when   $LI=[1]$ is a list of parameters occuring in $invOnXC(1)$
\begin{itemize}
  \item $LR=[1]$ is the actual parameter list to instantiate $crit$, $symbEq(LR,LI,1,1)=(\mathtt{\iR_1} = \mathtt{\iInv_1})$, $symbcase(LR,LI)=symbcaseI(LR,LI,1)=(\mathtt{\iR_1} = \mathtt{\iInv_1})$.

  \item  $LR=[2]$ is the actual parameter list to instantiate $crit$, $symbEq(LR,LI,1,1)= (\mathtt{\iR_1} \ne \mathtt{\iInv_1})$, $symbcase(LR,LI)=symbcase(LR,LI,1)=(\mathtt{\iR_1} \ne \mathtt{\iInv_1})$

   \item let $LRS=[[1],[2]]$, $partition(LRS,LI)= (\mathtt{\iR_1} = \mathtt{\iInv_1}) \vee  (\mathtt{\iR_1} \ne \mathtt{\iInv_1})$
\end{itemize}
\item when   $LI=[1,2]$ is a list of parameters occuring in $mutualEx(1,2)$
\begin{itemize}

  \item $LR=[1]$ is the actual parameter list to instantiate $crit$, $symbEq(LR,LI,1,1)=(\mathtt{\iR_1} = \mathtt{\iInv_1})$, $symbcase(LR,LI,1)=(\mathtt{\iR_1} = \mathtt{\iInv_1})$.

  \item  $LR=[2]$ is the actual parameter list to instantiate $crit$, $symbEq(LR,LI,1,1)= (\mathtt{\iR_1} \ne \mathtt{\iInv_1})$, $symbcase(LR,LI)=(\mathtt{\iR_1} = \mathtt{\iInv_2})$ becasue $LR_{[1]}=LI_{[2]}$.


 \item  $LR=[3]$ is the actual parameter list to instantiate $crit$, $symbEq(LR,LI,1,1)=\neg(\mathtt{\iR_1} = \mathtt{\iInv_1})$, $symbcase(LR,LI)=symbcaseI(LR,LI,1)= (\mathtt{\iR_1} \ne \mathtt{\iInv_1}) \wedge  (\mathtt{\iR_1} \ne \mathtt{\iInv_2})$ because neither $LR_{[1]}=LI_{[1]}$ nor $LR_{[1]}=LI_{[2]}$.

  \item let $LRS=[[1],[2],[3]]$, $partition(LRS,LI)= (\mathtt{\iR_1} = \mathtt{\iInv_1}) \vee (\mathtt{\iR_1} = \mathtt{\iInv_2}) \vee ( (\mathtt{\iR_1} \ne \mathtt{\iInv_1}) \wedge  (\mathtt{\iR_1} \ne \mathtt{\iInv_2}))$
\end{itemize}
\end{itemize}


With the help of all the lemmas such as {\sf ruleVsinv1},  we can prove the following lemma  {\sf lemma$\_$inv$\_$1$\_$on$\_$rules} which
specifies that for all $r \in rules ~N$, and $f$ is a formula $f$ which is generated by instantiating inv1 with some parameters $\iInv_1$ and $iInv_2$, $invHoldForRule ~s~ f~ r~ (invariants~ N)$.

\begin{specification}
lemma lemma$\_$inv1$\_$on$\_$rules:
  $\isasymlbrakk$ a1:
r $\in$ rules N
 and a2:
($\exists$ $\_$iInv1 $\_$iInv2. $\_$iInv1$\le$
N$\wedge$$\_$iInv2$\le$\\
N$\wedge$\iInv1~=\iInv2$\wedge$f=inv1  \iInv1 \iInv2)\\

  $\isasymrbrakk\Longrightarrow$
invHoldForRule s f r (invariants N)\\

  proof -\\
\twoSpaces  have
($\exists$ i. i$\le$
N$\wedge$r=try  i)$\vee$
    ($\exists$ i. i$\le$\\
N$\wedge$r=crit  i)$\vee$
    ($\exists$ i. i$\le$
N$\wedge$r=exit  i)$\vee$\\
    ($\exists$ i. i$\le$
N$\wedge$r=idle  i)\\

  apply (cut$\_$tac a1, auto) done\\
    moreover $\{$      assume b1:
($\exists$ i. i$\le$
N$\wedge$r=try  i)\\

\twoSpaces      have invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis tryVsinv1) done
    $\}$\\


    moreover $\{$ assume a1:
($\exists$ i. i$\le$
N$\wedge$r=crit  i)\\

\twoSpaces      have
invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis critVsinv1) done
    $\}$\\


    moreover $\{$
      assume a1:
($\exists$ i. i$\le$
N$\wedge$r=exit  i)\\

\twoSpaces      have
invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis exitVsinv1) done
    $\}$\\


    moreover $\{$ assume a1:
($\exists$ i. i$\le$
N$\wedge$r=idle  i)\\

\twoSpaces      have
invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis idleVsinv1) done
    $\}$\\


  ultimately show invHoldForRule' s f r (invariants N)\\
  by auto\\
qed\\

\end{specification}

With the help of all the lemmas such as {\sf lemma$\_$inv$_i\_$on$\_$rules},  we can prove the following lemma  {\sf invs$\_$on$\_$rules} which
specifies that for all $f \in invariants~ N$ and $r \in rules~ N$,   $invHoldForRule ~s~ f~ r~ (invariants~ N)$.

\begin{specification}
lemma invs$\_$on$\_$rules:
  $\isasymlbrakk$ a1:
f $\in$ invariants N
 and a2:
r $\in$ rules N
  $\isasymrbrakk\Longrightarrow$\\
invHoldForRule' s f r (invariants N)\\

  proof -\\
  have b1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1~=\iInv2$\wedge$f=inv1  \iInv1 \iInv2)$\vee$\\
    ($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv2  \iInv2)$\vee$\\
    ($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1~=\iInv2$\wedge$f=inv3  \iInv1 \iInv2)$\vee$\\
    ($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv4  \iInv2)$\vee$\\
    ($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1~=\iInv2$\wedge$f=inv5  \iInv1 \iInv2)\\

  apply (cut$\_$tac a1, auto) done\\
    moreover $\{$      assume b1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1~=\iInv2$\wedge$f=inv1  \iInv1 \iInv2)\\

\twoSpaces       have
invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis lemma$\_$inv1$\_$on$\_$rules) done
    $\}$\\


    moreover $\{$ assume b1:
($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv2  \iInv2)\\

\twoSpaces       have invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis lemma$\_$inv2$\_$on$\_$rules) done
    $\}$\\


    moreover $\{$      assume b1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1~=\iInv2$\wedge$f=inv3  \iInv1 \iInv2)\\

\twoSpaces       have
invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis lemma$\_$inv3$\_$on$\_$rules) done
    $\}$\\


    moreover $\{$      assume b1:
($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv4  \iInv2)\\

\twoSpaces       have
invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis lemma$\_$inv4$\_$on$\_$rules) done
    $\}$\\


    moreover $\{$
      assume b1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1~=\iInv2$\wedge$f=inv5  \iInv1 \iInv2)\\

\twoSpaces       have
invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis lemma$\_$inv5$\_$on$\_$rules) done
    $\}$\\


  ultimately show
invHoldForRule' s f r (invariants N)\\

\twoSpaces  apply fastforce done\\
qed
end\\
\end{specification}



 % {\tt allSymbRecs } are all symbolic causal relation records on {\tt  invName} and {\tt  ruleName},
% then  {\tt lenPInv} and {\tt lenPRule} which are numbers of the parameters of the invariant formula and rule, then {\tt asms} which are the assumptions part of the lemma such as line 2, {\tt allDisjuncts} the case analysis between the parameters of invariant and rule such as line 5, {\tt allSubProofs} all the proofs of the subcases such as lines 6-14, then fill all these into the blanks of the templates to generate the lemma.


% {\tt namedAsmTrans asm i} adds a name "ai:" to a string of assumption in order to construct a named assumption. {\tt allNamedAsmsGen} generates all the aformentioned  four kinds of assumptions of the lemma in the previous paragrapgh: {\tt asmsLessOnInv} is according with (1) types of assumptions; {\tt asmsLessOnRule} (2) types of assumptions;  {\tt asmsMutualDiffOnInv} (3) types of assumptions; and {\tt asmsMutualDiffOnRule} (4) types of assumptions. After naming any one assumption with a name, {\tt allNamedAsmsGen} returns all the named assumptions which are conned by {\tt and} operator. {\tt symbCausalRec2Proof symbRec} generates a kind of proof in Isabelle according to a symbolic casual relation record {\tt symbRec}: if the tag of {\tt holdTag} is 1(2,3), then kind 1 (2,3) proof are generated accordingly. Here we list the most complex one: {\tt proof3Gen ruleName invName f}, which generates a proof which is according with {\tt invHoldType3} such as lines 6-8, and {\tt f} is another invariant formula which is needed to construct the {\tt invHoldType3} causal relation.
%\twoSpaces  let asmsLessOnRule=asmsGen iRule sN lenPRule in \\
%\twoSpaces  let asmsMutualDiffOnInv=asmsLookUp symbInvs invName gFldName in\\
%\twoSpaces  let asmsMutualDiffOnRule
\subsubsection{Definitions and lemmas on initial states}

In this section, we discuss the definition on the initial state of the protocol, and the lemmas specifying that each invariant formula holds at the initial state.

A typical Isabelle definition on the initial state of the protocol is as follows:

\begin{specification}
definition initSpec0::nat $\Rightarrow$ formula where [simp]:\\
initSpec0 N $\equiv$ (forallForm (down N) (\% i . (eqn (IVar (Para (Ident ''n'') i)) (Const I))))\\

definition initSpec1::formula where [simp]:\\
initSpec1  $\equiv$ (eqn (IVar (Ident ''x'')) (Const true))\\

definition allInitSpecs::nat \<Rightarrow> formula list where [simp]:\\
allInitSpecs N $\equiv$ [(initSpec0 N),(initSpec1 )]\\

lemma iniImply\_inv4:
assumes a1: ($\exists$\iInv1. \iInv1$\le$N$\wedge$f=inv4 \iInv1)\\
and a2: formEval (andList (allInitSpecs N)) s\\
shows formEval f s\\
 using a1 a2 by auto\\
\end{specification}

{\tt initSpec0} and {\tt initSpec1} specifies the assignments on each variable {\tt n[i]} where {\tt i $\le$ N} and {\tt x}. The  specifications of the initial state is the list of all the specification definition on related state variables. Lemma {\tt iniImply\_inv4} simply specifies that the invariant formula {\tt inv4} holds at a state {\tt s} which satisfies the conjunction of the   specification of the initial state. Isabelle's {\tt auto} method can solve this goal automatically. Other lemmas specifying that other invariant formulas hold at the initial state are similar.
%The generation of the above code is straightforward: definitions of the specification of initial state variables in Isabelle is a direct syntax transformation from the internal represetation of tool {\tt proofGen} to Isabelle.

With the lemmas such as {\tt iniImply\_inv4}, for any invariant $inv \in (\mathsf{invariants} ~N) $,  any
state $s$, if $ini$ is evaluated true at state $s$, then $inv$ is
evaluated true at state $s$.

\begin{specification}
lemma on$\_$inis:
  $\isasymlbrakk$ a1:
f $\in$ (invariants N)
 and a2:
ini $\in$ $\{$
andList (allInitSpecs N)$\}$\\

 and a3:
formEval ini s

  $\isasymrbrakk\Longrightarrow$
formEval f s\\

  proof -\\
  have c1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1~=\iInv2$\wedge$f=inv$\_$$\_$1  \iInv1 \iInv2)$\vee$\\
    ($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv$\_$$\_$2  \iInv2)$\vee$\\
    ($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1~=\iInv2$\wedge$f=inv$\_$$\_$3  \iInv1 \iInv2)$\vee$\\
    ($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv$\_$$\_$4  \iInv2)$\vee$\\
    ($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1~=\iInv2$\wedge$f=inv$\_$$\_$5  \iInv1 \iInv2)\\

\twoSpaces  apply (cut$\_$tac a1, simp) done\\
    moreover $\{$
      assume b1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1~=\iInv2$\wedge$f=inv$\_$$\_$1  \iInv1 \iInv2)\\

      have
formEval f s\\

\twoSpaces      apply (rule iniImply$\_$inv$\_$$\_$1)\\
\twoSpaces      apply (cut$\_$tac b1, assumption)\\
\twoSpaces      apply (cut$\_$tac a2 a3, blast) done
    $\}$\\


    moreover $\{$
      assume b1:
($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv$\_$$\_$2  \iInv2)\\

      have
formEval f s\\

\twoSpaces      apply (rule iniImply$\_$inv$\_$$\_$2)\\
\twoSpaces      apply (cut$\_$tac b1, assumption)\\
\twoSpaces      apply (cut$\_$tac a2 a3, blast) done\\
    $\}$\\


    moreover $\{$
      assume b1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1~=\iInv2$\wedge$f=inv$\_$$\_$3  \iInv1 \iInv2)\\

      have
formEval f s\\

\twoSpaces      apply (rule iniImply$\_$inv$\_$$\_$3)\\
\twoSpaces      apply (cut$\_$tac b1, assumption)\\
\twoSpaces      apply (cut$\_$tac a2 a3, blast) done
    $\}$\\


    moreover $\{$
      assume b1:
($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv$\_$$\_$4  \iInv2)\\

      have
formEval f s\\

\twoSpaces      apply (rule iniImply$\_$inv$\_$$\_$4)\\
\twoSpaces      apply (cut$\_$tac b1, assumption)\\
\twoSpaces      apply (cut$\_$tac a2 a3, blast) done
    $\}$\\


    moreover $\{$
      assume b1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1~=\iInv2$\wedge$f=inv$\_$$\_$5  \iInv1 \iInv2)\\

      have
formEval f s\\

\twoSpaces      apply (rule iniImply$\_$inv$\_$$\_$5)\\
\twoSpaces      apply (cut$\_$tac b1, assumption)\\
\twoSpaces      apply (cut$\_$tac a2 a3, blast) done
    $\}$\\


  ultimately show formEval f s
  by auto\\
qed\\


\end{specification}

The proof structure of {\sf lemma$\_$inv1$\_$on$\_$rules} and  {\sf invs$\_$on$\_$rules} and {\sf on$\_$inis} are also typical case analysis ones using {\sf moreover} blocks and {\sf ultimately} commands, therefore, a generic program of generating a typical case analysis proof will be adopted in our framework.

%All can be generated by calling the generic template function {\sf doCaseAnalz} with different subproof generation functions.


\subsubsection{The main theorem}

%-------------------------------------------------------------------------
%At last, we discuss how to create automatically the proof for the main lemma, which depends
% on the applying the lemmas which are created in subsection \ref{sec:genOfIsabelleProof}.
With the preparation of lemma  on$\_$inis and  invs$\_$on$\_$rules, the generation of the main lemma is quite easy. Recall that the consistency lemma is our
main weapon to prove the main lemma, which requires proving two parts of
obligations.



\begin{description}
\item[(1)] For any invariant $inv \in (\mathsf{invariants} ~N) $,  any
state $s$, if $ini$ is evaluated true at state $s$, then $inv$ is
evaluated true at state $s$. This can be solved done by applying lemma on$\_$inis.
\item[(2)]  For any invariant $inv \in (\mathsf{invariants} ~N)$, any $r$ in rule set
$ \mathsf{rules} ~N$ , one of the causal relations
$\mathsf{invHoldForRule}_{1-3}$ holds. This can be solved done by  applying lemma invs$\_$on$\_$rules.
\end{description}
%
%Proof of Part (1) is  simple. %%For an invariant
%$inv=\mathsf{implyForm}~ant~cons$ in $invs$, we only need to prove
%that either $ant$ is evaluated as false or $cons$ is evaluated true
%at an initial state $s$ in order to prove $\models
%~inv~s$. Such a proof  can be automatically solved by Isabelle's
%$\mathsf{auto}$ command.



\begin{specification}
lemma main:
  $\isasymlbrakk$  s$\in$ reachableSet \{andList (allInitSpecs N)\} (rules N); 0<N$\isasymrbrakk$\\
  $\Longrightarrow$ $\forall$ inv. inv $\in$ (invariants N) $\longrightarrow$ formEval inv s\\
proof(rule consistentLemma)\\
  show consistent (invariants N) \{andList (allInitSpecs N)\} (rules N)\\
 proof(cut\_tac a1, unfold consistent\_def,rule conjI)\\
   show  $\forall$inv ini s. inv $\in$ (invariants N)
$\longrightarrow$ ini $\in$\{andList (allInitSpecs N)\}$\longrightarrow$formEval
ini s $\longrightarrow$ formEval inv s\\
proof((rule allI)+,(rule impI)+)\\
\twoSpaces   fix inv ini s\\
\twoSpaces   assume b1:inv $\in$ (invariants N) \\
\twoSpaces     and b2:ini $\in$ \{andList (allInitSpecs N)\}  and b3:formEval ini s\\
\twoSpaces   show "formEval f s"\\
\twoSpaces   apply (rule on\_inis, cut\_tac b1, assumption, cut\_tac b2, assumption, cut\_tac b3, assumption) done\\
    qed\\

next   show  $\forall$inv r. inv $\in$ invariants N$\longrightarrow$
 r $\in$rules N$\longrightarrow$invHoldForRule inv r (invariants N) \\

   proof((rule allI)+,(rule impI)+)\\
\twoSpaces      fix f r \\
\twoSpaces         assume b1: f $\in$ invariants N  and b2:r $\in$ rules N\\

\twoSpaces     show "invHoldForRule' s f r (invariants N)"\\
  apply (rule invs\_on\_rules, cut\_tac b1, assumption, cut\_tac b2, assumption) done\\
qed\\
next show "s $\in$ reachableSet {andList (allInitSpecs N)} (rules N)"
  apply (metis a1) done\\
qed\\
\end{specification}

The generation of the main lemma is quite easy because it is in a standard form.
%\vspace{-0.5cm}
 %in order to verify the cache coherence protocols. Others are straightforward.
%The proof is a typically
%readable one in Isar style \cite{}, which uses calculation
%reasoning such as {\tt moreover} and {\tt ultimately} to do  case analysis on
%the form of rules and the invariants. Lines 1-5 use proper Isabelle
%proof commands to   decompose the main proof goal of forall  and
%implication form,    fix a rule {\tt r} and {\tt inv}, then have two
%assumptions {\tt  b1: inv$\in$ invariants N  and b2:r $\in$ rules
%N}, now we need show the goal {\tt invHoldForRule s f r (invariants
%N)}. line 5 splits cases of $r$ into all possible cases according to
%the definition of $rules~N$. %In order to save space, we adopt the following abbreaviation:
% $\mathsf{ex1P}~ N~ P \equiv \exists i. (i \le N \wedge P~
%i)$, $\mathsf{ex2P}~ N~ P \equiv \exists i~j. (i \le N \wedge j \le
%N \wedge i\ne j \wedge P~ i~j)$, and $\mathsf{ex3P}~ N~ P \equiv
%\exists i~j~k. (i \le N \wedge j \le N \wedge k \le N\wedge i\ne j
%\wedge i\ne k \wedge j\ne k \wedge P~ i~j~k)$.
%Line 6 starts the case analysis on
%$r=r_0$. Line 7 again splits cases of $inv$ into all possible cases
%according to the definition of $invariants~N$. Line 8-10 proves the
%goal at case when $r=exit$ and $inv=inv1$. At line 10,  a  proved
%lemma {\tt exitVsInv1}  is directly applied to solve the proof
%goal.  Similiarly, we can do subproofs on other cases on {\tt inv},
%and finish the proof goal accordingly.
% After finishing the proof of the last case  of $inv=inv5$,
% we finish the proof of the first case $r=exit$. Similarly, we can
% finish the proof goal at
%each subcase on {\tt r}. At  lines 19 and  20 we show we have
%finished the proof goal formally.



\end{document}

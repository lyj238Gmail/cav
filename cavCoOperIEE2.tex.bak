%\documentclass{llncs}
\documentclass[final]{IEEEtran}
%%%%%%%%%%%%%%%%%%%%%%
%%%%   PACKAGES   %%%%
%%%%%%%%%%%%%%%%%%%%%%
\usepackage{makeidx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{latexsym}
\usepackage{url}
\usepackage{color}
\usepackage{isabelle}
\usepackage{isabellesym}
\usepackage{theorem}
\usepackage{algorithmic}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{multicol}
%\usepackage{program}
\usepackage{cases}
%\usepackage{enumitem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%For Isabelle code
\newlength{\fminilength}
\newsavebox{\fminibox}
\newenvironment{fmini}[1][\linewidth]
  {\setlength{\fminilength}{#1\fboxsep-2\fboxrule}%
   \vspace{2ex}\noindent\begin{lrbox}{\fminibox}\begin{minipage}{\fminilength}%
   \mbox{ }\hfill\vspace{-2.5ex}}%
  {\end{minipage}\end{lrbox}\vspace{1ex}\hspace{0ex}%
   \framebox{\usebox{\fminibox}}}

\newenvironment{specification}
{\noindent\scriptsize
\tt\begin{fmini}\begin{tabbing}X\=X12345\=XXXX\=XXXX\=XXXX\=XXXX\=XXXX
\=\+\kill} {\end{tabbing}\normalfont\end{fmini}}
\def \twoSpaces {\ \ }
\def \oneSpace {\ }
\def \eqc {=}
\def \andc {\wedge }
\def \negc {\lnot}
\def \orc {\vee }
\def \alt {$/\backslash$ }
\def \cat {\symbol{94}}

\def \dbRight {$\backslash\backslash$}
\def \iInv {iInv}
\def \iR {iR}
\newcommand \hoareTriple[3] {$\{#1\} #2  \{#3\}$}
\newcommand{\forget}[1]{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%for comments
\newcommand\JP[1]{\textcolor{magenta}{JP: #1}}
\newcommand\lyj[1]{\textcolor{magenta}{lyj: #1}}
\newcommand\cai[1]{\textcolor{blue}{ #1} }
\newcommand\caicomment[1]{\textcolor{red}{comment: #1} }

\setlength{\parskip}{0.6ex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Additional math operators
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[colorlinks,
            linkcolor=black,
            anchorcolor=black,
            citecolor=blue,
            urlcolor=black,
            bookmarks=true
            ]{hyperref}

\input{tcilatex}

%=========================================
\begin{document}


\title{ {\sf A Novel Approach to Parameterized Verification}
}
%\titlerunning{A Novel Approach to Parameterized verification of Cache Coherence Protocols}
\author{Yongjian Li  \and
        Kaiqiang Duan  \and
        Shaowei Cai  \and
        Yi Lv
%\thanks{%
%Yongjian~Li and Kaiqiang Duan and Shaowei Cai and Yi Lv are with State Key Laboratory of Computer
%Science, Institute of Software, Chinese Academy of sciences ,
%Beijing, China.
%E-mail: lyj238,zengnj@ios.ac.cn}%
%\thanks{William~N.~N.~Hung is with Synopsys Inc., Mountain View,
%California, USA.
%E-mail: william\_hung@alumni.utexas.net}%
%\thanks{Xiaoyu~Song is with ECE Department, Portland State
%University, Portland, Oregon, USA. E-mail: song@ece.pdx.edu}
}
%\authorrunning{Li et al.}
%55\institute{
%State Key Laboratory of Computer Science,
%Institute of Software,
%Chinese Academy of Sciences
%}
\maketitle
%-------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------
Parameterized verification of parameterized protocols like cache coherence protocols is important
but hard.   Our tool {\sf paraVerifier} handles this hard problem in
a unified framework: (1) it automatically  discovers auxiliary invariants and the
corresponding causal relations %between invariants and rules
 from a small reference instance of the verified protocol; (2) the above
invariants and causal relation information  are automatically generalized into a parameterized
form to construct a parameterized formal proof in a theorem prover
(e.g., Isabelle). The principle underlying the generalization is the
symmetry mapping. Our method is successfully applied to typical
benchmarks including  snoopy-based and directory-based benchmarks. Another novel
feature of our method lies in that the final verification result of a
protocol is provided by a formal and readable proof.% in a theorem
%prover like Isabelle.

%-------------------------------------------------------------------------
\end{abstract}
%-------------------------------------------------------------------------
%-------------------------------------------------------------------------

%\vspace{-0.5cm}
\section{Introduction }
%-------------------------------------------------------------------------
%=========================================
Verification of parameterized concurrent systems is interesting in
the area of formal methods, mainly due to the practical importance
of such systems. Parameterized systems exist in many important
application areas, including cache coherence, security, and
network communication protocols. %In this work, we will
%focus on cache coherence protocols, which play a key role in modern
%computer architectures. They require complex algorithms that must
%deal with asynchrony, unpredictable message delays, and multiple
%communication paths between many clients. Therefore, the highest
%possible assurance for the correctness of these complex
%parameterized systems should be guaranteed by formal reasoning
%techniques.
%The real challenge posed by parameterized verification is that the
%desired properties should hold in any instance of the parameterized
%system, not just for a single protocol instance. Model checking is
%automatical but is able to verify just an instance of the parameterized
% system. The correctness of the reference instance  does
%not formally suffice to conclude the correctness for all instances.
%Due to the extreme importance of many parameterized system, it is
%preferable to have a proof that the correctness holds for any
%instance.
The hardness of parameterized verification is mainly due to the requirement of correctness that
the desired properties should hold in any instance of the parameterized
system. The model checkers, although powerful in verification of
non-parameterized systems, become impractical to verify parameterized systems, as they can verify only an instance of the parameterized
system in each execution.
A desirable approach is to provide a proof that the correctness holds for any instance.
%\vspace{-0.3cm}
\paragraph*{Related Work} There have been a lot of studies in the field of  parameterized
verification~\cite{Pnueli1996,Bj√∏rner1997,Arons2001,Pnueli2001,Tiwari2001,Chou2004,Pandav2005,Lv2007,cubicle2011}.
Among them, the `invisible invariants' method~\cite{Arons2001}
is an automatic technique for parameterized verification. In this
method, auxiliary invariants are computed in a finite system
instance to aid inductive invariant checking. Combining parameter
abstraction and guard strengthening with the idea of computing
invariants in a finite instance, Lv~et al.~\cite{Lv2007} use a small instance of a
parameterized protocol as a `reference instance' to compute candidate
invariants. References to a specific
node in these candidate invariants are then abstracted away, and the
resulting formulas are used to strengthen guards of the transition
rules in the abstract node. Both works~\cite{Arons2001,Lv2007} attempt to automatically
find invariants. However, the invisible invariants are raw boolean formulas transferred from the reachable sate set of a small finite instance
of a protocol, which are BDDs computed by TLV (an variant of BDD\_based SMV model checker). They are too raw to have an intuitive meanings. The capacity of the invisible invariant method is seriously limited when computing the reachable  set of invisible invariants for  the inductive checking is not feasible in the case of a large example like FLASH . Until now, the  examples, which can be handled by the "invisible invariant" method, are quite small,  we still can't find successful experiments  on large examples like FLASH.


The CMP method, which adopts parameter abstraction and guard strengthening, is proposed
in~\cite{Chou2004} for verifying a safety property $inv$ of
a parameterized system.
 An abstract instance of the parameterized protocol,  which consists of m + 1
nodes $\{P_1, \ldots , P_m, P^*\}$ with $m$ normal nodes and one
abstract node $P^*$, is constructed iteratively. The abstract system is an
abstraction for any protocol instance whose size is greater than
$m$. Normally the initial abstract system does not satisfy the
invariant $inv$. Nevertheless it is still submitted to a model
checker for verification. When a counterexample is produced, one needs to
carefully analyze it and comes up with an auxiliary invariant
$inv'$, then uses it to strengthen the guards of some transition
rules of the abstract node. The `strengthened' system is then
subject to model checking again. This process stops until the
refined abstract system  eventually satisfies the original invariant
  as well as all the auxiliary invariants supplied by the
user. However, this method's soundness is only argued in an
informal way. To the best of our knowledge, no one has
formally proved its correctness in a theorem prover. This
situation may be not ideal because its application domain for cache
coherence protocols  which demands the highest assurance for
correctness. Besides, the analysis of counter-example and generation of new auxiliary invariants usually
 depend on human's deep insightful understanding of the protocol. It is too laborious for people to do these analysis and some effective automatic  tool is needed to help people.

 Predicate abstraction is also applied to the verification of parameterized systems. Baukus, Lakhnech, and Stahl  have used it to verify German (without data paths)\cite{Baukus2002}, and
 Das, Dill, and Park have used it to verify    FLASH\cite{Park1996a}.  The core of predicate abstraction is to discover  a set of predicates, which are needed  to abstract the states of a system, and an abstract state is a valuation of the predicates. Unfortunately, the task of discover proper predicates is neither easy nor automatical. Furthermore, the abstracted system is needed to proved to be conservative for certain properties under verification. This proof also needs a set of auxiliary invariants. Therefore searching enough auxiliary invariants cann't be avoided. No further efforts are made to make automatical both the discovery of proper predicates and the searching of auxiliary invariants in the work of applying predicate abstraction to the parameterized verification.

Sylvain Conchon, Amit Goel, Sava Krstic, Alain Mebsout, and Fatiha Zaidi have made progress in searching automatically auxiliary invariants\cite{Conchon2013}. A heuristics-guided algorithm, called Barb, searches auxiliary invariants backward  with the help of an oracle (a reference instance of the protocol). Roughly speaking, Barb's work can be seen as a backward reachability analysis. Barb is implemented in an SMT-based model checker Cubicle\cite{Conchon2012}. The correctness of Barb is argued in a generic symbolic framework. The searched auxiliary invariants are claimed to be inductive for deductive proof in a case study of a  protocol. However, the formulation of Barb and the proof is not done in a theorem prover. Neither is a formal proof is given adopting the invariants for the protocol. Besides, the configuration of oracle need to be done manually.



The degree of rigorousness and automation are two critical aspects of approaches to parameterized verification.
The verification of real-world parameterized systems is, however,  rarely  both rigorous and automatic.
{For instance, FLASH protocol is the cache coherence protocol of the Stanford FLASH mutlitprocessor \cite{FLASHCache}. This protocol is so complex that only a few approaches  \cite{Park1996a,McMillan2001,Chou2004,Conchon2013} have successfully verified it so far. Furthermore, all existing  successful verification approaches have their downsides.  \cite{Park1996a} is a theorem proving based approach which requires
to construct inductive invariants by hand. The cases of \cite{McMillan2001} and \cite{Chou2004} are similar to \cite{Park1996a} that hand-crafted invariants are required to
provide by human experts. As a contrast, \cite{Conchon2013} is a model checking based approach which can be carried out automatically. However, the formal proof can not be obtained from the work of \cite{Conchon2013}.
%: ÔøΩÔøΩif the method works on FLASH, then there is a good chance that it will also work on many real-world cache coherence protocols ÔøΩÔøΩ \cite{Chou2004}. However, the existing approaches, which have verified FLASH, need too much human intervention. The first full verification of safety properties of FLASH is done by work in \cite{Park1996a}. Park and Dill  proved the safety properties of FLASH using  PVS \cite{cade92-pvs}. %They introduce the aggressioned FLASH protocol, which
%is in fact an abstracted transaction version of FLASH,   need prove
%the correspondence between the abstract and the original FLASH
%protocol, and then prove the correctness of the abstracted protocol, and subsequently derive the correctness of  the
%original protocol by the correspondence. New   auxiliary state variables
%like {\tt fwdSrc} are   introduced  for verification. Deep human insight for FLASH is needed for both the construction of the aggressioned model  and  introducing new state variables.  Later research on FLASH must also rely on these auxiliary
%variables for verification.
%McMillan applied compositional
%model checking \cite{McMillan2001}  and used Candence SMV  \cite{cadenceSMV} to the verification of both safety and liveness properties of FLASH. In a different context, safety
%properties of German 2000 and FLASH were proved via
%Murphi tool \cite{alanHuMurphi} by adopting CMP method in \cite{Chou2004}. In
%all the three methods mentioned above, auxiliary invariants
%have to be supplied manually. Predicate abstraction based
%methods were applied to verify
%FLASH in \cite{dillPred}. Users need to manually provide plausible properties
%in predicate abstraction and automated predicate discovery
%techniques to find large predicates. So verifying large protocols
%like FLASH using predicate abstraction is also difficult. In contrast to previous work, our work need fewer human's aid in the verification of FLASH.   Both the auxiliary invariants and formal proof are generated automatically, and these   auxiliary invariants have intuitive meanings which can  be used to analyze FLASH.  %  The abstractions
%we used, the reliance on apparently circular reasoning, and the counterexampleguided
%discovery of noninterference lemmas are all deeply influenced by McMillan ÔøΩÔøΩs
%work.
In order to effectively verify complex parameterized protocols like FLASH protocol, there are two issues need to be addressed.
The first one is  how to find a set of sufficient and necessary invariants without (or with less) human intervention, which is a core research topic in this field. %of parameterized verification. %\cai{The second one is to get the invariants without (or with less) human intervention.}
The second one is the rigorousness  of the verification. %The theory foundation of a parameterized verification technique and its soundness are only discussed in a paper proof style in previous work.  %We will compare our approach in \ref{sec:experiments}.%For instance,
%the theory contains the apparent circularity in reasoning and
%applying the auxialiary invariants, and is based on the classical
%notion of a so-called simulation proofs \cite{Chou2004}. Frankly speaking, the
%theory itself is not easy to be understood, and  needs to be
%checked mechanically due to its soundness of should be
%guaranteed without conditions.
It is preferable to formulate all the verification in a publicly-recognized trust-worthy framework like a theorem prover \cite{Chou2004}.

It is not difficult to  formalize the model and properties of a protocol in a theorem prover like Isabelle, however, it is too hard to construct a  proof to prove the properties. Because the most creative choices in a formal proof are done by human and hard to be automated. These choices mainly lie in: (1) the induction scheme; (2) the case analysis: different subproofs are done in different cases. (3) the quantifier instantiations. Up to now, the main efforts are made in searching invariants automatically. Few people have considered how to link  the invariant searching with proof checking. The invariants found  automatically from   a concrete instance of the protocol in \cite{Arons2001, Conchon2013, Lv2007} without consideration how to use them in a theorem proving, thus, it is still hard to automate the above three kinds of intelligent choices. In detail, the invariants and rules are usually in concrete form in the procedure of invariant searching, but not in a parameterized form which are required in theorem proving. The generalization from a result obtained in the concrete protocol instance  to that in the parameterized instance  is not fully considered. Therefore, much human intervention is still needed to prove that the properties are invariance. Usually the complexity of the proof is  beyond  human's power. This is the reason why a theorem prover is still seldom  used in parameterized verification.

In order to solve the parameterized
verification %of cache coherence protocols
 in a both automatical and rigorous way, we must consider the invariant searching with proof checking in a unified framework. The key ideas are  to make the aforementioned generalization automatically and to make the aforementioned creative choices in theorem proving to be automated. In detail,

 \begin{enumerate}
 \item We propose a special induction scheme for parameterized verification.   Three kinds of causal
relations among a formula and a rule and a set of formulas are introduced, which are
essentially special cases of the general induction rule. Notably,  with proper case analysis on the comparing parameters of a parameterized rule and those of a parameterized form, the three special induction proof rules can be applied automatically in a theorem prover.

\item A so-called consistent relation among a protocol instance and a set of formulas is proposed basing on the above three causal
relations, which is the cornerstone in
our method. If such a consistent relation holds, then any formula in the formula set is an invariant for the protocol instance. Here the protocol instance can be either concrete or parameterized.


\item \label{step2} From an initially given invariant, our tool search both invariants and causal relations from a small concrete protocol instance  which can construct a consistent relation between the protocol instance and the set of all found invariants. Notice that both invariants and causal relations, which are searched in this phase, are  concrete  and stored in a table.

\item \label{step3} Basing on the  analysis and generalization by comparing the  parameters of a concrete rule and those of a concrete invariant occurring in a line of the table, we  generalize the line into a symbolic form. Namely, the invariants and rules will be generalized into symbolic forms, and a symbolic formula is generated basing on the above analysis of concrete parameters, and used to  indicate the  case condition in which the comparison should be satisfied between  the symbolic parameters of the symbolic invariants and rules. Thus, the information on the splitting cases decided by comparison between  the two symbolic parameters of a parameterized rule and a parameterized invariant formula is given in the generalized table. The choice of the three special induction proof rules in each case is also given in a line.

\item From the table in   \ref{step3}, a formal proof script in a theorem prover (e.g., Isabelle)  can be generated to prove that a consistent relation also holds between the parameterized protocol instance and the set of the parameterized invariant formulas. Notably, because the proof script has enough proof commands to do induction, and case analysis and necessary quantifier instantiation, the proof script can be automatically checked once it is fed into the theorem prover.

%Especially, the theory foundation itself is  verified as a
%formal theory in Isabelle, which is the formal library for verifying protocol case studies. The library provides basic types and constant definitions to model protocol cases and lemmas to prove  properties. % invariant Therefore, the theoretical foundation is rigorous.


\end{enumerate}

Basing on the above ideals, We design a tool called {\sf paraVerifier}, which is shown as below:


\begin{figure}[htbp]
\centering %
%\vspace{-0.8cm}
\includegraphics[width=0.5\textwidth]{paraVerifier.pdf}
\vspace{-0.6cm}
\caption{The workflow of {\sf paraVerifier} \label{fig:arch}
}
\end{figure}

Our tool {\sf paraVerifier} is composed of two parts:  an invariant finder {\tt invFinder}
and a proof generator {\tt proofGen}. %In order to verify  that an
%invariant $inv$ holds for any parameterizd instance of a protocol.
Given a protocol $\mathcal{P}$ and a property $inv$, {\tt invFinder} tries to find useful auxiliary invariants and causal relations which are capable of proving $inv$. To construct auxiliary invariants and causal relations, we employ heuristics inspired by consistency relation. Also, when several candidate invariants are obtained using the heuristics, we use oracles such as a model checker and an SMT-solver to check each of them under a small reference model of $\mathcal{P}$, and chooses the one that has been verified.


After {\tt invFinder} finds the auxiliary invariants and causal relations, {\tt proofGen} generalizes them  into a parameterized form, which are then used to construct a completely parameterized formal proof in a theorem prover (e.g., Isabelle) to model $\mathcal{P}$ and to prove the property $inv$. The generated proof is checked automatically.  %Usually, a proof is done interactively. Special efforts in the design of the proof generation are made in order to make the proof checking automatically. %In order to make the proof checking automatical, the basically formal library theory should be imported, and support

The organization of this work is as follows: Section \ref{sec:Preliminaries} introduces the preliminaries; Section  \ref{sec:causal_rel} introduces the theoretical foundation; Section \ref{sec:invFinder} the {\sf invFinder}; Section \ref{sec:generalization} the generalization strategy; Section \ref{sec:prooGen} the {\sf proofGen} and the generated proof. We go through these sections by verifying a small example - mutual exclusion example. Section \ref{sec:experiments} shows the further experiments on real-world protocols. Section \ref{sec:conclusion} concludes our work.

\section{Preliminaries}\label{sec:Preliminaries}
%\vspace{-0.3cm}
%\subsection{Protocol syntax} \label{sec:protocolSyntax}
%Variable are defined by the following BNF grammar:
%\begin{equation*}
%\left.
%\begin{array}{l}
%\mathtt{
%var ::=id |var[int] |rcd.id}
%\end{array}%
%\right.
%\end{equation*}
In this section, we introduce the theoretical foundation underlining
{\sf paraVerifier}. Consider a set of state variables $V$,
we use $e$, $f$ and $S$ to denote an
expression, a formula, and a statement over the set of state
variables $V$.
Variables are divided into two classes: array variables or
non-array (global) variables. Basing on the variables, first order expressions and formulas can be defined as usual. We also assume that the variables in $V$ range over a finite set $D$.
A state $s$  of a protocol is an
instantaneous snapshot of its behavior given by a mapping from
all variables in $V$ to $D$.  We write
$\mathbb{A}[e,s]$ (and $s \models f$) to denote the
evaluation result of the expression and (and formula $f$ is  evaluated to be true) at the state $s$.
With a parallel assignment $S=\{x_i:=e_i | i>0\}$,
we define the notion of the weakest precondition $\mathsf{preCond}(S,f)\equiv f[x_i:=e_i]$, which substitutes each
occurrence of $x_i$ by $e_i$.

\smallskip
\noindent{\bf Protocols.}
A cache coherence protocol is formalized as a pair $({\it I}, {\it R})$, where
(1) ${\it I}$ is an initialization formula; and
(2) ${\it R}$ is a set of transition rules. Each rule $r\in {\it R}$ is defined as
  $g \vartriangleright  S$, where $g$ is a predicate, and $S$ is a
  parallel assignment to distinct  variables $v_i$ with expressions
  $e_i$. We write $\mathsf{pre}(r)=g$, and $\mathsf{act}(r)=S$
  if $r=g \vartriangleright S$. A state transition is caused by   trigger and execution of a rule, formally, we define: $s\overset{r}{\rightarrow } s' \equiv$ $s \models \mathsf{pre}(r)\wedge$$(\forall x \in \mathsf{vars}(\mathsf{act}(r)). s'(x)=\mathbb{A}[e,s]$ $\wedge (\forall x \notin \mathsf{vars}(\mathsf{act}(r)). s'(x) = s(x))$.

\noindent{\bf Reachable state sets.}
  As usual, the reachable state set of protocol  $\mathcal{P}=(I,R)$, denoted as $\mathsf{reachableSet}(\mathcal{P})$, can be defined inductively: (1) a state $s$ is in
$\mathsf{reachableSet}(\mathcal{P})$ if there exists a formula $f \in I$, and $s \models  f$; (2) a state $s$ is in
$\mathsf{reachableSet}(\mathcal{P})$ if there exists a  state $s_0$  and a rule $r \in R$ such that $s_0 \in \mathsf{reachableSet}(\mathcal{P})$ and $s_0\overset{r}{\rightarrow } s$.


\noindent{\bf Parameterized formulas, statemets, rules, and protocols}
For simplicity, a
A parameterized formula(statement, rule, and protocol) is a function $f(x_1,x_2,...,x_n)$ from a tuple of natural numbers  to such an object. Without losing the generality, we require that parameters to instantiate a parameterized object are disjoint. For instance, $\mathsf{mutualInv}(i,j)\equiv
  \negc (n[i]\eqc C \andc n[j]\eqc C)$ is a parameterized formula with two disjoint parameters. A list of natural numbers which are different from each other are actual parameters to instantiate a parameterized object. Thus,  we need some functions on lists, $x\#xs$ for the list that extends $xs$ by adding $x$ to the
front of $xs$, $\left[ x_{1},..x_{n}\right] $ for a list
$x_{1}\#..x_{n}\#[]$, $xs@ys$ for the result list by concatenating
$xs$ with $ys$, $xs{[i]}$ for the $i^{th}$ element of the list $xs$
(counting from 1 as the first element), $\mathsf{set}~xs$ for the
set of all the elements in $xs$, $|xs|$ for the length
of the list $xs$, $\mathsf{hd}(xs)$ for the head element of a non-empty list, $\mathsf{tl}(xs)$ for the tail of $xs$ but the head element.

\forget{There are three kinds of $variables$:
1) simple identifier, denoted by a string;
2) element of an array, denoted by a string followed by a natural inside a square bracket. E.g., $arr[i]$ indicates the $i$th element of the array $arr$;
3) filed of a record, denoted by a string followed by a dot and then another string. E.g., $rcd.f$ indicates the filed $f$ of the record $rcd$.
Each variable is associated with its $type$, which can be enumeration, natural number, and Boolean.}

%%Expressions and formulas are defined recursively by the following BNF grammar:
%\begin{equation*}
%\left.
%\begin{array}{l}
%\mathtt{
%exp::=var | const | formula?exp:exp|}\\
%\mathtt{formula::=True| False| exp=exp | formula ~op~ formula | \neg formula }

%\end{array}%
%\right.
%\end{equation*}

\forget{$Experssions$ and $formulas$ are defined mutually recursively. $Experssions$ can be simple or compound. A simple expression is either a variable or a constant, while a compound expression is constructed with the ite(if-then-else) form $f?e_1:e_2$, where $e_1$ and $e_2$ are expressions, and $f$ is a formula.
A $formula$ can be an atomic formula or a compound formula. An atomic formula can be a boolean variable or  constant, or in the equivalence form $e_1\eqc e_2$, where $e_1$ and $e_2$ are two expressions. A $formula$ can also be constructed by using the logic connectives, including negation ($\negc$), conjunction ($\andc$), disjunction ($\orc$), implication ($\dashrightarrow$).} %, logical equivalence ($\longleftrightarrow$).

\forget{An $assignment$ is a mapping from a variable to an expression, and is denoted with the assigning operation symbol ``:=''. A $statement$ $\alpha$ is a set of assignments which are executed in parallel, e.g., $ x_1:=e_1;x_2:=e_2;...;x_k:=e_k $. If an assignment maps a variable to a (constant) value, then we say it is a $value$-$assignment$.  We use $\alpha|_x$ to denote the expression assigned to $x$ under the statement $\alpha$. For example, let $\alpha$ be $\{arr[1]:=C;x:=false\}$, then $\alpha|_x$ returns $false$. A $state$ is an instantaneous snapshot of its behavior given by a set of value-assignments.}




\forget{For every expression $e$ and formula $f$, we denote the value of $e$ (or $f$) under a state $s$ as $\mathbb{A}[e,s]$ (or $\mathbb{B}[f,s]$).
For a state $s$ and a formula $f$, we write
$s\models f$ to mean %$\mathbb{A}[e,s]=c$ and
$\mathbb{B}[f,s]=true$.
Formal semantics of expressions and formulas are given in HOL  as usual, which is shown as follows: \footnote{The logic to specify parameterized system  can be embedded in HOL supported by Isabelle. Therefore, HOL can be regarded as the main meta-logic in our work.}\\

\begin{table}[h] \label{table-semantics-exp-formula}
\center\begin{tabular}{|l|l|}
  \hline
   Semantics \\ \hline
  $\mathbb{A}[v,s]\equiv s(v)$, where  $v$ is a variable\\
    $\mathbb{A}[c,s]\equiv c$, where  $c$ is a constant\\
   $\mathbb{A}[f?e_1:e_2,s]\equiv$if ($\mathbb{B}[f,s]$) then $\mathbb{A}[e_1,s]$ else $\mathbb{A}[e_2,s]$ \\
  $\mathbb{B}[ e_1\doteq e_2,s]\equiv   \mathbb{A}[e_1,s]=\mathbb{A}[e_2,s]$  \\
  $\mathbb{B}[\negc f,s]\equiv \neg \mathbb{B}[f,s]$ \\
  $\mathbb{B}[f_1\andc f_2,s]\equiv \mathbb{B}[f_1,s] \land \mathbb{B}[f_1,s]$ \\
  $\mathbb{B}[f_1\orc f_2,s]\equiv \mathbb{B}[f_1,s] \vee \mathbb{B}[f_2,s]$ \\
 $\mathbb{B}[f_1\dashrightarrow f_2,s]\equiv \mathbb{B}[f_1,s]$  implies $\mathbb{B}[f_2,s]$ \\
 %  $\mathbb{B}[f_1\longleftrightarrow f_2,s]\equiv \mathbb{B}[f_1,s]$  if and only if $\mathbb{B}[f_2,s]$ \\
  \hline
\end{tabular}
\end{table}


For an expression $e$ and a statement $\alpha= x_1:=e_1;x_2:=e_2;...;x_k:=e_k $, we use $\mathsf{vars(\alpha)}$ to denote the variables to be assigned $\{x_1,x_2,...x_k\}$; and use $e^{\alpha}$ to denote the expression transformed from $e$ by substituting each $x_i$ with $e_i$ simultaneously.
Similarly, for a formula $f$  and a statement $\alpha= x_1:=e_1;x_2:=e_2;...;x_k:=e_k $, we use $f^{\alpha}$ to denote the formula transformed from $f$ by substituting each $x_i$ with $e_i$.
Moreover, $f^{\alpha}$ can be regarded as the weakest precondition of formula $f$ w.r.t. statement $\alpha$, and we denote $preCond(f,\alpha)\equiv f^{\alpha}$. Noting that a state transition is caused by an execution of the statement, formally, we define: $s\overset{\alpha}{\twoheadrightarrow } s' \equiv$ $(\forall x \in \mathsf{vars}(\alpha). s'(x)= \mathbb{A}[\alpha|_x,s])$ $\wedge (\forall x \notin \mathsf{vars}(\alpha). s'(x)= s(x))$ .

A $rule$ $r$ is a pair $<g,\alpha>$, where $g$ is a formula and is called the guard of rule $r$, and $\alpha$ is a statement and is called the $action$ of rule $r$.
 For convenience, we denote a rule with the guard $g$ and the statement $\alpha$ as $g \vartriangleright \alpha$. Also, we denote $\mathsf{act}(g \vartriangleright \alpha)\equiv \alpha$ and $\mathsf{pre}(g \vartriangleright \alpha)\equiv g$. If the guard $g$ is satisfied at state $s$, then $\alpha$ can be executed, thus a new state $s'$ is derived, and we say the rule $g \vartriangleright \alpha$ is triggered at $s$, and transited to $s'$. Formally, we define: $s\overset{r}{\rightarrow } s' \equiv s\models \mathsf{pre}(r) \wedge s\overset{\mathsf{act}(r)}{\twoheadrightarrow } s'$.

A $protocol$ $\mathcal{P}$ is a pair $(I,R)$, where $I$ is a set of $formulas$ and is called the initializing formula  set, and $R$ is a set of rules. %A $state$ is an instantaneous snapshot of its behavior given by a set of assignments.
 As usual, the reachable state set of protocol  $\mathcal{P}=(I,R)$, denoted as $\mathsf{reachableSet}(\mathcal{P})$, can be defined inductively: (1) a state $s$ is in
$\mathsf{reachableSet}(\mathcal{P})$ if there exists a formula $f \in I$, and $s \models  f$; (2) a state $s$ is in
$\mathsf{reachableSet}(\mathcal{P})$ if there exists a  state $s_0$  and a rule $r \in R$ such that $s_0 \in \mathsf{reachableSet}(\mathcal{P})$ and $s_0\overset{r}{\rightarrow } s$.

A parameterized object(T) is simple a function from a natural number to T, namely of type $nat \Rightarrow T$. For instance, a parameterized formula $pf$ is of type $nat \Rightarrow formula$, and we define
$\mathsf{forallForm}(1,pf)\equiv~pf(1)$, and $\mathsf{forallForm}((n+1),pf)\equiv\mathsf{forallForm}(n,pf) \andc pf(n +1)$. $\mathsf{existsForm}(1,pf)\equiv~pf(1)$, and $\mathsf{existsForm}((n+1),pf)\equiv\mathsf{existsForm}(n,pf) \orc pf(n +1)$.

}



Now we use a simple example to illustrate the above definitions by a simple mutual exclusion protocol with $N$ nodes. Let $\mathsf{I(dle)}$, $\mathsf{T(rying)}$,
 $\mathsf{C(ritical)}$, and  $\mathsf{E(xiting)}$  be enumerating values to indicate the state of a node, $x$,    $n$ are  simple and array variables, $N$ a natural number. $x$ is a flag to indicate ?   $\mathsf{pini}(N)$   the predicate to specify the inial state, prules(N) the four rules of the protocol, $\mathsf{mutualInv}(i,j)$ a property that $n[i]$ and $ n[j]$ cannot be in a critical state at the same time. We want to verify that $\mathsf{mutualInv}(i,j)$ holds at any reachable state of the parameterized protocol $mutualEx(N)$ for any $i\le N$, $j \le N$ s.t. $i \neq j$.
\vspace{-0.3cm}
\begin{example}\label{example1}Mutual-exclusion example.

\begin{specification}
%assignN(i)$\equiv$n[i]=I\\
\\
 pini(N) $\equiv$
   x=true $\wedge  \bigwedge\limits^N_{i=1}$ n[i]=I \\

    try(i) $\equiv$ n[i] $\eqc$ I $\vartriangleright$ n[i] := T \\

    crit(i) $\equiv$ n[i] $\eqc$ T$\wedge$ x = true $\vartriangleright$  n[i] := C; x := false\\

%
   exit(i) $\equiv$ n[i] $\eqc$ C $\vartriangleright$ n[i] := E \\


   idle(i) $\equiv$  n[i] $\eqc$ E $\vartriangleright$ n[i] := I;  x := true
  \\% \\
   prules(N) $\equiv$ \{r. $\exists$ i. i $\le$ N $\wedge$( r=crit(i)~$\vee$ r=exit(i) \\
    $\vee$ r=idle (i)~$\vee$ r=try (i)\}\\
%\\

mutualEx(N)$\equiv$ (pIni(N), prules(N))\\

mutualInv(i,j) $\equiv$
  $\negc$ (n[i]$\eqc$ C $\andc$ n[j]$\eqc$ C)\\



\end{specification}
\end{example}


\forget{As Hoare logics specifies,  after executing statement $\alpha$, $f$ holds iff $\mathsf{preCond}(f, \alpha)$ holds before the execution.
\begin{lemma}\label{lemma-preCond}
Suppose $s\overset{\r}{\rightarrow } s'$,
$s\models \mathsf{preCond} (f, \mathsf{act}(r))$ if and only if $s'\models f$
\end{lemma}
}


\section{Causal Relations and Consistency Lemma} \label{sec:causal_rel}

A novel feature of our work lies in that three kinds of causal
relations are exploited, which are essentially special cases of the
general induction rule.  Consider a rule $r$, a formula $f$, and a formula set $fs$, three
 kinds of causal relations are defined as follows:
 \begin{definition}
We define the following relations:
\forget{$\mathsf{invHoldRule_1}::state \times formula\times rule \Rightarrow bool$, $\mathsf{invHoldRule_2}::state\times  formula\times rule  \Rightarrow bool$,  $\mathsf{invHoldRule_3}::state \times formula\times rule \times rule set\Rightarrow bool$, and $\mathsf{invHoldRule}::state \times formula\times rule \times rule set\Rightarrow bool$.}
\vspace{-0.2cm}
\begin{enumerate}
\item $\mathsf{invHoldRule_1} (s,f,r) \equiv $$s \models \mathsf{pre}(r) \longrightarrow s \models \mathsf{preCond}(f ,\mathsf{act}(r))$;
\item $\mathsf{invHoldRule_2}(s,f,r) \equiv  $$s \models f \longleftrightarrow s \models \mathsf{preCond}( f,(\mathsf{act}( r))$;
\item $\mathsf{invHoldRule_3}(s,f,r,fs) \equiv$  $\exists f' \in fs$ s.t.
$s \models ( f' \andc (\mathsf{pre}(r))  \longrightarrow s \models \mathsf{preCond}(f ,\mathsf{act}(r))$;
\item $\mathsf{invHoldRule}(s,f,r, fs) \equiv$   $s \models\mathsf{invHoldRule_1}(s,f,r) \vee s\models\mathsf{invHoldRule_2}(s,f,r) \vee s\models \mathsf{invHoldRule_3}(s,f,r,fs)$.
%\item $\mathsf{invHoldRule}~ f~ r ~fs \equiv (\mathsf{invHoldRule_1} ~f
%  ~r) \lor (\mathsf{invHoldRule_2} ~f ~r) \lor (\mathsf{invHoldRule_3}~ f~ r~fs)$.
\end{enumerate}
\end{definition}
\vspace{-0.2cm}
%\begin{specification}
%definition invHoldRule1::
%formula $\Rightarrow$ state $\Rightarrow $ rule $\Rightarrow$ bool where\\
%invHoldRule1 s f  r$\equiv$ %\\
%(  formEval (pre r) s $\longrightarrow$
%  formEval  (preCond f  (act r)) s ) \\ %\\

%definition invHoldRule2:: state $\Rightarrow$ formula $\Rightarrow$ rule $\Rightarrow$ bool
% where \\

%invHoldRule2 s f  r $\equiv$  (  formEval  (preCond f  (act r)) s  =  formEval f s\\
%\end{specification}

%\vspace{2mm}
% \begin{specification}
%definition   invHoldRule3::
%state $\Rightarrow$ formula $\Rightarrow$ rule $\Rightarrow$formula set$\Rightarrow$ bool\\

% invHoldRule3 s f r fs  $\equiv$\\
%  (let pref=preCond f (act r) in\\
%  ( $\exists$f'. f' $\in$ fs $\wedge$  (formEval   (andForm (pre r)  f') s$\longrightarrow$
% formEval  pref s)))\\
%\\
%abbreviation invHoldRule::
%state $\Rightarrow$formula $\Rightarrow$ rule $\Rightarrow$ (formula set) $\Rightarrow$ bool
% where\\

%invHoldRule s inv0 r invs $\equiv$\\
%    invHoldRule1 s inv0 r $\vee$  invHoldRule2 s inv0 r $\vee$
 %  invHoldRule3 s inv0 r invs\\




%\%end{specification}

The relation $\mathsf{invHoldRule}(s, f,r,fs)$ defines a causality relation
between $f$, $r$, and $fs$, which guarantees that if each formula in $fs$ holds
before the execution of rule $r$, then $f$ holds after the execution of rule $r$. This includes three cases. 1) $\mathsf{invHoldRule}_1(s,f, r)$ means that after rule $r$ is executed, $f$ becomes true immediately;   2) $\mathsf{invHoldRule}_2(s,f, r)$ states that $\mathsf{preCond}(S,f)$ is equivalent to $f$, which intuitively means that none of state variables in $f$ is changed, and the execution of statement $S$ does not affect the evaluation of $f$;
 3) $\mathsf{invHoldRule}_3(s,f, r,fs)$ states that there exists another invariant $f' \in fs$ such that
  the conjunction of the guard of $r$ and $f'$ implies the precondition  $\mathsf{preCond}(S,f)$.
%Intuitively, $\mathsf{invHoldRule}(s, f, r, fs)$ defines a causal relation, which guarantees that if each of formula in $fs$ holds before the execution of the rule $r$, then  $f$ also holds after the execution of the rule $r$.

In Hoare logic, a Hoare triple is of the form \hoareTriple{f}{ S} {f'}
where $f$ and $f'$ are assertions of formulas and $S$ is a statement.  $f$  is named the precondition and $f'$ the postcondition: when the precondition is met, executing $S$ establishes the postcondition. We can interpret the above three kinds of causality relation in   Hoare triples:

\begin{enumerate}
\item $\mathsf{invHoldRule_1} (s,f,r)$ if and only if \hoareTriple{\mathsf{pre}(r)}{ \mathsf{act}(r)} {f}
\item $\mathsf{invHoldRule_2} (s,f,r)$ if and only if \hoareTriple{\mathsf{pre}(r) \andc f}{ \mathsf{act}(r)} {f}
\item $\mathsf{invHoldRule_3} (s,f,r,fs)$ if and only if $\exists f_0. f'\in fs \land ($\hoareTriple{\mathsf{pre}(r) \andc f_0}{ \mathsf{act}(r)} {f}$)$
\end{enumerate}

$\mathsf{invHoldRule}(s, f, r, fs)$ can be regarded as a
 kind of general inductive tactics. That is is to say, a property $f$ in $fs$ holds at a state $s$, and  $\mathsf{invHoldRule}(s, f, r, fs)$, then
 $f$ holds at the post-state $s'$ after a rule $r$ is executed.

\begin{lemma} \label{invHoldRuleIsIndut}
  Let $s$ and $s'$ be two states and $r$ be a rule s.t.  $s\overset{r}{\rightarrow } s'$, if  $s \models f$   and $\mathsf{invHoldRule}(s, f,r,fs)$ for any $f \in fs$,  then for any $f \in fs$, $s' \models f$.
\end{lemma}

Instead of using the general induction rule (or proving the general causal relation $\mathsf{invHoldRule}(s, f, r, fs)$), we classify it into    three special kinds of causal relations $\mathsf{invHoldRule}-{1-3}(s, f, r, fs)$ because the latter are more-fine grained and easy to be done by a theorem prover. In fact, because each one of $fs$ holds at $s$, they can be regarded as induction hypothesis,  $\mathsf{invHoldRule}-{1-3}(s, f, r, fs)$ has told the theorem prover how to use the premise in the induction hypothesis to prove the precondition $preCond(f,\mathsf{act}(r))$. We will illustrate this later.


With the $\mathsf{invHoldRule}$ relation, we define a consistency relation $\mathsf{consistent}( invs,inis, rs)$ between a protocol $(inis,rs)$ and a set of invariants $invs=\{inv_1,\ldots, inv_n\}$.

\begin{definition}
A relation  $\mathsf{consistent}( invs,inis, rs)$ holds if the following conditions hold:
\begin{enumerate}
\item for any formula $inv\in invs$ and $ini\in inis$ and any state $s$,
$s \models ini$ implies $s \models inv$;
\item for any formula $inv\in invs$ and rule  $r \in rs$ and any state $s$,  $\mathsf{invHoldRule}(s, inv, r, invs   )$
\end{enumerate}
\end{definition}

%Intuitively, the above definition specifies that:
%\begin{itemize}
%\item For any invariant $inv \in invs$,
%initializing predicate $ini \in ini$, and state $s$, if $ini$ is
%evaluated true at state $s$, then $inv$ is also evaluated true at
%state $s$.

%\item For any invariant $inv \in invs$, $r$ in the rule set
%$rs$, either one of the following five types of relation holds,
%i.e., $\mathsf{invHoldRule_{1-3}}inv r$.

%\end{itemize}

%For instance,
Let us use some examples to illustrate the above definitions. Next example gives a set of auxiliary invariants, in which the initially invariant $mutualInv$ is.

\begin{example}\label{example2}
Let us define

\begin{specification}
invOnXC(i)  $\equiv$ $\negc$(x $\doteq$ true $\andc$ n[i]$\doteq$ C)   \\

invOnXE(i)   $\equiv \negc$ (x $\doteq$ true$\andc$ n[i] $\doteq$ E)  \\


aux$_1$(i,j)   $\equiv \negc$ ( n[i]$\doteq$ C$\andc$n[j] $\doteq$ E)  \\

aux$_2$ (i,j) $\equiv \negc$  ( n[i]$\doteq$ E$\andc$n[j]$\doteq$ E)\\

  pinvs(N)$\equiv$ \{f. $\exists$ \iInv1 \iInv2. \iInv1 $\le$ N $\wedge$ \iInv2 $\le$ N $\wedge$\\
   \iInv1 $\ne$ \iInv2 $\wedge$   \\
   f =mutualInv   \iInv1 \iInv2) \\
 $ \vee(\exists$ \iInv1. \iInv1 $\le$ N $\wedge$  f =invOnXC  \iInv1)   \\
$\vee(\exists$ \iInv1. \iInv1 $\le$ N $\wedge$  f= invOnXE \iInv1)    \\
$\vee(\exists$ \iInv1 \iInv2. \iInv1 $\le$ N $\wedge$ \iInv2 $\le$ N $\wedge$ \iInv1 $\ne$ \iInv2 \\
$\wedge$ f =  aux1  \iInv1 \iInv2) \\
$\vee(\exists$ \iInv1 \iInv2. \iInv1 $\le$ N $\wedge$ \iInv2 $\le$ N $\wedge$ \iInv1 $\ne$ \iInv2 \\
$\wedge$ f =  aux2  \iInv1 \iInv2) \}.

\end{specification}
\end{example}
In Example \ref{example2}, $\mathsf{invOnXC}(i)$($\mathsf{invOnXE}(i)$) specifies that the variable $x$ will be set to be false once node $i$ is in or exiting the critical section. $\mathsf{aux_1(}i,j)$ says that node $i$ and $j$ can not be in and exiting the critical section at the same time. $\mathsf{aux_2}(i,j)$  that node $i$ and $j$ can not exit critical section at the same time.

Example \ref{example3} illustrates the three kinds of causal relations (or inductive tactics).

\begin{example}\label{example3} Suppose that $inv=\mathsf{mutual} (i_1,i_2)$, $r=\mathsf{crit}(iR_1)$, $rs= \mathsf{pinvs} (N)$, and     $i_1 \leq N$, $i_2 \leq N$, $i_1 \neq i_2$, and $iR_1 \leq N$.

\begin{itemize}
%\item  $\mathsf{invHoldRule_1 }(s,\mathsf{invOnXC}( 1),
%\mathsf{crit}(1))$ because $\mathsf{preCond}(\mathsf{act}(\mathsf{crit}(1)),
% \mathsf{invOnXC} (1))=\negc (\mathsf{flase}\eqc\mathsf{true}\andc \mathsf{C}\eqc\mathsf{C})$ which is a tautology;\\

%\item  $\mathsf{invHoldRule_2 }(s,\mathsf{mutual}(
%1,2), \mathsf{try}(3))$ because $\mathsf{preCond}(\mathsf{act}(\mathsf{try}(3)),
 %\mathsf{mutual}( 1,2))=\mathsf{mutual} (1,2)$;

% \item   $\mathsf{invHoldRule_3 }(s,\mathsf{mutual} (1,2), \mathsf{crit}(1),(\mathsf{pinvs} (N))$.
%   because
% $\mathsf{invOnXC}( 2) \in \mathsf{pinvs} (N)$, $\mathsf{preCond}(\mathsf{act}(\mathsf{crit}(1)),
% \mathsf{mutual} (1,2))=\negc (\mathsf{C}\eqc\mathsf{C}\andc n[2]\eqc\mathsf{C})$,
% and $  s \models \mathsf{guard}(\mathsf{crit}(1)) \andc \mathsf{invOnXC}(2)$ implies
% $ s \models \negc (\mathsf{C}\eqc\mathsf{C}\andc n[2]\eqc\mathsf{C})$. Notice that  the guard condition of
% $\mathsf{crit}(1)$ is $n[1]\eqc T \andc x\eqc\mathsf{true}$.

% \item

\item     $\mathsf{invHoldRule_2 }(s,inv,r)$, where   $i_1 \neq iR_1$, and $i_2 \neq iR_1$, since $\mathsf{preCond}(\mathsf{act}(r),inv)=inv$.


 \item   $\mathsf{invHoldRule_3 }(s,inv,r,invs)$, where  $i_1 = iR_1$.
  Since
 $\mathsf{invOnXC}( i_2) \in invs$, $\mathsf{preCond}$\ $(\mathsf{act}(r),inv)=\negc (\mathsf{C}\eqc\mathsf{C}\andc n[i_2]\eqc\mathsf{C})$,  $\mathsf{invOnXC}( i_2) \andc \mathsf{pre}(\mathsf{crit}(iR_1)) \longrightarrow \negc n[i_2]\eqc\mathsf{C}$, and $s \models \neg n[i_2]\eqc\mathsf{C}$  implies  $s \models \negc (\mathsf{C}\eqc\mathsf{C}\andc n[i_2]\eqc\mathsf{C})$.


\item   $\mathsf{invHoldRule_3 }(s,inv,r,invs)$, where $i_2 = iR_1$.  Since
 $\mathsf{invOnXC}( i_1) \in invs$, $\mathsf{preCond}$\ $(\mathsf{act}(r),inv)=\negc (n[i_1]\eqc\mathsf{C}\andc \mathsf{C}\eqc\mathsf{C})$, and $\mathsf{invOnXC}( i_1) \andc \mathsf{pre}(\mathsf{crit}(iR_1)) \longrightarrow \negc n[i_1]\eqc\mathsf{C} $, and $s \models \neg n[i_1]\eqc\mathsf{C}$  implies  $s \models \negc ( n[i_1]\eqc\mathsf{C}\andc \mathsf{C}\eqc\mathsf{C})$. %Since
 %$\mathsf{invOnXC}( i_1) \in \mathsf{pinvs} (N)$, $\mathsf{preCond}(\mathsf{act}(\mathsf{crit}(iR_1)),
% \mathsf{mutual} (i_1,i_2))=\negc (\mathsf{C}\eqc\mathsf{C}\andc n[i_1]\eqc\mathsf{C})$.
% where $i_1 \neq i_2$,  $i_1 \neq iR_1$, and $i_2 \neq iR_1$.
  % because
 %$\mathsf{invOnXC}( i_2) \in \mathsf{pinvs} (N)$, $\mathsf{preCond}(\mathsf{act}(\mathsf{crit}(iR_1)),
 %\mathsf{mutual} (i_1,i_2))=\negc (\mathsf{C}\eqc\mathsf{C}\andc n[i_2]\eqc\mathsf{C})$,
 %where $i_1 \neq i_2$, and $i_2 = iR_1$.% $  s \models \mathsf{guard}(\mathsf{crit}(i_1)) \andc \mathsf{invOnXC}(i_2)$ implies
% $ s \models \negc (\mathsf{C}\eqc\mathsf{C}\andc n[2]\eqc\mathsf{C})$. Notice that  the guard condition of
% $\mathsf{crit}(1)$ is $n[1]\eqc T \andc x\eqc\mathsf{true}$.
 \end{itemize}

 From the above discussion, we can conclude $\mathsf{invHoldRule_3 }(s,inv,r,invs)$.
\end{example}

In example \ref{example3},  $\mathsf{invHoldRule_1 }(s,inv,r)$ and   $\mathsf{invHoldRule_2 }(s,inv,r)$ can be checked \emph{automatically} by a theorem prover. $\mathsf{invHoldRule_3 }(s,inv,r,invs)$ can also be checked \emph{automatically}  if the proper formula $f'$ such as $\mathsf{invOnXC}( i_2) $ can be provided for the instantiation for the existence quantifier. We need notice that two things are needed to be done to guide a theorem prover to automatically assist us to check  $\mathsf{invHoldRule }(s,inv,r,invs)$: (1) the case splitting which is decided by comparison between rule parameter $iR_1$ and invariant parameters $i_1$ and $i_2$; (2) the choice among the three kinds of causal relations to prove in each subcase. Therefore

  %It is not diffcult to verify
%$\mathsf{consistent}~ (\mathsf{pinvs}~ N) ~(\mathsf{pini}~N)~
%(\mathsf{prules}~N)$ also holds.
We can check the consistent relation holds between the auxiliary invariant set example \ref{example1} and the protocol initial predicate and rules of the mutual exclusion protocol.
\begin{lemma} \label{pinvsetIsConsistent}
  If $ P=(pini(N),prules(N))$ is the protocol listed in example \ref{example1},  and $pinvs$ is the set of formulas in example \ref{example2},   then $\mathsf{consistent}(pinvs,pini(N),prules(N))$.
\end{lemma}
\begin{proof} By unfolding the definition of $\mathsf{consistency}$, we need
to verify that parts (1) and (2) of
 the $\mathsf{consistency}$ relation  hold.
For (1), the proof is rather straightforward.  We only do case analysis on the form of a formula $f$ in $pinvs$, and check $pini(n)$ implies $f$.  For instance,
consider the case where $inv= \mathsf{mutualInv}( i_1, i_2)$ for some $i_1$ and $i_2$, where
 $i_1\le N$, $i_2\le N$, and $i_1\neq i_2$. We can
 conclude that $s\models  n[i_2]\eqc I$ if $s\models pini(N)$,
thus $s\models inv$ holds. The other invariants can be
proved similarly.

\noindent For (2), we do case analysis on the form of a formula $f$ in $pinvs$, and then on the form of $r$ in $prules(N)$, notice that both $f$ and $r$ are parameterized, then we do case analysis by comparing indices in $f$ and $r$, we need show $\mathsf{invHoldRule_{1-3}}$ holds. Example \ref{example3} has shown a typical case where $inv=\mathsf{mutualInv} (\iInv_1, \iInv_2)$, and $r=\mathsf{crit }(iR)$, where $iR\le N$, $\iInv_1 \le N$, and $\iInv_2 \le N$.
%\qed
\end{proof}

Let us     analyze the complexity of part (2) of the proof in Lemma \ref{pinvsetIsConsistent}.  For one rule, we need to analyze three  cases for each invariant $inv$ in
$\mathsf{mutualInv}$, $\mathsf{aux_1}$, and
$\mathsf{aux_2}$, and two cases for the others. There are four rules,
%in $\mathsf{invOnX1}$ and $\mathsf{invOnX2} $.
thus we need in total
$4\times (3 \times 3 +2\times 2)=52$ cases. Note that the  protocol
is simple because it has only 4 rules. Let alone a moderate
protocol such as German (15-rules) and FLASH with about 50 rules. This complexity illustrates the difficulty of parameterized verification of
cache coherence protocols, which also accounts for the reason why there is seldom successful case study in applying a general theorem
 prover to verify even a moderate protocol such as German protocol.

For any invariant $inv \in invs$, $inv$ holds at a reachable state $s$  of a protocol $P=(ini,rs)$  if the consistency relation
$\mathsf{consistent}( invs, inis, rs)$ holds. % and $s$ is a reachable state of the protocol $P=(ini,rs)$, \cai{then?}
%$inv$ holds for any reachable state $s  \in
%\mathsf{reachableSet}( ini, rs)$.
The following lemma formalizes the essence of the aforementioned causal relation, and is called consistency lemma.

\begin{theorem}\label{consistentLemma}%[(consistency lemma)]
 If $P=(ini,rs)$, $\mathsf{consistent}( invs, ini, rs)$, and $s  \in \mathsf{reachableSet}(P)$, %  $\isasymrbrakk\Longrightarrow$
 then   for all $inv$ s.t. $inv \in invs$, $s \models inv $.
\end{theorem}

Theorem \ref{consistentLemma} is our main tool to prove that any property $f$ in a formula set $invs$ is an invariant for a protocol $(ini,rs)$. It has eliminated the need of directly use of usual induction proof method. We only check the causal relation between $f$ and $r\in rs$ by case analysing on $f$ and $r$.

Now we apply the consistence lemma to prove that the mutual exclusion property holds for each reachable state of the mutual-exclusion protocol. %Let us recall example \ref{example1} and  \ref{example2}.
In order to prove the mutual-exclusion property, we prove a more general result:
\begin{lemma} \label{caseSimp}
  If $ P=(pini(N),prules(N))$ is the protocol listed in example \ref{example1},  $s \in \mathsf{reachableSet}(P)$, and $0<N$, and $pinvs$ is the set of formulas in example \ref{example2},   then for any $inv$ s.t. $inv \in pinvs(N)$, $s\models inv $.
\end{lemma}

\begin{proof} By theorem\ref{consistentLemma}, we only need
to check that   $\mathsf{consistent}(pins(N),pini(N),prules(N))$ relation  holds. This can be immediately obtained by lemma \ref{pinvsetIsConsistent}.
 \end{proof}

In order to  apply   theorem \ref{consistentLemma} to prove that a given parameterized property $f$ (e.g., the mutual exclusion property) is an invariant for a parameterized  protocol (e.g., mutual-exclusion protocol), we need to solve two problems.
\begin{enumerate}
\item We need to construct a set of auxiliary invariants $invs$ which contains $f$ and satisfies  $\mathsf{consistent}( invs, inis, rs)$.  Constructing a set of auxiliary invariants is the central problem in the filed of parameter verification.

\item   After applying  theorem \ref{consistentLemma}, we  decompose the original problem of invariant checking into that of checking that some  causal relation between some $f\in invs$ and $r \in rs$. Then we need three levels of case analysis: the first is on the form of $f$, the second is on  and $r$, and the last is  case analysis by comparing on the rule parameters in $r$ and invariant parameters in $f$, which has been illustrated in the proof of Lemma \ref{pinvsetIsConsistent} and Example \ref{example3}, at last the choice among the three kinds of causal relations is needed in each subcase.  How to generate enough information to construct a proof which consists of the above case analysis and choices is our second problem.
\end{enumerate}

\forget{\begin{figure}[htbp]
\centering %
%\vspace{-0.8cm}
\includegraphics[width=0.5\textwidth]{paraVerifier.pdf}
\vspace{-0.6cm}
\caption{The workflow of {\sf paraVerifier} \label{fig:arch}
}
\end{figure}
}%\vspace{-0.8cm}

Notice that the two problems are w.r.t. a parameterized property and a parameterized protocol instance. Now we first turn to a simpler concrete property and a concrete protocol instance, and try to solve the two problems w.r.t. concrete ones. Here the concrete property is obtained by instantiating the parameters with concrete indices, and by fixing the parameterized size with concrete value. For instance,   Namely, $\mathsf{mutualInv}(i,j)$ (
  $\negc$ (n[i]$\eqc$ C $\andc$ n[j]$\eqc$ C) and $(pinit(3),prules(3))$ are concrete. If we can find answers to the two problems for the concrete ones, then we generalize them into  answers to the two problems for the parameterized ones.

\section{An Overview of Our Verification Strategy}
Due to  theorem \ref{consistentLemma}, the original problem of invariant checking boils down to  checking causal relation   some  causal relation between some $f\in invs$ and $r \in rs$, and different kinds of causal relation among hold in different cases which are split by parameter comparison scheme between rule parameters and formula parameters. Notice that the comparison scheme is only determined by the number of rule parameters and formula parameters. For instance, if the number of rule parameters and formula parameters are 1 and 2 respectively, the splitted cases are $iR_1=i_1$, or $iR_1 =i_2$, and $iR_1 \neq i_1 \wedge iR_1 \neq i_2$.

In order to know which kind of causal relation hold, we can select a special instance of the generalized symbolic case, and compute the precondition of $f$ w.r.t. $act(r)$, then test in a concrete protocol instance which kind of causal relation hold among $f$, $r$, and the current set of invariant formulas $invs$. For instance, we can instantiate both  $iR_1$ and  $i_1$ with 1, $i_2$  with 2 test the case $iR_1=i_1$. If the one of causal relation $invHoldRule_{1-2}$ holds, then only the causal relation is recorded. Otherwise, we need consider two cases: (1) there is a formula in $invs$ to make $invHoldRule_{1-2}$ to hold; (2) there is not a formula in $invs$  $invHoldRule_{1-2}$ to hold. In the second case, we   need construct a new invariant formula $f'$ which   makes the relation $\mathsf{invHoldRule}_3(f,r,invs \cup \{f'\})$ to hold. The coupling process of checking causal relation and generating new invariants is not finished until no new invariant formula can be found. The returned result is a table which records all the causal relation among the newly found invariant formulas and concrete rules and the set of auxiliary invariant formulas.

Basing on the table recording the information on causal relation, we generalize it into a parameterized version. Each line of table is associated with a symbolic formula to indicate a case by comparison between the symbolic parameters of a parameterized rule  and those of a parameterized invariant formula. Furthermore, a formal proof script is generated according the table on the generalized information.



In short,
\begin{enumerate}
\item Due to symmetry, we can check in a concrete protocol instance the causal relation between a concrete rule and a concrete invariant formula whose concrete parameters.

\item For each cases, we select a   special instance of the case to check.

\item Checking the causal relation is naturally coupled with finding new auxiliary invariants.

\item Generalization is needed to extend the searching results.


\end{enumerate}

\forget{ Our solution
Our solutions to the two problems are shown in Fig. \ref{fig:arch}:
Given a protocol,  \texttt{invFinder} finds all the necessary concrete auxiliary invariants from a small instance of the protocol in Murphi. This step solves the first  problem.
 A table {\tt protocol.tbl} is worked out  to store the set of concrete invariants and
 causal relations, which are then  used by {\tt proofGen} to
create an Isabelle proof   script which models and verifies the
protocol in a parameterized form. In this step, concrete invariants
are generalized into a parameterized form, and accordingly
concrete causal relations are adopted to create parameterized
proof commands which essentially proves the existence of the
parameterized causal relations. This solves the second problem.  At last, the Isabelle proof script is
fed into Isabelle to check the correctness of the protocol.}
%Consistency lemma has eliminated the need of directly use of usual induction proof method. Applying it, we  decompose the problem of invariant checking into that of checking the causal relation between $f$ and $r$ by case analysing parameters of a rule and an invariant. As shown in  and such a causal relation checking is within the ability of an automatical tactic provided by a theorem prover like Isabelle. Due to the uniform style of checking causal relation, it is also feasible to generate a proof of such a style by an external proof generator. However, as shown in Example \ref{example2}, the   three items shows that there are three subcases where we compare rule parameter $iR_1$ with formula parameters $i_1$ and $i_2$, different kinds of causal relations hold between rule $\mathsf{crit}~iR_1$ and invariant $\mathsf{mutualInv}~i_1~i_2$. Only if a proof script contains enough information on the case splitting and  which kind of causal relation to be checked in each case, Isabelle can help us to automatically  check whether the kind of causal relation hold in the case. How to provide these key proof information is a central problem in work of both {\sf invFinder} and {\sf proofGen}.
%\vspace{-0.6cm}

\section{Searching Concrete Auxiliary Invariants with Causal Relations}\label{sec:invFinder}
Given a parameterized protocol $P$ and a property set $F$ containing concrete invariant formulas each which is an instantiation of a parameterized invariant formula we want to initially verify,  $\mathsf{invFinder}$ in Algorithm \ref{alg:invfinder} aims to find useful auxiliary invariants and causal relations which are capable of proving any element in $F$. For instance, let $ P=(pini(N),prules(N))$ to be the mutual exclusion protocol listed in example \ref{example1}, $f=\mathsf{mutualInv}(1,2)$, and $F=\{f\}$.

 A set $A$ is used to store all the invariants found up to now, and is initialized as  $F$.  A relation table $tbl$ is used to record the causal relation between a parameterized rule in some parameter setting and a concrete invariant. Initially $tbl$ is set as NULL. A queue  $newInvs$ is used to store new invariants which have not been checked,  and  is initialized as  $F$.
$\mathsf{invFinder}$  works iteratively in a semi-proving and semi-searching way. In each iteration, the head element $cf$ of $newInvs$ is popped,  then $\mathsf{Policy}(r,cf)$  generates groups of parameters $paras$  according to $r$ and $cf$ by some policy. For each parameter $para$ in $paras$,   it is applied to instantiate $r$ into a concrete rule $cr$. This policy should guarantee that each case split by the aforementioned parameter comparison scheme should be sampled.  Here  $\mathsf{apply}(r,para)=r$ if $r$ contains no parameters and $para=[]$; otherwise $\mathsf{apply}(r,para)=r(para_{[1]},..., para_{[|para|]})$. Then $\mathsf{coreFinder}(cr,  cf, A)$ is called to check
 which kinds of causal relation exists between $cr$ and $f$; if there is such one relation item, the relation item $rel$ and a  formula option $newInvOpt$ is returned; otherwise a run-time error occurs in  $coreFinder$, which indicates no proof can be found. A tuple $<r, para, cf, rel>$ will be inserted into $tbl$ to indicate some causal relation $rel$ exits among $cr$ and $cf$and $f \cup A$; If the formula option $newInvOpt$ is $\mathsf{NONE}$, then no new invariant formula is generated; otherwise $newInvOpt=\mathsf{Some}(cf')$ for some formula $cf'$, then  $\mathsf{get}(newInvOpt)$ returns $cf'$, and the new invariant formula $cf'$ will be pushed into the queue $newInvs$ and inserted into the invariant set $A$.  The above searching process is executed until $newInvs$ becomes empty.  At last, the table $tbl$ and the augment invariant set $A$ are returned.


\SetAlFnt{\small}

%\vspace{-0.8cm}

\begin{algorithm}

\caption{Algorithm: $invFinder$\label{alg:invfinder}}

\KwIn{Initially given invariants $F$, a protocol $\mathcal{P}=<I,R>$ }

\KwOut{$tbl$ : a table which represent causal relations between concrete rules and invariants: $A$: a set of concrete invariant formulas}

{
    $A\leftarrow F$;

    $tbl \leftarrow []$;

    $newInvs \leftarrow F$;

    \While{$newInvs \neq []$ }
    {
   $ cf \leftarrow \mathsf{hd}(newInvs)$; $ newInvs \leftarrow \mathsf{tl}(newInvs)$;

   \For {$r \in R$}
   { $paras \leftarrow \mathsf{Policy}(r,cf)$;

      \For {$para \in paras$}
     {$cr \leftarrow \mathsf{apply}(r,para)$;

       $newInvOpt,rel \leftarrow \mathsf{coreFinder}(cr,  cf, A)$;

        $tbl \leftarrow tbl @[<r, para, cf, rel>]$;

       \If{$newInvOpt \neq NONE$}
        {$newInv \leftarrow \mathsf{get}(newInvOpt)$\;
        $newInvs\leftarrow newInvs@[newInv]$\;
        $A\leftarrow A \cup \{{newInv}\}$\;
        }

     }
   }
  }
\Return $A$, $tbl$\;
}

%}

\end{algorithm}
%\vspace{-0.8cm}

%\vspace{-0.8cm}


%instantiates the parameterized rule $r$ into a set of concrete rules $crs$ with different groups of concrete parameters Each rule in $crs$  represents a pattern w.r.t. the relationship (equivalent or not) between concrete rule parameters and invariant parameters. Such a parameter instantiation to the rule $pr$ can be generalized to a symbolic predicate {\bf which is according with a case (what do you mean?)}, as shown in Example \ref{example2}. Therefore, a good parameter instantiation policy should guarantee the completeness. Namely, each of subcases in the needed case-splitting should be covered by a concrete rule which is instantiated from $pr$ according to the policy.

%({\bf is this also accomplished by $coreFinder$? })\\
% \lyj{$CoreFinder$ only deal with a concrete rule $cr$ and a concrete invariant}

%For a rule $cr \in crs$ ({\bf for a rule and an invariant?}), {\sf invFinder} tries to prove that some causal relation exists between the rule and an invariant; if there is no such an invariant
%in the current invariant set, {\sf invFinder} automatically generates a new auxiliary invariant  and records the corresponding causal
%relation information between the current rule and invariant. %Note that the same causal relation should  hold between the generalized rule and invariant.
%Whenever a new invariant is generated, it is pushed into $newInvs$.  The above searching process is executed until $newInvs$ becomes empty. This searching process is a core algorithm of {\sf invFinder}, and we will describe it in Section 4.2, after introducing the parameter instantiation policy.


In Algorithm \ref{alg:invfinder},  $\mathsf{Policy}(r,cf)$ analyzes the number of the formal parameters of $r$ and that of actual parameters $cf$ respectively, and generates groups of concrete parameters, each of which will be used to instantiate $r$ into a concrete rule $cr$. The core invariant searching function $\mathsf{coreFinder}(cr,cf,A)$ returns the causal relation among $cr$ and $cf$and $A$. They will be illustrated in Section \ref{sec:parameterGenPolicy} and \ref{sec:coresearchingAlgorithm}.

%\caicomment{The algorithm pseudo code is good. Try to make the description of invFinder consistent with pseudo code, and as simple as possible.}

\vspace{-0.5cm}

\subsection{Parameter Generation Policy}\label{sec:parameterGenPolicy}
Let $cf$ to be a special instance of some parameterized formula $f$ s.t. $cf=apply(f,idp(|apOfCForm(cf)|))$.  Recall that the aim of our policy is to compute groups of rule parameters to instantiate a parameterized rule into a set of concrete rules.  Combination of  any group of the above generated rule parameters with the actual parameters occurring in the concrete invariant formula $cf$ will be a special instantiation of some case where we compare symbolic parameters in $r$ and those in $f$. Furthermore, each of the subcases should be sampled, which are partitioned by the aforementioned parameter comparison scheme.

Suppose that the number of actual parameters occurring in $cf$ is $n$, and that of formal parameters occurring in $r$ is $n'$, we choose $n'$--element subset among $\{1,...,(n+n')\}$ to instantiate $r$. Namely a $n'$-permutation of $n+n'$, $para$ will be regarded as a group of rule parameters to instantiate $r$.  Furthermore, if $n'>0$ and $i<n'$, and $para[i]>n$, then $para[i]$ will not equal to any actual parameters in $cf$. Thus we don't care which value $para[i]$ is if we can guranttee $para[i]$ is. In the sense of sampling cases, $para $  is the equivalent to $para' $ if $para' $ is the updated result by only replacing $para[i]$ with another index $j$ s.t. $j>n$. For instance, let $n=n'=2$, then $[1,2]$, $[2,3]$, $[2,4]$ are groups of rule parameters to instantiate $r$. $[2,3]$ and  $[2,4]$ are equivalent to each other in the sense of sampling cases. Thus, if we have used $[2,3]$ to instantiate $r$, we need not use $[2,4]$ to do so.

%In order to formulate our parameter generation policy, we introduce the concept of permutation modulo to symmetry relation $\simeq_m^n$,  and a quotient set of $\mathsf{perms}_{m}^{n}$ (the set of all $n$-permutations of $m$) under the  relation.  Here an $n$-permutation of $m$ is ordered arrangement of  an $n$--element subset of an $m$-element set $I=\{i. 0<i\le m\}$. We use a list $xs$ with size $n$ to stand for a $n$-permutation of $m$. For instance, $[1,2]$ is a 2-permutation of 3. $xs_{[i]}$ and $|xs|$  denote  the $i-$th element and the length of $xs$ respectively. If $xs_{[i]}=i$ for all $i \le |xs|$, we call it identical permutation. %, and sometimes is denoted by $1~ \mathsf{upto}~ n$ if $n=|xs|$.

In order to formulate our parameter generation policy, we define:

\begin{definition}\label{defFormulationPolicy}
Let $m$ and $n$ be two natural numbers, where $n \le m$,  $para$ and $para'$ are two lists which stand for two  $n$-permutations of $m$,
\begin{enumerate}
%\item
%$L \sim_m^n L' \equiv (|L| =|L'|=n) \wedge (\forall i. i<|L| \wedge L_{[i]} \le m-n \longrightarrow L_{[i]}=L'_{[i]}) $.

%\item $L \simeq_m^n L' \equiv L \sim_m^n L' \wedge   L' \sim_m^n L$.

%\item$[[L]]_{m}^{n} \equiv \{L'. L \in \mathsf{perms}_{m}^{n} \wedge L \sim_m^n L'\}$.

\item \label{defNormPara}$normPara(para,n)[i]=$\\
   \begin{numcases}{ }
   para[i] &   if $para[i] \le n$ \\
   n +1    & otherwise
\end{numcases}

\item  \label{defBisimilar} $para\sim_m^n para' \equiv$ $normPara(para,n)=normPara(para',n)$

\item $\mathsf{semiP}(m,n,S)\equiv (\forall  para \in \mathsf{perms}_{m}^{n} \exists  para' \in S. para \simeq_m^n para' ) \wedge (\forall  para\in S. \forall para'\in S. para \neq para' \longrightarrow  (para \not\simeq_m^n para' )$.   A set $S$ is called a quotient of the set $\mathsf{perms}_{m}^{n}$ under the relation $\simeq_m^n$ if    $\mathsf{semiP}(m,n,S)$.

\end{enumerate}
\end{definition}

In definition \ref{defFormulationPolicy}, \ref{defNormPara}  defines a   function $normPara(para,n)$ to normalize a group of parameters by uniformly replacing the $i$-th element with $n+1$ if it is greater than $n$. Naturally the aforementioned equivalence between two groups of parameters $para$ and $para'$ w.r.t. sampling is defined by the normalized form of them are the same. Basing on the relation $\sim_m^n$, we can define  a quotient of the set $\mathsf{perms}_{m}^{n}$ under the relation $\simeq_m^n$. Here a quotient of $\mathsf{perms}_{n+n'}^{n'}$ is the set of all groups of parameters to instantiate $r$ to check the causal relation between $r$ and $cf$ in the above paragraph.

\forget{
The definition of of relation $\simeq_m^n$ (item 1 and 2 in Definition 3) directly leads to the following lemma. %\caicomment{(Original version has a paragraph here to explain $L \simeq_{m+n}^n L' $. But the explanation is just a repetition of the below lemma while the lemma is more clear, from my viewpoint. So I delete them, and move the example downwards.)}

%According to the definition of of the relation $\simeq_m^n$, $L \simeq_{m+n}^n L' $ means that for any $0<i\le |L|$ and $0<j \le m$,
%if we compare any element $L_{[i]}$ with any $j\le m$, the comparison result is the same as that obtained by comparing $L'_{[i]}$ with $j$, namely
%$L_{[i]}=j$ if and only if $L'_{[i]}=j$ .
%For instance, let $L=[2,3]$ and $L'=[2,4]$, then $L \simeq_{4}^2 L' $. \cai{(should it be $\simeq_{6}^2$, since m+n=6 here)} This observation is formally captured by the following lemma. \cai{I simplify this paragraph, which focuses on the essential of $L \simeq_{m+n}^n L' $ }



\begin{lemma}\label{lemma:simeq1}%[(consistency lemma)]
If $L \simeq_{m+n}^n L' $, then for any $0<i\le |L|$, any $0<j \le m$, $L_{[i]}=j$ if and only if $L'_{[i]}=j$.
\end{lemma}

For instance, let $L=[2,3]$ and $L'=[2,4]$, then $L \simeq_{4}^2 L' $. %\caicomment{(should it be $\simeq_{6}^2$, since m+n=6 here)}
%\lyj{here is 4 ,not 6. Namely $m=4$,$n=2$. Thus $m-n=2$. Please recall Def 3, $L_{[1]}=2$, and $L_{[1]} \le 2$, thus $L_{[1]}'$ must be the same as $L_{[1]}$. But $L_{[2]}> 2$, we don not require $L_{[2]}' =L_{[2]}$.}
%\cai{Thanks to} Lemma \ref{lemma:simeq1},
Due to Lemma \ref{lemma:simeq1},
we can analyze a group of concrete parameters by analyzing only one of them as a presentative. Keeping this in mind, let us look at the following lemma, which together with Lemma \ref{lemma:simeq1} is the theoretical basis of our policy.


\begin{lemma}\label{lemma:simeqQuotinent}  Let $S $ be a set s.t.  $\mathsf{semiP}(m,n,S)$,
\begin{enumerate}
\item \label{complete}  for any $L \in \mathsf{perms}_{m}^{n}$, there exists a $L' \in S$ s.t. $L \simeq_m^n L'$.
\item \label{distinct} let $L \in S$, $L' \in S$, if $L \ne L'$, then there exists two indices $i \le m$ and $j \le n$ such that $L_{[i]}=j$ and $L'_{[i]}\ne j$.
\end{enumerate}
\end{lemma}



Lemma \ref{lemma:simeqQuotinent} shows \ref{complete}) completeness of $S$ w.r.t. the set $\mathsf{perms}_{m}^{n}$ under the relation $\simeq$, \ref{distinct})  the distinction between two different elements in $S$. Therefore, $S$ has covered all analysing patterns according to the aforementioned comparing scheme between elements of $L$ with numbers $j<n-m$. Moreover, the case patterns represented by different elements in $S$ are different from each other. This fact can be illustrated by the following example.

%\begin{itemize}
\item $LR=[1]$: it is a special case where $LR_{[1]}=1 $;
\item $LR=[2]$: it is a special case where $LR_{[1]}=2 $;
\item $LR=[3]$: it is a special case where $LR_{[1]}\ne 1$ and $LR_{[1]}\ne 2$.

}

\begin{example}\label{exampleSemip}
Recall that the number of actual parameters occurring in $cf$ is $n$, and that of formal parameters occurring in $r$ is $n'$,
\begin{enumerate}
\item Let $n=2$, $n'=1$, $paras=\{[1],[2],[3]\}$, and $paras$ is the quotinent set of  parameter groups to instantiate $r$;
\item Let $n=2$, $n'=2$, $paras=\{[1,2],[1,3],[2,1],[2,3],$\\$[3,4]\}$, and $paras$ is the quotinent set of  parameter groups to instantiate $r$;
%\end{itemize}
\end{enumerate}
\end{example}

Now we formally define the symbolic case which is generalized from a group of rule parameters if we compare it with an identical permutation with length $n$ which represents a group of invariant formula parameters.

\begin{definition}
Let $para$ be a permutation, $0<n$, we define:

\noindent $\mathsf{caseGen}([],n,pos)= []$\\
$\mathsf{caseGen}(i\#para£¨n,pos)$=
   \begin{numcases}{ }
   (\iR_{pos}=\iInv_i)\wedge \mathsf{caseGen}(para£¨n,pos+1)  &   if $i\le n$ \\
 (\bigwedge^n_{j=1}\iR_{pos} \neq \iInv_j)\wedge \mathsf{caseGen}(para£¨n,pos+1)   & otherwise
\end{numcases}

\end{definition}

Next example shows the meaning of $\mathsf{caseGen}$.
\begin{example}
Recall the example \ref{exampleSemip},
\begin{enumerate}
\item $\mathsf{caseGen}([1],2,1)=\iR_{1}=\iInv_1$
\item $\mathsf{caseGen}([3],2,1)=\bigwedge^2_{j=1}\iR_{i} \neq \iInv_j)$
\item  $\mathsf{caseGen}([1,3],2,1)=\iR_{1}=\iInv_1\bigwedge^2_{j=1}\iR_{2} \neq \iInv_j)$
%\end{itemize}
\end{enumerate}
\end{example}

\forget{
Note that the above cases are mutually disjoint, and their disjunction  is true.

%Consider  natural numbers $m$ and $n$, computing a quotient of $\mathsf{perms}_{m}^{n}$ can be implemented by an algorithm $\mathsf{cmpSemiperm}$. Roughly speaking, $\mathsf{cmpSemiperm}$ firstly computes the set $\mathsf{perms}_m^n$, and push elements of it into a queue $S_0$, and select elements of $S_0$ into a set $S$. Initially $S$ is set empty. the head element of $S_0$ is pop into $L$, then $L$ will be checked whether there is an element $L'$ in $S$ s.t. $L\simeq_m^n L'$. If  yes, then $L$ will be discarded, else $L$ is inserted into $S$. This procedure is repeated until $S$ is empty. Finally $S$ will be returned. The detail of $\mathsf{cmpSemiperm}$ can be found in \cite{}.

%\caicomment{why introduce the following definition, need a guide for reader. E.g, we use normalized invariant as presentative of a group of invariants? }
%\lyj{this is a key problem, I revise my definition according to your comments}

In Algorithm \ref{alg:invfinder}, a concrete formula $cinv$ is poped from the queue $newInvs$, which can be seen as a normalized instantiation of some parameterized formula $pinv$. % A normalized instantiation can be seen as a representative of all instantiations of $pinv$.  For a parameterized rule $r$ and the  parameterized invariant $pinv$, we only probe  causal relations between some rule instances of $r$  and $cinv$.  Here a rule instance is obtained by instantiating $r$ with a parameter group $para$    in $paras$, which is generated according to the parameter generation policy.  A symbolic causal relation between $r$ and $pinv$ in a symbolic case can be generalized from a concrete causal relation existing between a concrete rule instance and the normalized invariant $cinv$.  Therefore $para$  can be used to derive a symbolic predicate such as  $i_1 \neq iR_1$, and $i_2 \neq iR_1$,  as shown in Example \ref{example2}.  Such a predicate  formulates a case  of comparing between rule parameters and invariant formula parameters. %A good parameter generation policy should guarantee the completeness. Namely, each of subcases in the needed case-splitting of the above parameters  comparing should be covered by the derivation of an element in the generated paramter groups $paras$.

\begin{definition}
A  concrete invariant formula $cinv$ is normalized w.r.t a parameterized invariant $pinv$ if  there exists no array variable in $cinv$ and $pinv=cinv$ or there exits an identical permutation $LI$ with $|LI|>0$ such that $cinv=pinv(1,...~|LI|)$;

\end{definition}


\begin{definition}
Let $para$ be a permutation, $0<n$, we define:

\noindent $caseGen([],n,pos)$= []\\
$caseGen(i\#para£¨n,pos)$=
   \begin{numcases}{ }
   (\iR_{pos}=\iInv_i)\wedge caseGen(para£¨n,pos+1)  &   if $i\le n$ \\
 (\bigwedge^n_1\iR_{pos} \neq \iInv_j)\wedge caseGen(para£¨n,pos+1)   & otherwise
\end{numcases}

\end{definition}

Any normalized $cinv$ containing array variables is obtained by instantiating a parameterized invariant $pinv$ with a parameter list which is an identical permutation $LI$ (i.e., the $j^{th}$ parameter is $j$ itself $LI_{[j]}=j$). Thus, consider a list of parameter $LR$ which is used to instantiate a parameterized rule $pr$, we  have $LR_{[i]}=j$ (or $LR_{[i]}\ne j$) is equivalent to $LR_{[i]}=LI_{[j]}$ (or $LR_{[i]}\ne LI_{[j]}$), %\lyj{my correction}{\bf[what is LR, you only use it in an example, need to define it clearly in this paragraph] },
which is a factor to specify a case by comparing $LR_{[i]}$ with $LI_{[j]}$ .  %All the auxiliary invariant formulas will be in a normalized form, and checked with any parameterized rule whether some kind of causal relation hold between them.


%{\bf Our Parameter Instantiation Policy:}
Let $cinv$  be a normalized concrete invariant w.r.t. a parameterized invariant $pinv$, $pr$ be a parameterized rule, $m$ be the number of actual parameters occurring in $cinv$, and $n$  be the number of formal parameters occurring in $pr$,  our policy is to compute a quotient of $\mathsf{perms}_{m}^{n}$, denoted as $\mathsf{cmpSemiperm}(m+n,n )$, and use elements of it as a group of parameters to instantiate $pr$ into a set $crs$ of concrete rules, which is shown in Algorithm \ref{alg:computeSemiPerms}.}

%\footnote{the details of computing $\mathsf{cmpSemiperm}(m+n,n )$ can be found in \cite{LiCache16}.}

In the end of this section, we give an algorithm to compute a quotinent set of $\mathsf{perms}_{m}^{n}$.
\begin{algorithm}
\caption{Computing a quotient of $\mathsf{perms}_{m}^{n}$: $cmpSemiperm$ \label{alg:computeSemiPerms}}%\label{alg:invfinderII}

\KwIn{$m$, $n$     }

\KwOut{A list of permutations $L$}

{
    $L_0\leftarrow \mathsf{perms}_m^n$;$L\leftarrow [] $\;
     \While{$L_0 \neq []$}
      {$para \leftarrow \mathsf{hd}(L_0)$;$L_0 \leftarrow \mathsf{tl}(L_0)$\;
       \If{$\forall para' \in \mathsf{set}(L).  para' \not\simeq_m^n para$}
        { $L\leftarrow L@[para]$\;}
      }
    \Return $L$\;
  %  }
}

%}

\end{algorithm}

Algorithm \ref{alg:computeSemiPerms} computes a quotient of $\mathsf{perms}_{m}^{n}$.   Firstly it set $L_0=\mathsf{perms}_m^n$,  then we fetch the head element of $L_0$ into $L$, and find whether there is an element $para'$ in $L$ s.t. $para\simeq_m^n para'$. If  yes, then $para$ will be discarded, else $para$ is inserted into $L$. This procedure is repeated until $L$ is empty. $\mathsf{Policy}(cf,r)$ is simply  $\mathsf{perms}_{n+n'}^{n'}$.

Let us return to the example of mutual-exclusion protocol, for the invariant $\mathsf{mutualInv}(1,2)$, according to $\mathsf{Policy}$, three groups of parameters [1], [2], [3] are used to instantiate $\mathsf{crit}$ respectively, each of the instantiation results will be used to check which kind of  causal relation exists between the derived concrete rule and $\mathsf{mutualInv}(1,2)$.  %Each of the three probed concrete causal relations will be used to generalized  into a symbolic causal relation existing between $\mathsf{crit}$ and $\mathsf{mutualInv}$ in a case formulated by a predicate comparing rule parameters and invariant parameters.  %A good parameter generation policy should guarantee the completeness. Namely, each of subcases in the needed case-splitting of the above parameters  comparing should be covered by the derivation of an element in the generated paramter groups $paras$.  In Section \ref{sec:generalization}, we will illustrate how three groups of parameters [1], [2], [3]  can be derived into three predicate which describes cases as shown in  Example \ref{example2}, which is a complete partition.

\subsection{Core Searching Algorithm}\label{sec:coresearchingAlgorithm}

%\vspace{-0.3cm}
For a concrete $cf$ and a concrete rule $cr$ and a set of formulas of found invariants $invs$,   Algorithm \ref{alg:coreFinder} checks the causal relation among $cf$ and $cr$ and $invs$, as well as find a new invariant if it is needed.
The algorithm returns a formula option and a causal relation item between $r$ and $inv$. A formula option value $\mathsf{NONE}$ indicates that no new invariant is found, while $\mathsf{SOME}(f)$ indicates a new auxiliary invariant $f$ is searched.

In order to illustrate $\mathsf{coreFinder}$, we also need introduce some functions on symmetry transformation to a formula. We define $\mathsf{indices}(f)$ to denote the list of concrete parameters occurring in $f$, which is arranged by the pre-order traversal of the syntax of $f$. A bijection $\pi$ induced from a list $L$ of mutually-different natural numbers is the mapping $\pi(i)=L[i]$ for any $i$ such that $i \le |L|$. As usual we use $\pi^{-1}$ to denote the inverse function of $\pi$. We use $\mathsf{induced}(L)$ to denote the bijection induced from a list $L$, $\mathsf{symApp}(\pi,f)$ to the formula obtained by simultaneously replacing all occurrences of each $i$ with $\pi(i)$. A formula $f$  is symmetric to another $f'$ if there is a bijection  $\pi(i)$ s.t.  $\mathsf{symApp}(\pi,f)=f'$.  A normalized form of a concrete formula $f$ is defined as $\mathsf{normalize}(f) \equiv \mathsf{symApp}((\mathsf{induced}(\mathsf{indices}(L))^{-1},f)$.

$\mathsf{coreFinder}$ needs to call two oracles. The first one, denoted by {\tt chk}, checks whether a concrete formula is an invariant. Such an oracle can be implemented by translating the formula into a formula in SMV, and calling SMV to check whether it is an invariant  in a given small reference instance of the protocol. If  the reference instance is too small to check the invariant, then the formula will be checked by Murphi in a big reference model.  The second oracle, denoted by $ \mathsf{tautChk}$, checks whether a formula is a tautology. Such a tautology checker is implemented by translating the formula into a form in the SMT (SAT Modulo Theories) format, and checking it by an SMT solver such as Z3.

%\vspace{-0.6cm}
\begin{algorithm}

\caption{Core Searching Algorithm: $\mathsf{coreFinder}$}\label{alg:coreFinder}

\KwIn{  $cr$, $cf$, $invs$   }

\KwOut{A formula  option $fOpt$, a new causal relation $rel$}

{
    $g\leftarrow \mathsf{pre}(cr) $\; %$S\leftarrow \mathsf{act}(cr)$\;

    $cf'\leftarrow \mathsf{preCond}(cf, \mathsf{act}(cr))$\; \label{line:preCondComp}

    \If{$cf=cf'$}
    {
    $relItem\leftarrow (cr, cf, invRule_2,-)$\;
    \Return $(\mathsf{NONE},  relItem )$\;
    }
    \ElseIf{$\mathsf{tautChk}(g\rightarrow cf')=true$}
    {
    $relItem\leftarrow (cr, cf, \mathsf{invRule}_1,-)$\;
    \Return $(NONE,  relItem )$\;
    }
    \Else
    {
    $candidates\leftarrow \mathsf{subsets}(\mathsf{decompose}(\mathsf{dualNeg}(cf')\andc g))$\;
    $newInv\leftarrow choose(chk,candidates)$\;
    $relItem\leftarrow (cr, cf, \mathsf{invRule}_3,newInv)$\;
    \If{$\mathsf{isNew}(newInv,  invs)$}
    {
    $newInv \leftarrow  \mathsf{normalize}(newInv)$\;%$ and insert it into the head of $newInvs$\;
    \Return $(\mathsf{SOME}(newInv),   relItem )$\;
    }
    \Else{\Return $(\mathsf{NONE},  relItem )$\;}
    }
}

%}

\end{algorithm}
%\vspace{-0.8cm}



%Besides the two oracles which are passed as parameters,
\forget{Input parameters of Algorithm \ref{alg:coreFinder} include a rule instance $r$, an invariant $inv$, a sets of invariants $invs$.  The sets $invs$   stores the auxiliary invariants constructed up to now. The algorithm   searches for new invariants and    constructs the causal relation between the rule instance $r$ and the invariant $inv$.
The algorithm returns a formula option and a causal relation item between $r$ and $inv$. A formula option value $\mathsf{NONE}$ indicates that no new invariant is found, while $\mathsf{SOME}(f)$ indicates a new auxiliary invariant $f$ is searched.}


%{\sf invFinder} is implemented by FL, which is an excellent STE-tool
%  The above function {\sf findInvsFromRule} tries to find new
%invariants and construct the causal relation between the rule
%instance $rule$. %The statement {\tt
%cond => te|fe} is an abbreviation of the if-then-else expression
%that if $cond$ is true then $te$ else $fe$.
%Parameters $newInvs$, $invs$, and $casRel$ are new invariants, invariants, and all the
%causal relations constructed up to now, the above oracle functions
%are also passed as parameters.  % Causal relations  are still not
%checked between the ones in $newInvs$ and rules.
%

Algorithm $\mathsf{coreFinder}$ works as follows: after computing $ cf'$ (line \ref{line:preCondComp}) , which is the weakest precondition of the input formula $cf$ w.r.t. $\mathsf{act}(cr)$, the algorithm takes further operations according to the cases it faces with:
%Algorithm {\sf invFinder-I} performs case analysis on $inv'$:

\begin{description}
\item[(1)] If $ cf=cf'$, meaning that statement $\mathsf{act}(cr)$ does not change $cf$, then no new invariant is created, and  new causal
relation item marked with tag $\mathsf{invHoldRule_2}$ is recorded
between $cr$ and $cf$, but at this moment there are no new invariants to be added; for instance, let $ cr=\mathsf{crit} (3)$,  $ cf=\mathsf{mutualInv}(1,2)$, thus
$cf'=cf$, then a pair  $ (\mathsf{NONE}, ( crit(3), inv, \mathsf{invHoldRule}_2,\_))$ will be returned.

\item[(2)] If $\mathsf{ tautChk}$ verifies that $g \dashrightarrow cf'$ is a tautology, then  no new invariant is created, and
the new causal relation item marked with tag
$ \mathsf{invHoldRule}_1$ is recorded between $cr$ and $cf$.  For instance, let $cr=\mathsf{crit}(2)$, $cf=\mathsf{invOnXC}(1)$,
 $cf'=\neg(\mathsf{false }\eqc \mathsf{true} \andc n[1] \eqc \mathsf{C})$, obviously, $g \dashrightarrow f'$ holds forever,
 thus a pair $(\mathsf{NONE},  (\mathsf{crit}(2), inv, \mathsf{invHoldRule}_1,\_))$ will be returned.


\item[(3)] If neither of the above two cases holds, then a new auxiliary invariant $newInv$ will be constructed, which will make the causal relation $ \mathsf{invHoldRule}_3$  to hold. The candidate set is $\mathsf{subsets}(\mathsf{decompose}(\mathsf{dualNeg}(cf')\andc g))$, where $\mathsf{decompose}(f)$ decompose $f$ into a set of sub-formulas $f_i$  such that each $f_i$ is not of a conjunction form and $f$   is semantically equivalent to $\bigwedge\limits_{i=1}^Nf_i$  for some $N$. $\mathsf{dualNeg}(\negc f)$ returns $f$. $\mathsf{subsets}(S)$ denotes the power set of a set $S$.
%The construction of the auxiliary invariant is introduced better after giving some definitions. A formula $f$ can be composed into a set of sub-formulas $f_i$, denoted as $decompose(f)$, such that each $f_i$ is not of a conjunction form and $f$   is semantically equivalent to $f_1 \andc f_2 \andc ... \andc f_N$.  $f_i$ usually is an atomic formula in our work after decomposition. For a formula $f$, we use $subsets(f)$ to denote the power set of $decompose(f)$, which contains all subsets of $decompose(f)$. $dualNeg(\negc f)$ returns $f$. The $\mathsf{ normalize}(f)$ function normalizes the numbering order of the use of parameters in the invariant $inv$.
%The result formula should be in  a normal form, whose parameters
%  always start from 1, and increase one by one if there are more
%  parameters. E.g.,  $\negc (x\eqc\mathsf{true} \andc n[1]\eqc\mathsf{C})$ is normalized, but
%  $\negc (x\eqc\mathsf{true} \andc n[2]\eqc\mathsf{C})$  not. The implementation of $\mathsf{ normalize}$ firstly compute a protype of $f'$,  which is obtained by substituting concrete parameters with different  e index variables $i_1$, ...$i_n$ in a pre-order traversal of the syntax of $f$, where $n$ is  the number of concrete parameters occurring in $f$ , then the returned result by $normalize$ is the formula which is obtained by substituting index variables $i_1$, ...$i_n$ with concrete indexes 1,...,$n$. Namely, we can see a normalized formula is obtained by substituting formal index variables with an identical permutation $1~ \mathsf{upto}~ n$.
A proper formula is chosen from the candidate set to construct a new invariant $newInv$. This is accomplished by the $\mathsf{choose}$ function, which calls the oracle $\mathsf{chk}$ to verify whether a formula is an invariant in the given reference model. After $newInv$ is chosen, the function $\mathsf{isNew}(newInv,invs)$ checks whether $newInv$ is new w.r.t. $invs$. If this is the case, the invariant will be normalized, and then be  added into $newInvs$, and the new causal relation item marked with tag $\mathsf{invHoldRule_3}$ will be added into the causal relations. Here the meaning of $\mathsf{isNew}(newInv,invs)$ is that $newInv$ is not symmetric to any formula in $invs$. %E.g., $\mathsf{mutualInv}(1,2)$ is equivalent to
%$\mathsf{mutualInv}(2,1)$ in a symmetry view. 
 Let $ invs=\emptyset$, $ r=\mathsf{crit}(1)$, $ inv=\mathsf{mutualInv}(1,2)$,
$ cf'= \negc(true\eqc true \andc n[2]\eqc C)$, from all the subsets of $\{n[1]\eqc T, x\eqc true, n[2]\eqc C\}$, the $\mathsf{coreFinder}$ calls $ \mathsf{choose}$ oracle to select the subset $\{ x=true, n[2]\eqc C\}$,  combines all the item in this set, then constructs a new formula $f_0= \negc(x\eqc true \andc  n[2]\eqc C)$. After   normalization tom$f_0$, the resulting new invariant   $newInv=\negc(x=true \andc
   n[1]\eqc C)$  and  a  relation item $ (crit(1),   \mathsf{invHoldRule}_3, f_0)$ are returned.


\end{description}

%Roughly speaking, the top level of {\sf invFinder} works as follows: a queue  $newInvs'$ is used to store new invariants found, and the initial value of $newInvs'$ is set by the initial invariant formulas we want to verify. Head element of $newInvs'$ is pushed, and used to check the consistency relation with all the parameterized rules.  $\mathsf{InvFinder}$ is iteratively called to compute new invariant formulas and relation items. This searching procedure is not finished until no new invariant is searched.

%\vspace{-0.5cm}
 \begin{table}[htbp]
\centering \caption{A fragment of output of {\sf invFinder}\label{table:groundCausalRelation}} % {\tt
%simpMutual.tbl}
\begin{tabular}{|c|c|c|c|c|  }
\hline
  rule& ruleParas&inv&causal relation &   f'  \\
\hline
  .. & ..&.. &..&.. \\

\hline
  crit  & [1]&mutualInv(1,2)& invHoldRule3 &invOnXC(2) \\
\hline
  crit &[2]& mutualInv(1,2)& invHoldRule3 &invOnXC(1)  \\
\hline
  crit & [3]& mutualInv(1,2) & invHoldRule2  & \\
\hline
  .. & ..&.. &..&.. \\

\hline
  crit  & [1]&invOnXC(1) & invHoldRule1 &\_ \\
\hline
  crit &[2]& invOnXC(1) & invHoldRule1 &\_  \\
\hline
\end{tabular}
\end{table}

%\vspace{-0.8cm}

For instance, let $PR=\{try, crit, exit, idle\}$, $invs=\{mutualInv(1,2)\}$,    the output of the {\sf invFinder}, which is stored in file {\tt mutual.tbl},  is shown in Table
\ref{table:groundCausalRelation}. In the table,  each line records the    index of a normalized   invariant, name of a parameterized rule, the rule
  parameters to instantiate the rule, a causal relation between
  the concrete invariant and a kind of causal relation which involves the kind and proper formulas
  $f'$   in need (which are used to construct
      causal relations $\mathsf{invHoldRule}_3$). The auxiliary invariants found by {\sf invFinder} include: $\mathsf{inv_2}  \equiv  \negc (\mathsf{x} \eqc \mathsf{true}  \andc  n[1]=\mathsf{C})$, $\mathsf{inv_3}    \equiv \negc  ( n[1]=\mathsf{C} \andc n[2]=\mathsf{E})$,
$\mathsf{inv_4}  \equiv  \negc (x \eqc \mathsf{true}  \andc  n[1]\eqc \mathsf{E})$,   $\mathsf{inv_5}    \equiv \negc  ( n[1]\eqc \mathsf{E} \andc n[2] \eqc \mathsf{E})$.  \footnote{The names $\mathsf{mutualEx}$ and $\mathsf{invOnX1}$ in
  this work are just for easy-reading, their
 index here is generated  in some order by {\sf invFinder}}.


%\vspace{-0.5cm}
\section{Generalization}\label{sec:generalization}
%\vspace{-0.5cm}%From this section, our modelling language has been extended to HOL (Higher-order Logic) provided by Isabelle, which not only include the language in Section \ref{sec:protocolSyntax}, but also higher-order logic features. This is not surprising because our formal theory for a parameterized instance of a protocol is done in HOL/Isabelle.  In order to include the theory formally in section \ref{sec:protocolSyntax} and \ref{sec:causal_rel}, we define a Isabelle theory {\tt cache.thy}.
Intuitively, generalization means that a concrete index (formula or rule) is generalized into a set of concrete indices (formulas or rules), which can be formalized  by a symbolic index (formula or rules) with side conditions  specified by   constraint formulas.     In order to do this, we  adopt a new constructor  to model symbolic index or symbolic value $\mathsf{symb}(str)$, where $str$ is   a string.  We use $\mathtt{N}$ to denote $symb("N")$, which formalizes the size of an parameterized protocol instance. A concrete index $i$ can be transformed into a symbolic one by some special strategy $g$, namely  $\mathsf{symbolize}(g,i)=\mathsf{symb}(g(i))$. In this work, two special transforming function $\mathsf{fInv}(i)="iInv"\cat \mathsf{itoa}(i)$ and $\mathsf{fIr}(i)="iR"\cat \mathsf{itoa}(i)$, where $\mathsf{itoa}(i)$ is the standard function transforming an integer $i$ into a string. We use  special symbols $\mathtt{\iInv_i}$  to denote $\mathsf{symbolize}(fInv,i)$;  and $\mathtt{\iR_i}$ to denote $\mathsf{symbolize}(fIr,i)$. The former formalizes a symbolic parameter of a parameterized   formula, and the latter    a symbolic  parameter of a parameterized rule. Accordingly, we define $\mathsf{symbolize2f}(g,inv)$ (or  $\mathsf{symbolize2r}(g,r)$), which returns the symbolic transformation result to a concrete formula $inv$ (or rule $r$) by replacing a concrete index $i$ occurring in $inv$ (or $r$) with a symbolic index $\mathsf{symbolize}(g,i)$.


There are two
main kinds of generalization in our work: (1) generalization of a normalized invariant into a symbolic one. %This generation will be used for the generation of \cai{(replace to:
The resulting symbolic invariants are used to create definitions of invariant formulas in Isabelle. For instance,  $\negc$(x $\doteq$ true $\andc$ n[1]$\doteq$ C) is generalized into $\negc$(x $\doteq$ true $\andc$ n[$\mathtt{\iInv_1}$]$\doteq$ C).  This kind of generalization is done with model constraints, which  specify  that any parameter index should be not greater than the instance size $\mathtt{N}$, and parameters to instantiate a parameterized rule (formula) should be different. (2) The generalization of concrete causal relations into parameterized causal relations in Isabelle, and will be used in proofs of the existence  of causal relations in Isabelle.


Since the first kind of generalization is simple, we focus on the second kind of generalization, which consists of two phases.
Firstly, groups of rule parameters  such as [[1],[2],[3]] will be generalized into a list of  symbolic formulas  such as $[\mathtt{\iR_1} \eqc \mathtt{\iInv_1},\mathtt{\iR_1} \eqc \mathtt{\iInv_2},  (\mathtt{\iR_1} \ne \mathtt{\iInv_1}) \wedge  (\mathtt{\iR_1} \ne \mathtt{\iInv_2})] $\footnote{$\mathtt{\iR_1} \ne \mathtt{\iInv_1}$ is the abbreviation of $!(\mathtt{\iR_1} \eqc \mathtt{\iInv_1})$} , which  stands for case-splittings  by comparing  a symbolic rule parameter $iR_1$ and invariant parameters $\iInv_1$ and $\iInv_2$. In the second phase, the formula field accompanied with a $\mathsf{invHoldRule3}$ relation is also  generalized by some special strategy.  %This generation is prepared for the generation of proofs of the existence of causal relations in Isabelle. Here we focus on  %These formulas should be formalized in HOL.

Now let us look at the first phase, starting with some definitions.
Consider a line of concrete causal relation shown in Table \ref{table:groundCausalRelation}, there is a group of rule parameters $LR$, and a group of parameters $LI$ occurring in an  invariant formula.

\begin{definition}
Let $LR$ be a permutation s.t. $|LR|>0$, which represents a list of actual parameters to instantiate a parameterized rule,    let $LI$  be a  permutation $|LI|>0$,  which  represents a list of actual parameters to instantiate a parameterized invariant, we define:
\begin{enumerate}
\item symbolic comparison condition generalized from comparing $LR_{[i]}$ and $LI_{[j]}$: \\
$ \mathsf{symbCmp}(LR,LI,i,j)\equiv $
 \begin{numcases}{ }
 \mathtt{\iR_i} \eqc \mathtt{\iInv_j} &   if $LR_{[i]}=LI_{[j]}$\ \ \ \ \\
\mathtt{\iR_i} \ne \mathtt{\iInv_j} & otherwise
\end{numcases}
%$symbCmp(LR,LI,i,j)\equiv$ if $equality(LR,LI,i,j)$ then $\mathtt{\iR_i} = \mathtt{\iInv_j}$ else $ (\mathtt{\iR_i} \ne \mathtt{\iInv_j})$

\item symbolic comparison  condition generalized from comparing   $LR_{[i]}$ and with all $LI_{[j]}$ :\\
$\mathsf{symbCaseI}(LR,LI,i)\equiv $\\
\begin{numcases}{ }
   symbCmp(LR,LI,i,j)& if $\exists! j.  LR_{[i]}=LI_{[j]}$\\
   forallForm(|LI|,pf)& otherwise
 \end{numcases}
 where  $pf(j)= \mathsf{symbCmp}(LR,LI,i,j)$, and $\exists!j.P$ is an qualifier meaning that  there exists a unique $j$ s.t. property $P$;

\item symbolic case  generalized from comparing $LR$ with $LI$ : $\mathsf{symbCase}(LR,LI )\equiv \mathsf{forallForm}(|LR|,pf)$, where $pf(i)= \mathsf{symbCaseI}(LR,LI,i )$;

\item symbolic partition generalized from comparing all $LRS_{[k]}$ with $LI$, where $LRS$ is a list of permutations with the same length: $\mathsf{partition}(LRS,LI) \equiv \mathsf{existsForm}(|LRS|,pf)$,  where $pf(i)= \mathsf{symbCase}(LRS_i,LI)$.

\end{enumerate}
\end{definition}

$\mathsf{symbCmp}(LR,LI,i,j)$ defines a symbolic formula  generalized from comparing $LR_{[i]}$ and $LI_{[j]}$; $\mathsf{symbCaseI}(LR,LI,i)$  a symbolic formula summarizing the results of comparison  between $LR_{[i]}$  and all $LI_{[j]}$ such that $j \le |LI|$; $\mathsf{symbCase}(LR,LI )$ a symbolic formula representing a subcase generalized from comparing all $LR_{[i]}$  and all $LI_{[j]}$; $\mathsf{partition}(LRS,LI)$  is a disjunction of subcases $\mathsf{symbCase}(LRS_{[i]},LI )$.  Recall the first three lines in Table. \ref{table:groundCausalRelation}, and $LI=[1,2]$ is the list of parameters occurring in $\mathsf{mutualEx}(1,2)$; and $LR$ is the actual parameter list to instantiate $\mathsf{crit}$.
 %\begin{itemize}
 %\item when   $LI=[1]$ is a list of parameters occurring in $invOnXC(1)$
%\begin{itemize}
 % \item $LR=[1]$ is the actual parameter list to instantiate $crit$, $symbCmp(LR,LI,1,1)=(\mathtt{\iR_1} = \mathtt{\iInv_1})$, $symbCase(LR,LI)=symbCaseI(LR,LI,1)=(\mathtt{\iR_1} = \mathtt{\iInv_1})$.

 % \item  $LR=[2]$ is the actual parameter list to instantiate $crit$, $symbCmp(LR,LI,1,1)= (\mathtt{\iR_1} \ne \mathtt{\iInv_1})$, $symbCase(LR,LI)=symbCase(LR,LI,1)=(\mathtt{\iR_1} \ne \mathtt{\iInv_1})$

  % \item let $LRS=[[1],[2]]$, $partition(LRS,LI)= (\mathtt{\iR_1} = \mathtt{\iInv_1}) \vee  (\mathtt{\iR_1} \ne \mathtt{\iInv_1})$
%\end{itemize}
%\item when   $LI=[1,2]$ is a list of parameters occurring in $mutualEx(1,2)$
\begin{itemize}

  \item when $LR=[1]$, $\mathsf{symbCmp}(LR,LI,1,1)=(\mathtt{\iR_1} \eqc \mathtt{\iInv_1})$, $\mathsf{symbCase}(LR,LI)=\mathsf{symbCaseI}(LR,LI,1)=(\mathtt{\iR_1} \eqc \mathtt{\iInv_1})$ becuase $LR_{[1]}=LI_{[1]}$.

  \item when $LR=[2]$, $\mathsf{symbCmp}(LR,LI,1,2)= (\mathtt{\iR_1} \eqc \mathtt{\iInv_2})$, $\mathsf{symbCase}(LR,LI)=\mathsf{symbCaseI}(LR,LI,2)=(\mathtt{\iR_1} \eqc \mathtt{\iInv_2})$ becasue $LR_{[1]}=LI_{[2]}$.


 \item when  $LR=[3]$, $\mathsf{symbCmp}(LR,LI,1,1)=(\mathtt{\iR_1} \ne \mathtt{\iInv_1})$, $\mathsf{symbCmp}(LR,LI,1,2) = (\mathtt{\iR_1} \ne \mathtt{\iInv_2})$, $\mathsf{symbCase}(LR,LI)=symbCaseI(LR,LI,1)= (\mathtt{\iR_1} \ne \mathtt{\iInv_1}) \wedge  (\mathtt{\iR_1} \ne \mathtt{\iInv_2})$ because neither $LR_{[1]}=LI_{[1]}$ nor $LR_{[1]}=LI_{[2]}$.

  \item let $LRS=[[1],[2],[3]]$, $\mathsf{partition}(LRS,LI)= (\mathtt{\iR_1} \eqc \mathtt{\iInv_1}) \vee (\mathtt{\iR_1} \eqc \mathtt{\iInv_2}) \vee ( (\mathtt{\iR_1} \ne \mathtt{\iInv_1}) \wedge  (\mathtt{\iR_1} \ne \mathtt{\iInv_2}))$
\end{itemize}
%\end{itemize}

%Note that $\mathsf{partition}(LRS,LI)$ is a complete partition if it is a tautology.
%In the above example, the two partitions are both complete.
If we see a line  in table \ref{table:groundCausalRelation} as a concrete test case for some concrete causal relation,  then $\mathsf{symbCase}(LR, LI)$ is an abstraction predicate to generalize the concrete case. Namely, if we transform $\mathsf{symbCase}(LR, LI)$ by substituting $\mathtt{\iInv_i}$ with $LI_{[i]}$, and $\mathtt{\iR_j}$ with $LR_{[j]}$, the result is semantically equivalent to true. %If another $LR'$ and $LI'$ are permutations s.t.  $symbCase(LR', LI')$, then the same kind of causal relation  should hold, thus we can apply the same proof tactics to prove.

The second phase of generalization of concrete causal relations is to generalize the formula $inv'$ accompanied with a causal relation $\mathsf{invHoldRule_3}$ in a line of table \ref{table:groundCausalRelation}. An index occurring in $f'$ can either  occur in the invariant formula, or in the rule. We need to look it up to determine the  transformation.

\begin{definition}
Let $LI$ and $LR$ are two permutations,  $\mathsf{find\_first}(L,i)$ returns the least index $j$ s.t. $L_{[i]}=j$ if there exists such an index; otherwise returns an error.
%$\mathsf{lookup}(LI,LR, i)\equiv$
\begin{numcases}{\mathsf{lookup}(LI,LR, i)\equiv }
 \mathtt{\iInv_{find\_first(LI,i)}} &   if $i\in LI$\\
\mathtt{iR_{find\_first(LR,i) }} & otherwise
\end{numcases}
 %if $i\in LI$ then $\mathtt{\iInv_{find\_first(LI,i)}}$ else $\mathtt{iR_{find\_first(LR,i) }}$
%$\mathsf{symbolize'}(f,LI,LR) $ is a formula transformed from $f$ by substituting each $i$ with $lookup(LI,LR, i)$.
\end{definition}

$\mathsf{lookup}(LI,LR, i)$ returns the symbolic index transformed from $i$ according to whether $i$ occurs in $LI$ or in $LR$. The index $i$ will be transformed into  $\mathtt{\iInv_{find\_first(LI,i)}}$ if $i$ occurs in $LI$, and  $\mathtt{iR_{find\_first(LR,i) }}$ otherwise. Employing the $\mathsf{lookup}$ strategy to transform a concrete index $i$ in  $inv'$ to $\mathsf{lookup}(LI,LR, i)$, $\mathsf{symbolize2f}$ transforms $inv'$ into a symbolic one  which will be needed in a proof command for existence of the $\mathsf{invHoldRule_3}$  relation in Isabelle.  %\caicomment{not clear: $\mathsf{symbolize2f}$ calling $\mathsf{lookup}$ strategy   will be used  to transform   $inv'$ into  a symbolic formula, which will be needed for the generation of a proof command for existence of the $\mathsf{invHoldRule_3}$  relation in Isabelle.}
%For instance, let $LI=[1,2]$, $LR=[2]$, then  $\mathsf{lookup}(LI,LR, 2)=\mathtt{\iInv_2}$, and  $\mathsf{invOnXC}(2)$ is transformed into $\negc(x\eqc true \wedge n[\mathtt{\iInv_2}]\eqc C)$ by the strategy $\mathsf{lookup}$.

%Let $LI=[1]$, $LR=[1,2]$, then $symbolize'(mutualInv(1,2),LI,LR)$ is $\neg(n[\iInv_1]\eqc C \wedge n[\iR_2]\eqc C)$. Here the latter exmple is only  artificial because there is no rule which will be instantiated by $[1,2]$. But for complex protocols like FLASH, the case exits where a rule with two parameters and an invariant with only a parameter exits.
%For convenience in generating Isabelle proofs,      %a formula $\mathsf{diffConGen}~(\mathsf{paraMumsOfInv}~cr~"iR"$ to specify with the assumptions that mutual difference between the parameters of the symbolic invariant.  Here we assume that the string $"iR"$ does not occur in $cr$.
%a table $symbCausalTab$ is generated, which  stores causal relation between a parameterized rule and an  invariant w.r.t. a  size $N$. An entry of the table is referenced by concatation of the name of a rule and an invariant formula. Such an entry is a record containing fields {\tt symbCases} and  {\tt relationItems}, and created by collecting all the lines on the concrete relation items between the rule and the invariant. {\tt symbCases}  stores the list of symbolic cases each of which is derived by $\mathtt{symbCase}(LR, 1~\mathsf{upto}~n)$, where $LR$ is the rule parameters, and $n$ the number of parameters occurring in the invariant. relations store a list of generalized causal relation items.  For instance, for the rule $\mathsf{crit}$ and $\mathsf{inv5}$, a record $(|\mathtt{symbCases}=[\mathtt{\iR_1} = \mathtt{\iInv_1},\mathtt{\iR_1} = \mathtt{\iInv_2},(\mathtt{\iR_1} \ne \mathtt{\iInv_1}) \wedge  (\mathtt{\iR_1} \ne \mathtt{\iInv_2})]$; $\mathtt{relationItems}= [\mathsf{invHoldRule}_3(f_1')$,$\mathsf{invHoldRule_3}(f_2')$,$\mathsf{invHoldRule}_2]|)$, where $f_1'=\negc(x\eqc true \wedge n[\mathtt{\iInv_2}]\eqc C)$, and $f_2'=\negc(x\eqc true \wedge n[\mathtt{\iInv_1}]\eqc C)$.

%\vspace{-0.3cm}
%-------------------------------------------------------------------------
\section{Automatical Generation of Isabelle Proof }\label{sec:prooGen}
%-------------------------------------------------------------------------
%\subsection{An  Example of Generated Isabelle/Script} \label{subsection:introOfIsabelleProof}
%\vspace{-0.3cm}
A formal model for a protocol case in a theorem prover like Isabelle
includes the definitions of constants and rules and invariants,
lemmas, and proofs. Readers can refer to \cite{LiCache16} for detailed illustration of the formal proof script. In this section, we focus on the generation of a lemma on the existence of causal relation between a parameterize rule and invariant formula based on the aforementioned generalization of lines of concrete causal relations. %An overview of the hierarchy  of the formal proof scripts of  is
%shown in Fig \ref{fig:isabelleProofIntro}.

%\begin{figure}[htbp]
% \centering %
% \vspace{-0.8cm}
%\includegraphics[width=1.0\textwidth]{lemmaHierachy}
%\vspace{-0.5cm}
%\caption{An overview of an Isabelle proof\label{fig:isabelleProofIntro}}

%\end{figure}

%In detail, the proof script is divided into   parts as follows: (1) Definitions of protocol under case study including enumerating datatypes; definitions of formally parameterized invariant formulas, and the set of all actual invariants w.r.t. a protocol instance; definitions of formally parameterized rules, and the set of all actual rules w.r.t. a protocol instance; definitions of specification of the initial state; (2) A lemma  such as {\tt rule$_i$Vsinv$_j$} on a causal relation of a rule and an invariant; (3) A  Lemma  such as {\tt inv$_i$OnRules} on causal relations for all rules in  the rule set  and an invariant. (4) A lemma {\tt invsOnRules} on a causal relation for all rules in  the rule set  and all invariants in the invariant set. (4) A Lemma such as {\tt iniImply\_inv$_i$} on a fact that an invariant {\tt inv$_i$}  holds at the initial state defined by the specification of the initial state. (5) A lemma {\tt on\_inits} proves that for all invariants they hold at the initial state of the protocol. (6) Main theorem  proving that any invariant formula  holds at any reachable state of the  N-parameterized the protocol instance.
%\subsubsection{Lemmas for Causal Relation between Rules and Invariants}
 % Now we discuss how to use records on {\tt crit} and {\tt inv$_1$} in the tables   $symbInvs$, $symbRules$, and $symbCausalTab$ to generate a lemma to prove that causal relation hold between   crit and   $inv_1$, which will be applied in the proof of main lemma.
 %A lemma at the bottom level, specifies that causal relation hold between  a rule like  $\mathsf{crit}$ and a parameterized rule like  $\mathsf{inv_1}$,
 An  example lemma
{\tt critVsinv$_1$} and its proof in Isabelle in the {\tt mutualEx} protocol, is illustrated as follows:

\begin{specification}
%\begin{algorithm}
%\caption{Generating a kind of proof which is according with a relation tag of $invHoldRule_{1-3}$ : rel2proof}\label{lemma:causal relation lemma}
1lemma critVsinv1:\\
2  assumes  a1: $\exists$ \iR1. \iR1 $\le$ N $\wedge$ r=crit \iR1 and \\
  a2: $\exists$  \iInv1 \iInv2. \iInv1 $\le$ N $\wedge$ \iInv2 $\le$ N $\wedge$ \iInv1 $\neq$ \iInv2 \\
   $\wedge$ f=inv1  \iInv1 \iInv2\\
3  shows  invHoldRule s f r (invariants
  N)\\
4  proof -\\
   from a1 obtain \iR1 where a1:\iR1 $\le$ N $\wedge$ r=crit \iR1 \\
\twoSpaces   by blast\\
   from a2 obtain \iInv1 \iInv2 where a2: \iInv1 $\le$ N \\
   $\wedge$ \iInv2 $\le$ N $\wedge$ \iInv1 $\neq$ \iInv2 $\wedge$ f=inv1  \iInv1 \iInv2\\
\twoSpaces   by blast \\
5  have iR1=\iInv1 $\vee$ \iR1=\iInv2 $\vee$ (\iR1 $\ne$ \iInv1 $\wedge$  \iR1 $\ne$ \iInv2) \\
  by auto\\

6  moreover\{assume  b1:\iR1=\iInv1\\
7  \twoSpaces have invHoldRule3 s f r (invariants N)\\
 \twoSpaces  \twoSpaces   proof(cut\_tac a1 a2 b1, simp, \\
 rule\_tac x=$\negc$ (x=true $\andc$ n[\iInv2]=C)  in exI,auto)qed\\
8  \twoSpaces then have invHoldRule s f r
(invariants
  N)
by auto\}\\

9  moreover\{assume  b1:iR1=\iInv2\\
10 \twoSpaces have invHoldRule3 s f r (invariants N)\\
 \twoSpaces \twoSpaces   proof(cut\_tac a1 a2 b1, simp, \\
 rule\_tac x=$\negc$ (x=true $\andc$ n[\iInv1]=C  in exI,auto)qed\\
11 \twoSpaces then have invHoldRule s f r (invariants
  N)
by auto\}\\

12   moreover\{assume  b1:(\iR1 $\ne$  \iInv1 $\wedge$   \iR1 $\ne$  \iInv2)\\
13 \twoSpaces have invHoldRule2 s f r  \\
  \twoSpaces \twoSpaces  proof(cut\_tac a1 a2 b1,  auto) qed\\
14 \twoSpaces then have invHoldRule s f r
(invariants
  N)
by auto\} \\

15ultimately show invHoldRule s f r
(invariants N) by blast\\
16qed\\
%\end{algorithm}
\end{specification}

In the above proof, line 2 are assumptions on the parameters of the invariant and rule, which are composed of two parts: (1) assumption {\tt a1} specifies that there exists an actual parameter {\tt \iR1} with which {\tt r} is a rule obtained by instantiating {\tt crit}; (2) assumption {\tt a2} specifies that  there exists   actual parameters {\tt \iInv1} and {\tt \iInv2} with which {\tt f} is a formula obtained by instantiating {\tt inv1}.
 %(1) the facts that all parameters of this invariant should be less than the parameter $N$; %(2) the facts that all parameters of this invariant should be less than the parameter $N$; (3) the constraints of he mutual difference between parameters of the invariant (rule), which can %be looked up in the field of those records  from the table $symbInvTab$ ($symbRuleTab$) by the invariant (rule) name {\tt inv1} ({\tt crit}), which specifies that the mutual difference %between two parameters.
Line 4 are two typical  proof patterns forward-style which fixes local variables such as {\tt \iR1} and new facts such as {\tt a1: iR1 $\le$ N $\wedge$ r=crit \iR1}. From line 5, the remaining part  is a typically readable Isar proof using calculation
reasoning such as {\tt moreover} and {\tt ultimately} to do  case analysis.
Line 5 splits cases of {\tt iR1} into all possible cases by comparing
{\tt \iR1} with {\tt \iInv1} and {\tt \iInv2}, which is in fact characterized by $\mathsf{partition}([1],[2],[3]],[1,2])$. Lines 6-14  proves    these cases one by one: Lines 6-8 proves the case where {\tt iR1=\iInv1}, line 7 first proves that the causal relation $\mathsf{invHoldRule_3}$ holds by supplying a symbolic formula, which is transformed from $invOnXC(2)$  by calling $\mathsf{symbolize2f}$ with $\mathsf{lookUp}$ strategy.  %which is $symbolize'(invOnXC(2),[1,2],[1])$. %Notes that $invOnXC(2)$ is the $f'$ which is provided in the last column of the line.
From the conclusion at line 7, line 8 furthermore proves the causal relation $\mathsf{invHoldRule}$  holds; Lines 9-11 proves the case where {\tt iR1=\iInv2}, proof of which is similar to that of case 1; Lines 12-14 the case   where neither {\tt iR1=\iInv1} nor {\tt iR1=\iInv2}. Each proof of a subcase is done in a block {\tt moreover b1:asm1 proof1}, the {\tt ultimately}  proof command in line 15 concludes by summing up all the subcases.



With the help of all the lemmas such as {\sf ruleVsinv1},  we can prove the following lemma  {\sf lemma$\_$inv$\_$1$\_$on$\_$rules} which
specifies that for all $r \in rules ~N$, and $f$ is a formula $f$ which is generated by instantiating inv1 with some parameters $\iInv_1$ and $iInv_2$, $invHoldForRule ~s~ f~ r~ (invariants~ N)$.

\begin{specification}
lemma lemma$\_$inv1$\_$on$\_$rules:\\
  asumes a1:
r $\in$ rules N
 and \\
 a2:
($\exists$ $\_$iInv1 $\_$iInv2. $\_$iInv1$\le$
N$\wedge$$\_$iInv2$\le$\\
N$\wedge$\iInv1$\neq$\iInv2$\wedge$f=inv1  \iInv1 \iInv2)\\

 shows
invHoldForRule s f r (invariants N)\\

  proof -\\
\twoSpaces  have
($\exists$ i. i$\le$
N$\wedge$r=try  i)$\vee$
    ($\exists$ i. i$\le$\\
N$\wedge$r=crit  i)$\vee$
    ($\exists$ i. i$\le$
N$\wedge$r=exit  i)$\vee$\\
    ($\exists$ i. i$\le$
N$\wedge$r=idle  i)\\

  apply (cut$\_$tac a1, auto) done\\
    moreover $\{$      assume b1:
($\exists$ i. i$\le$
N$\wedge$r=try  i)\\

\twoSpaces      have invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis tryVsinv1) done
    $\}$\\


    moreover $\{$ assume a1:
($\exists$ i. i$\le$
N$\wedge$r=crit  i)\\

\twoSpaces      have
invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis critVsinv1) done
    $\}$\\


    moreover $\{$
      assume a1:
($\exists$ i. i$\le$
N$\wedge$r=exit  i)\\

\twoSpaces      have
invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis exitVsinv1) done
    $\}$\\


    moreover $\{$ assume a1:
($\exists$ i. i$\le$
N$\wedge$r=idle  i)\\

\twoSpaces      have
invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis idleVsinv1) done
    $\}$\\


  ultimately show invHoldForRule' s f r (invariants N)\\
  by auto\\
qed\\

\end{specification}

With the help of all the lemmas such as {\sf lemma$\_$inv$_i\_$on$\_$rules},  we can prove the following lemma  {\sf invs$\_$on$\_$rules} which
specifies that for all $f \in invariants~ N$ and $r \in rules~ N$,   $invHoldForRule ~s~ f~ r~ (invariants~ N)$.

\begin{specification}
lemma invs$\_$on$\_$rules:
assumes a1:
f $\in$ invariants N \\
 and a2:
r $\in$ rules N\\
shows
invHoldForRule' s f r (invariants N)\\

  proof -\\
  have b1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1$\neq$\iInv2$\wedge$\\
f=inv1  \iInv1 \iInv2)$\vee$\\
    ($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv2  \iInv2)$\vee$\\
    ($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1$\neq$\iInv2$\wedge$\\
f=inv3  \iInv1 \iInv2)$\vee$\\
    ($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv4  \iInv2)$\vee$\\
    ($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1$\neq$\iInv2$\wedge$\\
f=inv5  \iInv1 \iInv2)\\

  apply (cut$\_$tac a1, auto) done\\
    moreover $\{$      assume b1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$ N \\
$\wedge$\iInv1$\neq$\iInv2
$\wedge$f=inv1  \iInv1 \iInv2)\\

\twoSpaces       have
invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis lemma$\_$inv1$\_$on$\_$rules) done
    $\}$\\


    moreover $\{$ assume b1:
($\exists$ \iInv2. \iInv2$\le$ N\\
$\wedge$f=inv2  \iInv2)

\twoSpaces       have invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis lemma$\_$inv2$\_$on$\_$rules) done
    $\}$\\


    moreover $\{$      assume b1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$ N\\
$\wedge$\iInv1$\neq$\iInv2
$\wedge$f=inv3  \iInv1 \iInv2)\\

\twoSpaces       have
invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis lemma$\_$inv3$\_$on$\_$rules) done
    $\}$\\


    moreover $\{$      assume b1:
($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv4  \iInv2)\\

\twoSpaces       have
invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis lemma$\_$inv4$\_$on$\_$rules) done
    $\}$\\


    moreover $\{$
      assume b1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$ N\\
$\wedge$\iInv1$\neq$\iInv2
$\wedge$f=inv5  \iInv1 \iInv2)\\

\twoSpaces       have
invHoldForRule' s f r (invariants N)\\

\twoSpaces      apply (cut$\_$tac a2 b1, metis lemma$\_$inv5$\_$on$\_$rules) done
    $\}$\\


  ultimately show
invHoldForRule' s f r (invariants N)\\

\twoSpaces  apply fastforce done\\
qed
end\\
\end{specification}



 % {\tt allSymbRecs } are all symbolic causal relation records on {\tt  invName} and {\tt  ruleName},
% then  {\tt lenPInv} and {\tt lenPRule} which are numbers of the parameters of the invariant formula and rule, then {\tt asms} which are the assumptions part of the lemma such as line 2, {\tt allDisjuncts} the case analysis between the parameters of invariant and rule such as line 5, {\tt allSubProofs} all the proofs of the subcases such as lines 6-14, then fill all these into the blanks of the templates to generate the lemma.


% {\tt namedAsmTrans asm i} adds a name "ai:" to a string of assumption in order to construct a named assumption. {\tt allNamedAsmsGen} generates all the aformentioned  four kinds of assumptions of the lemma in the previous paragrapgh: {\tt asmsLessOnInv} is according with (1) types of assumptions; {\tt asmsLessOnRule} (2) types of assumptions;  {\tt asmsMutualDiffOnInv} (3) types of assumptions; and {\tt asmsMutualDiffOnRule} (4) types of assumptions. After naming any one assumption with a name, {\tt allNamedAsmsGen} returns all the named assumptions which are conned by {\tt and} operator. {\tt symbCausalRec2Proof symbRec} generates a kind of proof in Isabelle according to a symbolic casual relation record {\tt symbRec}: if the tag of {\tt holdTag} is 1(2,3), then kind 1 (2,3) proof are generated accordingly. Here we list the most complex one: {\tt proof3Gen ruleName invName f}, which generates a proof which is according with {\tt invHoldType3} such as lines 6-8, and {\tt f} is another invariant formula which is needed to construct the {\tt invHoldType3} causal relation.
%\twoSpaces  let asmsLessOnRule=asmsGen iRule sN lenPRule in \\
%\twoSpaces  let asmsMutualDiffOnInv=asmsLookUp symbInvs invName gFldName in\\
%\twoSpaces  let asmsMutualDiffOnRule
\subsubsection{Lemmas on initial states}

In this section, we discuss the definition on the initial state of the protocol, and the lemmas specifying that each invariant formula holds at the initial state.

A typical Isabelle definition on the initial state of the protocol is as follows:

\begin{specification}
definition initSpec0::nat $\Rightarrow$ formula where [simp]:\\
initSpec0 N $\equiv$ (forallForm (down N) \\
(\% i . (eqn (IVar (Para (Ident ''n'') i)) (Const I))))\\

definition initSpec1::formula where [simp]:\\
initSpec1  $\equiv$ (eqn (IVar (Ident ''x'')) (Const true))\\

definition allInitSpecs::nat \<Rightarrow> formula list\\
allInitSpecs N $\equiv$ [(initSpec0 N),(initSpec1 )]\\

lemma iniImply\_inv4:\\
assumes a1: ($\exists$\iInv1. \iInv1$\le$N$\wedge$f=inv4 \iInv1)\\
and a2: formEval (andList (allInitSpecs N)) s\\
shows formEval f s\\
 using a1 a2 by auto\\
\end{specification}

{\tt initSpec0} and {\tt initSpec1} specifies the assignments on each variable {\tt n[i]} where {\tt i $\le$ N} and {\tt x}. The  specifications of the initial state is the list of all the specification definition on related state variables. Lemma {\tt iniImply\_inv4} simply specifies that the invariant formula {\tt inv4} holds at a state {\tt s} which satisfies the conjunction of the   specification of the initial state. Isabelle's {\tt auto} method can solve this goal automatically. Other lemmas specifying that other invariant formulas hold at the initial state are similar.
%The generation of the above code is straightforward: definitions of the specification of initial state variables in Isabelle is a direct syntax transformation from the internal represetation of tool {\tt proofGen} to Isabelle.

With the lemmas such as {\tt iniImply\_inv4}, for any invariant $inv \in (\mathsf{invariants} ~N) $,  any
state $s$, if $ini$ is evaluated true at state $s$, then $inv$ is
evaluated true at state $s$.

\begin{specification}
lemma on$\_$inis:
 assumes  a1:
f $\in$ (invariants N)\\
 and a2:
ini $\in$ $\{$
andList (allInitSpecs N)$\}$\\

 and a3:
formEval ini s\\

 shows formEval f s\\

  proof -\\
  have c1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1$\neq$\iInv2\\
$\wedge$f=inv$\_$$\_$1  \iInv1 \iInv2)$\vee$\\
    ($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv$\_$$\_$2  \iInv2)$\vee$\\
    ($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1$\neq$\iInv2\\
$\wedge$f=inv$\_$$\_$3  \iInv1 \iInv2)$\vee$\\
    ($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv$\_$$\_$4  \iInv2)$\vee$\\
    ($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N$\wedge$\iInv1$\neq$\iInv2\\
$\wedge$f=inv$\_$$\_$5  \iInv1 \iInv2)\\

\twoSpaces  apply (cut$\_$tac a1, simp) done\\
    moreover $\{$
      assume b1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N\\
$\wedge$\iInv1$\neq$\iInv2$\wedge$f=inv$\_$$\_$1  \iInv1 \iInv2)\\

      have
formEval f s\\

\twoSpaces      apply (rule iniImply$\_$inv$\_$$\_$1)\\
\twoSpaces      apply (cut$\_$tac b1, assumption)\\
\twoSpaces      apply (cut$\_$tac a2 a3, blast) done
    $\}$\\


    moreover $\{$
      assume b1:
($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv$\_$$\_$2  \iInv2)\\

      have
formEval f s\\

\twoSpaces      apply (rule iniImply$\_$inv$\_$$\_$2)\\
\twoSpaces      apply (cut$\_$tac b1, assumption)\\
\twoSpaces      apply (cut$\_$tac a2 a3, blast) done\\
    $\}$\\


    moreover $\{$
      assume b1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N\\
$\wedge$\iInv1$\neq$\iInv2$\wedge$f=inv$\_$$\_$3  \iInv1 \iInv2)\\

      have
formEval f s\\

\twoSpaces      apply (rule iniImply$\_$inv$\_$$\_$3)\\
\twoSpaces      apply (cut$\_$tac b1, assumption)\\
\twoSpaces      apply (cut$\_$tac a2 a3, blast) done
    $\}$\\


    moreover $\{$
      assume b1:
($\exists$ \iInv2. \iInv2$\le$
N$\wedge$f=inv$\_$$\_$4  \iInv2)\\

      have
formEval f s\\

\twoSpaces      apply (rule iniImply$\_$inv$\_$$\_$4)\\
\twoSpaces      apply (cut$\_$tac b1, assumption)\\
\twoSpaces      apply (cut$\_$tac a2 a3, blast) done
    $\}$\\


    moreover $\{$
      assume b1:
($\exists$ \iInv1 \iInv2. \iInv1$\le$
N$\wedge$\iInv2$\le$
N\\
$\wedge$\iInv1$\neq$\iInv2$\wedge$f=inv$\_$$\_$5  \iInv1 \iInv2)\\

      have
formEval f s\\

\twoSpaces      apply (rule iniImply$\_$inv$\_$$\_$5)\\
\twoSpaces      apply (cut$\_$tac b1, assumption)\\
\twoSpaces      apply (cut$\_$tac a2 a3, blast) done
    $\}$\\


  ultimately show formEval f s
  by auto\\
qed\\


\end{specification}

The proof structure of {\sf lemma$\_$inv1$\_$on$\_$rules} and  {\sf invs$\_$on$\_$rules} and {\sf on$\_$inis} are also typical case analysis ones using {\sf moreover} blocks and {\sf ultimately} commands, therefore, a generic program of generating a typical case analysis proof will be adopted in our framework.

%All can be generated by calling the generic template function {\sf doCaseAnalz} with different subproof generation functions.


\subsubsection{The main theorem}

%-------------------------------------------------------------------------
%At last, we discuss how to create automatically the proof for the main lemma, which depends
% on the applying the lemmas which are created in subsection \ref{sec:genOfIsabelleProof}.
With the preparation of lemma  on$\_$inis and  invs$\_$on$\_$rules, the generation of the main lemma is quite easy. Recall that the consistency lemma is our
main weapon to prove the main lemma, which requires proving two parts of
obligations.



\begin{description}
\item[(1)] For any invariant $inv \in (\mathsf{invariants} ~N) $,  any
state $s$, if $ini$ is evaluated true at state $s$, then $inv$ is
evaluated true at state $s$. This can be solved done by applying lemma on$\_$inis.
\item[(2)]  For any invariant $inv \in (\mathsf{invariants} ~N)$, any $r$ in rule set
$ \mathsf{rules} ~N$ , one of the causal relations
$\mathsf{invHoldForRule}_{1-3}$ holds. This can be solved done by  applying lemma invs$\_$on$\_$rules.
\end{description}
%
%Proof of Part (1) is  simple. %%For an invariant
%$inv=\mathsf{implyForm}~ant~cons$ in $invs$, we only need to prove
%that either $ant$ is evaluated as false or $cons$ is evaluated true
%at an initial state $s$ in order to prove $\models
%~inv~s$. Such a proof  can be automatically solved by Isabelle's
%$\mathsf{auto}$ command.



\begin{specification}
lemma main:
  assumes  a1: 0<N and \\
  a2: s$\in$ reachableSet \{andList (allInitSpecs N)\} (rules N)\\
  shows $\forall$ inv. inv $\in$ (invariants N) $\longrightarrow$ formEval inv s\\
proof(rule consistentLemma)\\
  show consistent (invariants N) \{andList (allInitSpecs N)\}\\ (rules N)\\
 proof(cut\_tac a1, unfold consistent\_def,rule conjI)\\
   show  $\forall$inv ini s. inv $\in$ (invariants N)
$\longrightarrow$ ini $\in$\{andList \\
(allInitSpecs N)\} $\longrightarrow$formEval ini s $\longrightarrow$ formEval inv s\\
proof((rule allI)+,(rule impI)+)\\
\twoSpaces   fix inv ini s\\
\twoSpaces   assume b1:inv $\in$ (invariants N) and b2:formEval ini s\\
\twoSpaces     and b3:ini $\in$ \{andList (allInitSpecs N)\}  \\
\twoSpaces   show "formEval f s"\\
\twoSpaces   apply (rule on\_inis, cut\_tac b1, assumption, cut\_tac b2, \\
assumption, cut\_tac b3, assumption) done\\
    qed\\

next   show  $\forall$inv r. inv $\in$ invariants N$\longrightarrow$
 r $\in$rules N\\
 $\longrightarrow$invHoldForRule inv r (invariants N) \\

   proof((rule allI)+,(rule impI)+)\\
\twoSpaces      fix f r \\
\twoSpaces         assume b1: f $\in$ invariants N  and b2:r $\in$ rules N\\

\twoSpaces     show invHoldForRule' s f r (invariants N)\\
  apply (rule invs\_on\_rules, cut\_tac b1, assumption, \\
  cut\_tac b2, assumption) done\\
qed\\
next show s $\in$ reachableSet {andList (allInitSpecs N)} (rules N)\\
  apply (metis a1) done\\
qed\\
\end{specification}

The generation of the main lemma is quite easy because it is in a standard form.
%\vspace{-0.5cm}
 %in order to verify the cache coherence protocols. Others are straightforward.
%The proof is a typically
%readable one in Isar style \cite{}, which uses calculation
%reasoning such as {\tt moreover} and {\tt ultimately} to do  case analysis on
%the form of rules and the invariants. Lines 1-5 use proper Isabelle
%proof commands to   decompose the main proof goal of forall  and
%implication form,    fix a rule {\tt r} and {\tt inv}, then have two
%assumptions {\tt  b1: inv$\in$ invariants N  and b2:r $\in$ rules
%N}, now we need show the goal {\tt invHoldForRule s f r (invariants
%N)}. line 5 splits cases of $r$ into all possible cases according to
%the definition of $rules~N$. %In order to save space, we adopt the following abbreaviation:
% $\mathsf{ex1P}~ N~ P \equiv \exists i. (i \le N \wedge P~
%i)$, $\mathsf{ex2P}~ N~ P \equiv \exists i~j. (i \le N \wedge j \le
%N \wedge i\ne j \wedge P~ i~j)$, and $\mathsf{ex3P}~ N~ P \equiv
%\exists i~j~k. (i \le N \wedge j \le N \wedge k \le N\wedge i\ne j
%\wedge i\ne k \wedge j\ne k \wedge P~ i~j~k)$.
%Line 6 starts the case analysis on
%$r=r_0$. Line 7 again splits cases of $inv$ into all possible cases
%according to the definition of $invariants~N$. Line 8-10 proves the
%goal at case when $r=exit$ and $inv=inv1$. At line 10,  a  proved
%lemma {\tt exitVsInv1}  is directly applied to solve the proof
%goal.  Similiarly, we can do subproofs on other cases on {\tt inv},
%and finish the proof goal accordingly.
% After finishing the proof of the last case  of $inv=inv5$,
% we finish the proof of the first case $r=exit$. Similarly, we can
% finish the proof goal at
%each subcase on {\tt r}. At  lines 19 and  20 we show we have
%finished the proof goal formally.

\subsection{Algorithms of Proof Generator {\sf proofGen}}

In this subsection, we illustrate the key techniques and algorithms of generation of the lemmas and their proofs in subsection \ref{subsection:introOfIsabelleProof}. Being according with the order in which we introduce the above lemmas, we also introduce their generation in a bottom-up order. First let us introduce the generation of a subproof according to a relation tag of $invHoldForRule_{1-3}$, which is shown in Algorithm \ref{alg:proofGenOfReltag}.

\begin{algorithm}
\caption{Generating a kind of proof which is according with a relation tag of $invHoldForRule_{1-3}$ : rel2proof}\label{alg:proofGenOfReltag}
\KwIn{A causal    relation item $relTag$}
\KwOut{  An Isablle proof: $proof$   }

{
 \If{$relTag=invHoldForRule_1$}
  {$proof \leftarrow $ sprintf\\
\twoSpaces"have invHoldForRule1 f r (invariants N)  \\
\twoSpaces         by(cut\_tac a1 a2 b1, simp, auto) \\
\twoSpaces then have invHoldForRule f r (invariants N)  by blast" \; }
 \ElseIf{ $relTag=invHoldForRule_2$}
  {$proof \leftarrow$  sprintf\\
\twoSpaces"have invHoldForRule2 f r (invariants N)
\twoSpaces         by(cut\_tac a1 a2 b1, simp, auto) \\
\twoSpaces then have invHoldForRule f r (invariants N)  by blast" \; }
 \Else{
 \label{label:getFormField}$f' \leftarrow getFormField(relTag)$\;
 $proof \leftarrow$ sprintf\\
\twoSpaces"have invHoldForRule3 f r (invariants N)  \\
\twoSpaces proof(cut\_tac a1 a2 b1, simp, rule\_tac x=\%s  in exI,auto)qed\\
\twoSpaces then have invHoldForRule f r (invariants N)  by blast" (symbf2Isabelle f')"\;}
\Return{proof}
}
\end{algorithm}

In the body of function {\sf rel2proof},  $sprintf$ writes a formatted data to string and returns it.
In line \ref{label:getFormField}, $getFormField(relTag)$ returns $f'$ if $relTag=invHoldForRule_3(f')$.  {\sf rel2proof} transforms a a relation tag into a paragraph of proof.% as shown in lines 7-8, 10-11, or 13-14.
If the tag is among $invHoldForRule_{1-2}$, the transformation is rather straight-forward, else the form $f'$ is assigned by the formula $getFormField(relTag)$, and provided to tell Isabelle the formula which should be used to construct the $invHoldForRule_3$ relation.

\begin{algorithm}
\caption{Generating one sub-proof for a subcase: oneMoreOverGen}\label{alg:MoreOver}

\KwIn{A formula $caseFsm$ standing for the assumption of the subcase, a relation item $relItem$ containing the information of causal relation }
\KwOut{  An Isablle proof: $subProof$ }
{
%$label \leftarrow labelGen(depth) $\;
$proof \leftarrow rel2proof(relItem)$\;
$  subProof \leftarrow$  sprintf\\
%\twoSpaces sprintf\\
\twoSpaces "moreover\{assume  b1:\%s  \\
           \%s    \} "\\
\twoSpaces ( asm, proof)\;
\Return{subproof}
}
\end{algorithm}

In Algorithm \ref{alg:MoreOver}, {\sf oneMoreOverGen} generates a subproof for a subcase in a proof of case analysis. It returns a subproof which is composed by filling an assumption of the subcase such as "\iR1=\iInv1" and a paragraph of proof generated by $rel2proof(relItem)$ into a format of block {\tt morover \{ ...\}}.  %the input $depth$ shows the  the depth of the current proof. Recalling that proof is recursively composed by subproofs. Each level of proofs are tagged with some depth. {\sf labelGen(depth)} returns a label such as $a1:$. {\sf oneMoreOverGen} generates a subproof which is

Due to the common use of case analysis proof of using {\sf moreover} and {\sf ultimately} commands, we design a generic program of generating  doing case analysis {\sf doCaseAnalz}. In algorithm \ref{alg:doCaseAnalz}, %generates a typical proof of doing case analyis.
 formulas standing for case-splitting $partition$, subproofs $subproofs$, and the conclusion $concluding$ are needed  in case analysis to fill the format.
\begin{algorithm}

\caption{Generating a whole proof of doing case analysis: doCaseAnalz}\label{alg:doCaseAnalz}
\KwIn{A formula $partition$ standing for case-splittings, a proof list $subproofs$ standing  all the subproofs of each subcases, concluding parts $concluding$}%, the depth of proof $depth$ }
\KwOut{  An Isablle proof: $proof$ }
{

%\If{$depth=1$}
%{$showOrHave \leftarrow$ "show"\;}
%\Else {$showOrHave \leftarrow$ "have"\;}
$proof \leftarrow $sprintf\\
\twoSpaces \twoSpaces  " have \%s  by auto\\
\twoSpaces \twoSpaces         \%s\\
\twoSpaces \twoSpaces        ultimately show \%s by auto"\\
\twoSpaces     (partition, subproofs,  concluding) \;
\Return{proof}
}
\end{algorithm}


In algorithm \ref{alg:doCaseAnalzI}, {\sf caseAnalzI} generates a typical proof of doing case analysis to  prove some causal relation hold between some rule and invariant. oneMoreOverGenI(case,rel) formula comes from the disjunction of formulas in the {\tt symbCases} field of $rec$, which is returned by $caseField(rec)$, subproofs $subproofs$ are generated by concatenation of all the subproofs, each of which is generated by $oneMoreOverGenI(case,rel)$. The proof is simply composed by  calling $doCaseAnalz(partition,subproofs,concluding)$.

\begin{algorithm}

\caption{Generating a whole proof of doing case analysis on parameters of rule and invariant: caseAnalzI}\label{alg:doCaseAnalzI}
\KwIn{A record $rec$ fetched from $symbCausal$ }
\KwOut{  An Isablle proof: $proof$ }
{
$cases \leftarrow caseField(rec)$\;
$rels \leftarrow relItems(rec)$;
$partition \leftarrow \bigvee cases$\;
$subproofs \leftarrow ""$\;
\While{$(cases \ne [])$}
{ $ case \leftarrow hd(cases)$ \;
  $cases \leftarrow tl(cases)$ \;
  $ rel \leftarrow hd(rels)$ \;
  $rels \leftarrow tl(rels)$ \;
  $subproofs \leftarrow subproofs \cat oneMoreOverGenI(case,rel)$\;
  }
$ concluding \leftarrow $"invHoldForRule s f r (invariants N) "\;
$proof \leftarrow doCaseAnalz(partition,subproofs,concluding)$\;
\Return $proof$
}
\end{algorithm}

Next we discuss how to generate assumptions on an invariant formula of an lemma such as $critVsInv1$. In the body of algorithm \ref{alg:asmGenOnInv}, $tbl\_element(symbInvs,  invName)$  retrieves the record on a invariant formula from $symbInvs$ to $invItem$ by its name $invName$, $invParaNum(invItem  )$ and $constrOfInv(invItem))$ return the field {\tt invNumFld} and {\tt constr} of  $invItem$ respectively. $invParasGen(lenPInv)$ generates a string of a list of actual parameters such as $iInv_1 ... iInv_{lenPInv}$ if $lenPInv>0$, else an empty string "".  At last, the assumption on the invariant is created by filling $invParas$,  $constrOnInv$, and $invName$ into a proper place in the format if needed.

\begin{algorithm}
  \caption{Generating an assumption on an invariant formula: asmGenOnInv}\label{alg:asmGenOnInv}
  \KwIn{An invariant name $invName$,    a table $symInvs$ storing invariant formulas   }

\KwOut{  An assumption on an invariant formula: $asm$   }

 $invItem   \leftarrow tbl\_element( symbInvs,  invName)$\;
  $lenPInv \leftarrow invParaNum(invItem  )$\;
  $invParas \leftarrow invParasGen(lenPInv)$\;
 % $constrOfInv \leftarrow constr(N,lenPInv)$\;
 $constrOnInv \leftarrow symbForm2Isabelle(constrOfInv(invItem))  $\;
 \If {lenPInv = 0}
  {$asm  \leftarrow  "a1: f="\cat invName   $\;}
  \Else{$asm  \leftarrow$ sprintf "a1: $\exists$ \%s. \%s $\wedge$ f=\%s \%s" (invParas,  constrOnInv, invName, invParas)\;}
  \Return{asm}
\end{algorithm}

Similar to {\sf asmGenOnInv}, {\sf obtainGenOnInv}, which is shown in algorithm \ref{alg:obtainGenOnInv}, generates a proof command of {\sf obtain} by retrieving and generating the related information and filling them in a format on {\sf obtain}.  Similar to {\sf asmGenOnInv} and  {\sf obtainGenOnInv}, {\sf asmGenOnRule} and  {\sf obtainGenOnRule} generate an  assumption and {\sf obtain} proof command   on a rule.

\begin{algorithm}
  \caption{Generating an {\sf obtain} proof command on an invariant formula: obtainGenOnInv}\label{alg:obtainGenOnInv}
  \KwIn{An invariant name $invName$,    a table $symInvs$ storing rules    }
  $invItem   \leftarrow tbl\_element( symbInvs,  invName)$\;
  $lenPInv \leftarrow invParaNum(invItem  )$\;
  $invParas \leftarrow invParasGen(lenPInv)$\;
\If {$  lenPInv = 0 $}
    {$obtain \leftarrow  ""$\;}
 \Else {$obtain \leftarrow$ sprintf "from a1 obtain  \%s where a1:\%s $\wedge$ f=\%s \%s by auto"\\
 \twoSpaces           $(invParas,  constrOnInv, invName, invParas)$\;}
 \Return{obtain}
\end{algorithm}



After the above preparing functions, now the generation of a lemma on the causal relation such as    $critVsInv1$ is rather easy, which is shown in algorithm \ref{alg:lemmaOnCausalRuleInv}. After generating an assumption on invariant formula $asm1$,  $asm2$ on a rule, an obtain command  $obtain1$ on the invariant, and  $obtain2$ on the rule,  $symRelItem$ is retrieved from $symCausalTab$ by $ruleName\cat invName$, and a proof $proof$ is generated by calling $caseAnalzI(symRelItem)$. At last these parts are filled into proper places in the lemma format.

\begin{algorithm}
\caption{Generating a lemma on a causal relation: lemmaOnCausalRuleInv}\label{alg:lemmaOnCausalRuleInv}

\KwIn{A parameterized rule name $ruleName$,   a formula name $invName$, a table $symRules$ storing rules , a table $symInvs$ storing invariant formulas,   a table $symCausalTab$  storing causal relation  }

\KwOut{  An Isablle proof script for a lemma: $lemmaWithProof$   }

{


 $asm1 \leftarrow asmGenOnInv(symbInvs,invName)$\;
 $asm2 \leftarrow asmGenOnRule(symbRules,ruleName)$\;
 $obtain1 \leftarrow obtainGenOnInv(symbInvs,invName)$\;
 $obtain2\leftarrow obtainGenOnRule(symbRules,ruleName)  $\;
  $symRelItem \leftarrow tbl\_element( symCausalTab,(ruleName\cat invName))$\;
 $proof \leftarrow caseAnalzI(symRelItem)$\;

$lemmaWithProof \leftarrow$ sprintf \\
\twoSpaces"lemma \%sVs\%s:\\
%2  assumes  a2: iR $\le$ N and a3: i1 $\le$ N and a4: i2 $\le$ N\\ generations assumptions
\twoSpaces assumes \%s and \%s\\
\twoSpaces  shows  invHoldForRule s f r (invariants   N)\\
\twoSpaces  proof -
\twoSpaces \%s~ \%s~  \%s

\twoSpaces qed"\\

\twoSpaces $(ruleName, invName, asm1,asm2, obtain1, obtain2, proof)$ \;
    \Return $lemmaWithProof$
}



\end{algorithm}




%\paragraph*{Algorithms of Proof Generator {\sf proofGen}}
%A lemma such as {\tt critVsinv1}  is generated by collecting all the information on   {\tt inv1} and   {\tt crit} in the generalization step discussed in Section \ref{sec:generalization}.
Due to length limitation, we illustrate the algorithm  for generating  a key part of the proof of the lemma {\tt critVsinv1}: the generation of a subproof (e.g., lines 7-8) according to a symbolic  relation tag of $\mathsf{invHoldRule}_{1-3}$, which is shown in Algorithm \ref{alg:proofGenOfReltag}. Input $relTag$ is the result of the   generalization step, which is discussed in Section \ref{sec:generalization}.
%\vspace{-0.8cm}
\begin{algorithm}
\caption{Generating a kind of proof which is according with a relation tag of $invHoldRule_{1-3}$ : rel2proof}\label{alg:proofGenOfReltag}
\KwIn{A symbolic causal    relation item $relTag$}
\KwOut{  An Isablle proof: $proof$   }

{
 \If{$relTag=invHoldRule_1$}
  {$proof \leftarrow $ sprintf\\
\twoSpaces"have invHoldRule1 f r (invariants N)  \\
\twoSpaces         by(cut\_tac a1 a2 b1, simp, auto) \\
\twoSpaces then have invHoldRule f r (invariants N)  by blast" \; }
 \ElseIf{ $relTag=invHoldRule_2$}
  {$proof \leftarrow$  sprintf\\
\twoSpaces"have invHoldRule2 f r (invariants N)
\twoSpaces         by(cut\_tac a1 a2 b1, simp, auto) \\
\twoSpaces then have invHoldRule f r (invariants N)  by blast" \; }
 \Else{
 \label{label:getFormField}$f' \leftarrow getFormField(relTag)$\;
 $proof \leftarrow$ sprintf\\
\twoSpaces"have invHoldRule3 f r (invariants N)  \\
\twoSpaces proof(cut\_tac a1 a2 b1, simp, rule\_tac x=\%s  in exI,auto)qed\\
\twoSpaces then have invHoldRule f r (invariants N)  by blast" (symbf2Isabelle f')"\;}
\Return{proof}
}
\end{algorithm}
%\vspace{-0.8cm}
In the body of function {\sf rel2proof},  $\mathsf{sprintf}$ writes a formatted data to string and returns it.
In line \ref{label:getFormField}, $\mathsf{getFormField}(relTag)$ returns the field of formula $f'$ if $relTag=\mathsf{invHoldRule_3}(f')$.  {\sf rel2proof} transforms a symbolic relation tag into a paragraph of proof, as shown in lines 7-8, 10-11, or 13-14.  %stored as an element in {\tt relationTags} field of an entry of $symbCausalTable$ on $\mathsf{crit}$ and $\mathsf{inv1}$.
If the tag is among $\mathsf{invHoldRule_{1-2}}$, the transformation is rather straight-forward, else the form $f'$ is assigned by the formula $\mathsf{getFormField(relTag)}$, and provided to tell Isabelle the formula which is used to construct the $\mathsf{invHoldRule_3}$ relation.

%Roughly speaking, the generation of a lemma such as {\tt critVsinv1} needs the information stored in the aforementioned three tables in the end of section \ref{sec:generalization}. Lines 1-4 can be generated by looking up information on {\tt inv1} in the table {\tt symbInvs} and that on {\tt crit} in {\tt symbRules}. Line 5 can be generated by combining the disjunction of elements of the {\tt symbCases} field of the entry of{\tt symbCausalTable} on {\tt crit} and {\tt inv1}, which is a command of case splitting. Lines 6, 9, 12 are generated by the elements of the {\tt symbCases} field of the entry respectively, which are assumptions of  subcases. Subproofs of subcases can be generated by Algorithm \ref{alg:proofGenOfReltag} according to three  elements in {\tt relationTags} field of the entry. Lines 15-16 are string with fixed pattern, which can be output directly.


%=========================================
%\vspace{-0.5cm}
\section{Experiments}\label{sec:experiments}
%=========================================
%\vspace{-0.5cm}
We implement our tool in Ocaml. %\cite{ocamlRef}.
 Experiments are
done with typical bus-snoopy benchmarks such as MESI and MOESI, as well as
 directory-based benchmarks such as  German and FLASH. The detailed codes and experiment data can
be found in \cite{LiCache16}. Each experiment data includes the
${\sf paraVerifier}$ instance, invariant sets, Isabelle proof
scripts.  Experiment results are summarized in Table \ref{Summarization of experiment results}.
 %Among the benchmarks, the German
%protocol   was posted
% as
% Among the benchmarks, a case study is done
%on a directory-based protocol, German protocol, which was posted as
%a challenge to the formal verification community by Steven German in
%2000. German protocol is a moderate case.
%To the best of our knowledge, few people but us give a complete proof to verify
%the mutual exclusion  property of the German protocol
 %in a theorem prover.
  %As Chou, Mannava, Park pointed out in \cite{Chou2004}, FLASH is a good benchmark for any proposed method for parameterized verification: ÔøΩÔøΩif the method works on FLASH, then there is a good chance that it will also work on many real-world cache coherence protocols ÔøΩÔøΩ. Therefore, our approach has reached this most important landmark. %From the line on the statistics on the FLASH, we can see the huge resource consumed by this case study. Such a big proof project is also a great challenge to a theorem prover like Isabelle. The total size of the proof scripts for FLASH verification is about 16M, which cann't be directly processed by Isabelle if we put all the proof scripts in a file. A file with 5000k is too large to be processed by Isabelle. Instead we have to divided   the proofs into small pieces, which are processed in some order. Therefore we work out a proof project control script in a {\tt ROOT} file to control the proof sessions. The proof consumptions of resources are according with the complexity of the problems. By the FLASH experiment, we demonstrate that ITP combined with automatic proof generation can handle industry-scale case like FLASH.


%There have been a lot of research papers in the field of  parameterized
%verification~\cite{Pnueli1996,Bj√∏rner1997,Arons2001,Pnueli2001,Tiwari2001,Chou2004,Pandav2005,Lv2007,cubicle2011}.


Among all the work in the  field of parameterized verification, only four of them have verified FLASH. The first full verification of safety properties of FLASH is done in \cite{Park1996a}. Park and Dill  proved the safety properties of FLASH using  PVS. % \cite{cade92-pvs}. %They introduce the aggressioned FLASH protocol, which
%is in fact an abstracted transaction version of FLASH,   need prove
%the correspondence between the abstract and the original FLASH
%protocol, and then prove the correctness of the abstracted protocol, and subsequently derive the correctness of  the
%original protocol by the correspondence.
The CMP method, which adopts parameter abstraction and guard strengthening, is applied %proposed
in~\cite{Chou2004} for verifying  safety properties  of
FLASH.  %An abstract instance of the parameterized protocol
%is constructed by a counter-example-guided refinement process.
McMillan applied compositional
model checking \cite{McMillan2001}  and used Candence SMV  to the verification of both safety and liveness properties of FLASH. Sylvain et.al have applied Cubeic to the verification FLASH \cite{cubicle2011,Conchon2013}, which is theoretically based on an SMT  model checking to the verification of array-based system.
 %All these four methods need auxiliary invariants.
 In the  former three methods \cite{Park1996a,Chou2004,McMillan2001}, auxiliary invariants are provided manually depending on verifier's deep insight in the FLASH protocol itself, while in Cubeic, auxiliary invariants are found automatically.  In  Cubeic, auxiliary invariants are searched backward  by a heuristics-guided algorithm with the help of an oracle (a reference instance of the protocol), but these auxiliary invariants are in concrete form, and are not generalized to the parameterized form. Thus there is no  parameterized proof derived for parameterized verification of FLASH.


The invariants-searching  algorithm used in our work differs from that in Cubeic \cite{cubicle2011,Conchon2013} in that the heuristics in our work are based on the construction of causal relation which is uniquely proposed in our work. Thus the auxiliary invariants in our work are different from those found in \cite{cubicle2011,Conchon2013}. Moreover, we generalize these concrete invariants and causal relations into a parameterized proof, and  generate a parameterized proof in Isabelle. The found invariants have abundant semantics reflecting the deep insight   of the FLASH protocol design, and the readable Isabelle proof script formally proves these invariants. In this way, we prove the protocol with the highest assurance. To the best of knowledge, this work for the first time automatically generates a proof of safety properties of full version of FLASH in a theorem prover without auxiliary invariants manually provided by people.






\begin{table}[!t]
\centering
\caption{\label{Summarization of experiment results}Verification results on benchmarks.}
%\vspace{-2mm}
\begin{tabular}{|c|r|r|r|r|}
\hline
Protocols &  \#rules & \#invariants & time (seconds) & Memory (MB) \\
\hline\hline
mutualEx & 4& 5 & 3.25 & 7.3  \\
\hline
MESI & 4& 3 & 2.47 & 11.5  \\
\hline
MOESI &  5& 3 &2.49 & 23.2  \\
\hline
Germanish~\cite{cubicle2011}  & 6&3&2.9 & 7.8   \\
%\hline
%German~\cite{Chou2004} & 13 & 24 & 4.09 & 26.7   \\
\hline
German~\cite{Chou2004} & 13 & 52 & 38.67 & 14  \\
\hline
FLASH\_nodata & 60 & 152 & 280 & 26  \\
\hline
FLASH\_data & 62 & 162 & 510 & 26  \\
\hline
\end{tabular}
%\vspace{-5mm}
\end{table}

%=========================================
%\vspace{-0.5cm}
\section{Conclusion }\label{sec:conclusion}
%\vspace{-0.5cm}
%=========================================
%Within {\sf paraVerifier},
%our automatic framework for parameterized verification of cache coherence protocol,
The originality of {\sf paraVerifier} lies in the following aspects:
(1) instead of directly proving the invariants of a protocol by induction, we propose a general
proof method based on the consistency lemma to decompose the proof goal into a number of small ones;
(2) instead of proving the decomposed subgoals by hand,
we automatically generate proofs for them based on the information of causal relation computed in a small protocol instance.%\footnote{Technical details
%of {\sf paraVerifier} will be made available in a technical report.}

As we demonstrate in this work, combining theorem proving with
automatic proof generation is promising in the field of formal
verification of industrial protocols. Theorem proving can guarantee the rigorousness of the verification results,
while automatic proof generation can release the burden of human interaction.

%\vspace{-0.5cm}
%\bibliographystyle{splncsnat}
\bibliographystyle{plain}
\bibliography{gste,cache,refer,bib-proanyIsabelle,lvyi}

\end{document}

\documentclass{llncs}
%%%%%%%%%%%%%%%%%%%%%%
%%%%   PACKAGES   %%%%
%%%%%%%%%%%%%%%%%%%%%%
\usepackage{makeidx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{latexsym}
\usepackage{url}
\usepackage{color}
\usepackage{isabelle}
\usepackage{isabellesym}
\usepackage{theorem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%For Isabelle code
\newlength{\fminilength}
\newsavebox{\fminibox}
\newenvironment{fmini}[1][\linewidth]
  {\setlength{\fminilength}{#1\fboxsep-2\fboxrule}%
   \vspace{2ex}\noindent\begin{lrbox}{\fminibox}\begin{minipage}{\fminilength}%
   \mbox{ }\hfill\vspace{-2.5ex}}%
  {\end{minipage}\end{lrbox}\vspace{1ex}\hspace{0ex}%
   \framebox{\usebox{\fminibox}}}

\newenvironment{specification}
{\noindent\scriptsize
\tt\begin{fmini}\begin{tabbing}X\=X12345\=XXXX\=XXXX\=XXXX\=XXXX\=XXXX
\=\+\kill} {\end{tabbing}\normalfont\end{fmini}}
\def \twoSpaces {\ \ }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%for comments
\newcommand\JP[1]{\textcolor{magenta}{JP: #1}}
\newcommand\lyj[1]{\textcolor{green}{lyj: #1}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Additional math operators
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[colorlinks,
            linkcolor=black,
            anchorcolor=black,
            citecolor=blue,
            urlcolor=black,
            bookmarks=true
            ]{hyperref}

\input{tcilatex}

%=========================================
\begin{document}

\title{ {\sf paraVerifier}: An Automatic Framework for Proving Parameterized Cache Coherence Protocols}
\titlerunning{{\sf paraVerifier}: An Automatic Proof Framework for Parameterized Cache Coherence Protocols}
\author{~}
\authorrunning{~}
\institute{~}

\maketitle

%-------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------
Parameterized verification of cache coherence protocols is an important
but challenging research problem.  In this paper, we present our tool {\sf paraVerifier}
to handle this research problem within a unified and automatic framework:
(1) it first discovers auxiliary invariants and the
corresponding causal relations between invariants and protocol rules from a
small reference instance of the verified protocol; (2) the discovered
invariants and causal relations can then be generalized into a parameterized
form to construct a formal proof to establish the correctness of the protocol.
%The principle underlying our generalization is symmetry mapping,
%and a novel feature of our work lies in that the last verification result of a
%protocol is provided by a formally readable proof in a theorem prover like Isabelle.
{\sf paraVerifier} has been successfully applied to typical benchmarks.

%-------------------------------------------------------------------------
\end{abstract}
%-------------------------------------------------------------------------

%=========================================
\section{Introduction}
%=========================================
Verification of parameterized concurrent systems is interesting in
the area of formal methods, mainly due to the practical importance
of such systems. Parameterized systems exist in many
application areas, including cache coherence protocols, security systems, and
network communication protocols. In this work, we
focus on cache coherence protocols, which play a key role in modern
computer architecture. They require complex algorithms that must
deal with asynchrony, unpredictable message delays, and multiple
communication paths between many nodes. Therefore, the highest
possible assurance for the correctness of these complex
parameterized systems should be guaranteed by formal reasoning
techniques.

The real challenge posed by parameterized verification of cache coherence protocols
is that the desired properties should hold in any instance of the parameterized
protocol, not just for a single protocol instance. Model checking is
automatic but is only able to verify an instance of the parameterized
protocol. The correctness of the reference instance does
not formally suffice to conclude the correctness for all instances.
Due to the extreme importance of many parameterized system, it is
preferable to have a proof that the correctness holds for any
instance.

Some advanced techniques such as compositional and abstraction model
checking are proposed to handle this challenge. However, auxiliary
invariants, which is usually provided by a human, based on his
insights of the verification cases, are needed to make these
techniques work. How to find sufficient and necessary invariants
is the core in the field of parameterized verification.
Many papers in the literature have focused on the
construction of a set of auxiliary
invariants, for example, see~\cite{Pnueli2001,Chou2004,Pandav2005,cubicle2011}.
Besides, the theoretical foundation of these techniques and their
soundness proofs are often only discussed in the respective papers.
%For instance, many of these theories contain the apparent circularity in reasoning and
%applying the auxiliary invariants, and are based on the classical
%notion of a so-called simulation proofs. Frankly speaking,
These theories themselves are not easy to understand, and are subjects
to be mechanically checked, since their soundness needs to be
guaranteed without any conditions.

The aim of our tool {\sf paraVerifier} is to solve the parameterized
verification of cache coherence protocols in a unified and automatic way.
{\sf paraVerifier} mainly consists of two parts:  an invariant finder {\sf invFinder}
and a proof generator {\sf proofGen}. In order to verify the that an
invariant $inv$ holds for any instance of a parameterizd protocol.
First, a reference model of the protocol with a fixed parameter
is constructed, and {\sf invFinder} tries to search for
interesting auxiliary invariants and causal relations which is
capable of proving $inv$. Next, {\sf proofGen}
uses the outputs of {\sf invFinder} to construct a complete and parameterized
formal proof in a theorem prover (e.g., Isabelle). Such a proof can eventually
be checked automatically.

The originality of our work lies in the following aspects:
\begin{itemize}
\item {\sf paraVerifier} is based on a simple but elegant theory. Three types of causal
relations between protocol rules and invariants are introduced, which are
essentially special cases of the general induction rule.
The correctness of the three causal relations is captured
by the so-called \emph{consistency lemma}.
One one side, it is heuristics inspired by trying to
construct the consistency relation that guides the tool {\sf
invFinder} to find auxiliary invariants. On the other side, the
consistency lemma provides a general guiding principle to prove
invariants  in the parameterized model of a cache coherence
protocol. Especially, the lemma itself is verified as a
formal theory in Isabelle.

\item {\sf paraVerifier} produces a list of interesting invariants
and a formally readable proof script for a given parameterized cache coherence protocol.
The invariants are visible,
which can characterise the semantical features of the protocol and aid human to
precisely understand the design of the protocol.
The formal proof script not only models the protocol
rigorously and specifies its properties without any ambiguity, but also
is mechanically checked in a theorem prover.
Therefore, it achieves the highest possible
assurance for formal reasoning of the protocol.

\item {\sf paraVerifier} is automatic and scalable.
After the protocol is modelled in {\sf paraVerifier}, auxiliary invariants
are searched automatically ({\sf invFinder}).
The formal proof script in Isabelle is also automatically generated ({\tt proofGen}),
and checked by Isabelle without human intervention.
Furthermore, our tool is able to handle industrial case studies such as
the Flash protocol, the German 2004 protocol, and the Godson-T protocol.
\JP{add references to the protocols.}
\end{itemize}

To the best of our knowledge, {\sf paraVerifier} is the first tool
that generates automatically formal proofs in a theorem prover for
parameterized verification of cache coherence protocols.

%\JP{The following part needs revision and will be moved to evaluation/case studies section.}
%Besides, we also generate a new
%proof for original flash protocol without adding new auxiliary
%variables. This proof is different from those of Park et al \cite{}
%because  they introduce the aggressioned Flash protocol model, which
%is in fact an abstract transaction model of Flash,   need prove
%the correspondence between the abstract model and the original Flash
%model, and then prove the correctness of the protocol in the abstract
%model, and subsequently derive the correctness of protocol in the
%original model by the correspondence. New   auxiliary state variables
%like {\tt fwdSrc} are   introduced  for verification.
%Deep human insight for Flash is needed for both the construction of the aggressioned model
%and  introducing new state variables.  Later research on Flash must also rely on these auxiliary
%variables for verification. Our work need fewer human's aid in the verification of Flash.


%=========================================
%\section{The Design Principle of {\sf paraVerifier}}
%=========================================

\section{Theory foundation}
In this section, we introduce the theory foundation underlining {\sf paraVerifier}. Consider a set of state variables $V$, we use $e$, $f$ and $S$ to denote an
expression, a formula, and a statement over the set of state
variables $V$.
\JP{The above notations are not used in the following discussions.}
Variables are divided into two categories: array variables or
non-array (global) variables. \JP{Explain more about the two categories.} A state $s$  of a protocol is an
instantaneous snapshot of its behaviour given by a mapping from
variables $V$ to natural numbers.  We write
$\mathsf{expEval}~e~s$ (and $\mathsf{formEval}~f~s$) to denote the
evaluation of the expression $e$ (and formula $f$) at the state $s$.
\JP{$s$ is not introduced before.}  Consider a parallel assignment $S=\{x_i:=e_i | i>0\}$,
we define $\mathsf{preCond}~S~f=f[x_i:=e_i]$, which substitutes each
occurrence of $x_i$ by $e_i$.


\paragraph*{Protocols.} A protocol is formalized by a pair
$(ini,rules)$, where
%
\begin{itemize}
\item $ini $ is an initialization formula; \JP{What is a predicate?}

\item $rules$ is a set of transition rules, each of which is defined as
  $g \vartriangleright  S$, where $g$ is a predicate, and $S$ is a
  parallel assignment to distinct  variables $v_i$ with expressions
  $e_i$. We write $\mathsf{pre}~r=g$, and $\mathsf{act}~r=g$ if $r=g \vartriangleright
  S$.
\end{itemize}



%\section{Consistency Lemma}
A novel feature of our work lies in that three kinds of causal
relations are exploited, which are essentially special cases of the
general induction rule.

 Consider a rule $r$, a formula $f$, and a formula set $fs$, three
 kinds of causal relations are defined as follows:

\begin{definition}  Relation
$\mathsf{invHoldForRule_1} ~f ~r$ if    $ \mathsf{pre}~ r
\longrightarrow \mathsf{preCond}~ f ~(\mathsf{act}~ r)$ ;
$\mathsf{invHoldForRule_2}~ f~ r$ if $f = \mathsf{preCond}~ f
(\mathsf{act}~ r)$; $\mathsf{invHoldForRule_3}~ f~ r ~fs$ if there
exits a formula $f'$ in $fs$ such that
  $(f' \wedge (\mathsf{pre}~ r)) \longrightarrow \mathsf{preCond} ~f ~(\mathsf{act}
  ~r)$; $\mathsf{invHoldForRule}~ f~ r ~fs$ holds if $\mathsf{invHoldForRule_1} ~f
  ~r$, or $\mathsf{invHoldForRule_2} ~f ~r$, or $\mathsf{invHoldForRule_3}~ f~ r
  ~fs$ holds.
\end{definition}

 We can view the relation $\mathsf{invHoldForRule}~ f
r ~fs$ in two ways. Firstly it defines some causality relation
between $inv$, $r$, and $invs$.  $\mathsf{invHoldForRule}_1~f~ r$
  means that after rule $r$ is executed,
 $f$ will be true immediately;   $\mathsf{invHoldForRule}_2~f~ r$ specifies that
 $\mathsf{preCond}~S~f=f$, intuitively this means that none of state variables in $f$ is
 changed, and the execution of statement $S$ does not affect the
 evaluation of $f$.
 $\mathsf{invHoldForRule}_3~f~ r~invs$ states
  that  there exists another invariant $f' \in invs$ such that
  the conjunction of the guard of $r$ and $f'$ implies the precondition  $\mathsf{preCond}~S~f$.
Intuitively, $\mathsf{invHoldForRule} ~f ~r ~fs$ defines a causal
relation, which can guaranttee that if each of formula in $fs$ holds
before the execution of the rule $r$, then  $f$ also holds after the
execution of the rule $r$ f. Secondly the relation
$\mathsf{invHoldForRule} ~f ~r ~fs$ can also be regarded as a
special kind of inductive proof rules, which can be applied to prove
each formula in $fs$ holds at each inductive protocol rule cases.


\begin{definition}
A consistency relation $\mathsf{consistent}~ invs ~ini~ rs$,
 which holds between a protocol $(inis,rs)$ and
a set of invariants $invs=\{inv_1,\ldots, inv_n\}$,  is defined as
follows:
%
\begin{itemize}
\item For any invariant $inv \in invs$,
initializing predicate $ini \in ini$, and state $s$, if $ini$ is
evaluated true at state $s$, then $inv$ is also evaluated true at
state $s$.

\item For any invariant $inv \in invs$, $r$ in the rule set
$rs$, either one of the following five types of relation holds,
i.e., $\mathsf{invHoldForRule_{1-3}}~inv~ r$.

\end{itemize}
\end{definition}


Now we   formally prove the essence of the aforementioned
causality. Suppose that the consistency relation
$\mathsf{consistent}~ invs ~inis~ rs$ holds, for any $inv \in invs$,
$inv$ holds for any reachable state $s$ such that $s  \in
\mathsf{reachableSet}~ ini~ rs$. This is formalized by a so-called
consistency lemma.

\begin{lemma}\label{consistentLemma}[(consistency lemma)]
  $\isasymlbrakk \mathsf{consistent}~ invs ~ini~ rs$; $s  \in \mathsf{reachableSet}~ ini~ rs$
  $\isasymrbrakk\Longrightarrow$ $\forall inv. inv \in invs \longrightarrow
\mathsf{formEval}~ inv ~s$.
\end{lemma}

A general theory to model cache coherence protocols are formalized in {\tt cache.thy}, and the consistency lemma is formally proved. Thus
the theory foundation itself is verified, and will be imported as a library theory in a case study of sample protocol.



\section{An overview of problem formulation and our solution to
parameterized verification}

The general architecture of  our solution  to parameterized
verification is illustrated in Fig.~\ref{fig:arch}. A small
cache coherence protocol instance {\tt a.fl}, is fed into the
\texttt{invFinder}. The task of tool \texttt{invFinder} is to find
all the necessary ground auxiliary invariants from the reference
protocol instance.
 A table {\tt a.tbl} is worked out  to store the set of ground invariants and
 causal relations, which will be  used by {\tt proofGen} to
create an Isabelle proof   script which models and verifies the
protocol in a parameterized form. In this step, ground invariants
will be generalized into a parameterized form, and accordingly
ground causal relations will be adopted to create parameterized
proof commands which essentially proves the existence of the
parameterized causal relations. At last the Isabelle proof script is
fed into   Isabelle to check the correctness of the protocol.


The consistency lemma is the cornerstone in our framework.  One one
side, it is heuristics to construct a consistency relation that
guides the tool {\sf invFinder} to find auxiliary invariants. On the
other side, the consistency lemma gives a general guiding principle
to prove invariants of a cache coherence protocol. Especially the
consistency lemma eliminates the need of directly using the
induction proof method. It allows us to focus on  the causal
relationship between transition rules of the protocol and
invariants. It allows us to divide the proof of the invariants to a
series of subproofs to verify whether one of the relations
$\mathsf{invHoldForRule_{1-3}}$ hold
  for  a rule  and an invariant. This strategy of dividing and
  conqueing is also the key point to make the series of sub-proofs
  to be automated because the proof patterns for the  subproofs  are similar
  and modular. To sump up, the tool \texttt{proofGen} will
  automatically generates a proof that applies the the consistency
  lemma to prove the correctness of the protocol.


 \begin{figure}[!ht]
% \centering %
 \vspace{-0.8cm}
\includegraphics[width=1.0\textwidth]{invFinderArchClipA.pdf}
%\vspace{-0.5cm}
 \caption{The architecture of {\sf paraVerifier}}
\label{fig:arch}
\end{figure}
 \vspace{1cm}


\section{An illustrating example}
In this section, we use the verification of {\tt mutual}   to illustrate the function of the tool.
We only need write a protocol model in our modelling language FL, the core of which is shown as below:
\\
\begin{specification}\label{spec1}
1\twoSpaces   pIni  N $\equiv$
   x=true $\wedge$ (forallForm N ($\lambda$ i. n[i]=I))\\

2\twoSpaces    try i $\equiv$ n[i] = I $\vartriangleright$ n[i] := T; \\

3\twoSpaces    crit i $\equiv$ n[i] = T\& x = true $\vartriangleright$  n[i] := C; x := false;  ;\\

4\twoSpaces   exit i $\equiv$ n[i] = C $\vartriangleright$ n[i] := E; \\


5\twoSpaces   idle  i $\equiv$  n[i] = E $\vartriangleright$ n[i] := I;  x := true;\\% \\

6\twoSpaces   prules  = [(``crit", crit), (``exit", exit), ("idle",idle),("try",try)]\\
%\\

7\twoSpaces inv1 i j $\equiv$
  $\neg$ (n[i]= C $\wedge$ n[j]= C)\\

8\twoSpaces  search prules 3 [mutualInv 1 2] "mutual" \\

9\twoSpaces  createIsabelleModel pini "mutual" \\


\end{specification}%\caption{Modelling the protocol mutual in FL}

Line 1 defines an form to specify the initial state; lines 2-5 specifies four rules; line 6 defines the set of all the rules and names them;
 line 7 defines the mutual exclusion property; line 8 is a command to tell {\sf invFinder} to search auxiliary invariants from a the reference instance with 3 nodes,   the starting invariant is {\tt inv1  1 2}, and the output results are stored in a file "mutual"; Line 9 is a command to tell {\sf proofGen}
  to create a parameterized Isabelle proof script for the protocol.

 The output of the {\sf invFinder}, which is stored in file "mutual.tbl",  is shown in Table
\ref{label-ground-causal relation}. In the table,  each line records the    index of a normalized   invariant, name of a parameterized rule, the rule
  parameters to instantiate the rule, a causal relation between
  the ground invariant and a kind of causal relation which involves the kind and proper formulas
  $f'$   in need (which are used to construct
      causal relations $\mathsf{invHoldForRule}_3$. The auxiliary invariants found by {\sf invFinder} includes: $\mathsf{inv_2}  \equiv  \neg (x=true  \wedge  n[1]=C)$, $\mathsf{inv_3}    \equiv \neg  ( n[1]=C \wedge n[2]=E)$,
$\mathsf{inv_4}  \equiv  \neg (x=true  \wedge  n[1]=E)$,   $\mathsf{inv_5}    \equiv \neg  ( n[1]=C \wedge n[2]=C)$.

 \begin{table}[!t]
\centering \caption{A fragment of output of {\sf invFinder}}\label{label-ground-causal relation} % {\tt
%simpMutual.tbl}
\begin{tabular}{|c|c|c|c|c|  }
\hline
  rule& ruleParas&inv&causal relation &   f'  \\
\hline
  .. & ..&.. &..&.. \\

\hline
  crit  & [1]&inv$_1$ 1 2& invHoldForRule3 &inv$_2$~2 \\
\hline
  crit &[2]& inv$_1$ 1 2& invHoldForRule3 &inv$_2$~1  \\
\hline
  crit & [3]& inv$_1$ 1 2 & invHoldForRule2  & \\
\hline
  .. & ..&.. &..&.. \\
\hline
\end{tabular}
\end{table}

A  formal Isabelle proof script generated by {\sf proofGen}
includes the definitions of control signals, rules, invariants, initializing formula,
lemmas and their proofs. Some main definitions and lemmas of the case {\tt mutual} are listed as follows: %The %lemmas are devided into three categories: (1) a lemma which specifies and proves  that if a state $s$ satisfies %$formEval~(pIni~N)~s$, then
% $\mathsf{formEval}~(inv~i)~s$ (or  $\mathsf{formEval}~(inv~i~j)~s$); (2) a lemma   that $\mathsf{invHoldForRule}~(rule~iR)~(inv~i_1)$ (or %$\mathsf{invHoldForRule}~(rule~iR)~(inv~i_1~i_2)$; (3) the main lemma that if a state $s \in \mathsf{reachableSet}~{pIni~N)~(prules~N)$, then
% for all invariants $inv$ such that $inv \in (\mathsf{invariants}~N)$, $\mathsf{formEval}~inv~s$.

\begin{specification} \label{spec2}

\noindent 1\twoSpaces "pIniN  N $\equiv$  andList [ iniStateSpecOfx ,   iniStateSpecOfn N ]\\

2\twoSpaces
prules N$\equiv$ \{r. ex1P N ($\lambda$i.  r=crit i)  $\vee$
ex1P N ($\lambda$i.  r=exit i)  $\vee$\\
ex1P N ($\lambda$i.  r=idle i)  $\vee$
ex1P N ($\lambda$i.  r=try i)  \}\\




3\twoSpaces
invariants N$\equiv$ \{f. ex2P N ($\lambda$ i j.  f = inv1 i j)  $\vee$
ex1P N ($\lambda$ i.  f= inv2 i)  $\vee$\\
ex2P N ($\lambda$ i j.  f = inv3 i j)  $\vee$
ex1P N ($\lambda$ i.  f= inv4 i)  $\vee$\\
ex2P N ($\lambda$ i j.  f = inv5 i j)   \}\\

4\twoSpaces lemma initImpInv1:
    $\isasymlbrakk$
i1 $\le$ N;
i2
$\le$ N;
i1$\neq$i2; $\mathsf{formEval}$~(pIni~N)~s
    $\isasymrbrakk\Longrightarrow$\\
invHoldForRule' (inv1  i1 i2 ) (crit iR1 ) (invariants   N)
 % (is $\forall$s. ?P1 s$\vee$?P2 s$\vee$?P3 s
)\\

5\twoSpaces lemma critVsInv1:
    $\isasymlbrakk$
iR1 $\le$ N;
i1 $\le$ N;
i2
$\le$ N;
i1$\neq$i2
    $\isasymrbrakk\Longrightarrow$\\
invHoldForRule' (inv1  i1 i2 ) (crit iR1 ) (invariants   N)
 % (is $\forall$s. ?P1 s$\vee$?P2 s$\vee$?P3 s
)\\

6\twoSpaces lemma main:
   $\isasymlbrakk$
s $\in$ reachableSet { pIni  N} (rules N);
0<N

   $\isasymrbrakk\Longrightarrow$\\
$\forall$inv. inv $\in$(invariants N)$\longrightarrow$
formEval
inv s\\
%\caption{Isabelle proof script for verifying  mutual }
\end{specification}



Line 1 defines the specification formula of  in a paramaterized instance with $N$ nodes, where $N$ is only a symbolic parameter. Line 2    all the rules; Line 3   all the   invariant formulas.   Line 4 specifies   a lemma that if the initial specification formula is evaluated true at a state $s$, then   invariant formula {\tt inv1}   is evaluated true too at  $s$. Line 5 a lemma that the causal relation holds between rule {\tt crit} and invariant {\tt inv1}. Lemma 6 the main lemma that  for all invariants $inv$ , for all reachable state $s$, $inv$ is evaluated to be true at state $s$. Here we briefly explain the generalization principle involved in {\tt proofGen}. For a ground formula $gInv$ with actually ground parameters, such as $\neg  ( n[1]=C \wedge n[2]=C)$, accordingly {\tt proofGen} analyzes the number  of ground parameters (1,2,3), defines a formal parameterized $pInv$ with the same number of formal
 symbolic parameters ($i_1$, $i_2$, $i_3$), ......  by replacing   with
  symbolic  accordingly; then
  uses the $ex1P$ or $ex2p$ or $ex3P$ to define all the actually parameterized
  invariants, where $\mathsf{ex1P}~ N~ P \equiv \exists i. (i \le N \wedge P~
i)$, $\mathsf{ex2P}~ N~ P \equiv \exists i~j. (i \le N \wedge j \le
N \wedge i\ne j \wedge P~ i~j)$, and $\mathsf{ex3P}~ N~ P \equiv
\exists i~j~k. (i \le N \wedge j \le N \wedge k \le N\wedge i\ne j
\wedge i\ne k \wedge j\ne k \wedge P~ i~j~k)$.  For instance, for the formula $\neg  ( n[1]=C \wedge n[2]=C)$, two ground parameters 1 and 2 are extracted, and
 a formal invariant formula $inv_1~i1~i2=\neg  ( n[i1]=C \wedge n[i2]=C)$ is defined by replacing 1 and 2 with formal parameters $i1$ and $i2$, $\{f.
\mathsf{ex2P}~ N~ \lambda i1 i2. f= inv_1~i1~i2\}$ defines the set of  all the formulas, each of which is symmetric to $inv_1~1~2$. The generalization of statements, rules, and causal relations can be defined accordingly. Each line in the ground causal relation table shown in Table \ref{label-ground-causal relation}, is generalized into a parameterized relation,  which is key to generate a proof command to select a proper causal relation to prove. The generalization is another core technique to generate automatically a parameterized proof script besides the consistency lemma.




%-------------------------------------------------------------------------



%=========================================
\section{Verification products}
%=========================================

After the auxiliary invariants are found,  the formula set  in Table \ref{label-ground-causal relation}   can be used to analyze
 and verify the design  of the protocol. In fact, they gives a complete
logical characterization of the semantics of the protocol. It will gives a deep insight of the protocol. These properties are divided into two categories: (1) correspondence between
control signals; (2)mutual exclusion between control signals. For instance, the intuitive meaning of the invariants is analyzed as follows:

\begin{table}[htbp] \label{Summarization of invariants}
\centering \caption{Summarization of invariants}
\begin{tabular}{|c|c| }
\hline
invariant &  meaning  \\
\hline
$\mathsf{inv1}~ i ~j$ &  the mutual exclusion between n[i]=C and n[j]=C \\
\hline
$\mathsf{inv2} ~i$& Once some n[i] is set C, the flag x will be set false \\

\hline
$\mathsf{inv3}~ i ~j$ &  the mutual exclusion between n[i]=C and n[j]=E \\
\hline
$\mathsf{inv4} ~i$&  Once some n[i] is set E, the flag x will be set false \\

\hline
$\mathsf{inv5}~ i ~j$ &  the mutual exclusion between n[i]=E and n[j]=E \\
\hline
\end{tabular}
\end{table}
%$\mathsf{invOnX_1} ~i$ specifies that the flag $x$ shows the
%availability of the critical section. Once some node state variable
%$n[i]$ is set $C$ or $E$, $x$ will be set $true$. Formulas
%$\mathsf{mutualInv}~ i ~j$, $\mathsf{aux_1} ~i~j$, and
%$\mathsf{aux_2} ~i~j$ state the mutual exclusion properties between
%a node's $\mathsf{C}(\mathsf{E})$ state and another different node's
%$\mathsf{C}(\mathsf{E})$ state.
The causal relations listed in Table \ref{label-ground-causal relation} illustrate why the invariants hold  after a rule is executed.
That is to say, for a rule $r$ and an $inv$ descriibed in a line, one of the three causal relation $\mathsf{invHoldForRule}_{1\_3}$ holds, so an invariant holds after the execution the rule $r$. The Isabelle proof-script formally generalizes these causal relation into parameterized form and proved the existence of the  causal relations.

A special feature of our tool is that both the found invariants are ``visible" to the practical designers of the protocol and the Isabelle proof script is readable. The above invariants is  ``visible"  in that they have
 very clearly intuitive semantics which are according with the design ideas of the protocol, and can be understood by the engineers. Our Isabelle proof script is written in Isar language, which  is the abbreviation of the phrase ¡°Intelligible semi-automated reasoning¡±.
Isar is offered as an alternative proof language interface layer beyond traditional tactical scripts. In Isar proof
language, our formal proof theory is more readable for human beings.


%At last, a main lemma formally specifies that why the invariants hold forever at any reachable state set, and is formally proved by using the consistency lemma.


%=========================================
\section{Experiments}
%=========================================
We implement our tool in Forte \cite{Forte}. More experiments are
done including typical bus-snoopy ones such as MESI and MOESI,
 directory-based ones such as  Germanish, German protocols. Hard cases Godson-T and Flash are also done. The detail experiment codes and data can
be found in \JP{\cite{LiCache14}}. Each experiment data includes the
${\sf paraVerifier}$ model, invariant sets found, Isabelle proof
scripts. A table
summarizes  our experiments below. Among the benchmarks, the German
protocol   was posted
 as
% Among the benchmarks, a case study is done
%on a directory-based protocol, German protocol, which was posted as
a challenge to the formal verification community by Steven German in
2000. German protocol is a moderate case.  Flash is a well-known hard case, which is soledmly verified automatically. In the literature, much human interaction and profound knowledge to the Flash protocol are needed to verify it.  Godson-T is   is a cache
coherence protocol adopted in a mutlti-core NOCs, which is designed
by the CAS. Because Godson-T is applied in many safety-critical application fields of China, the designers furthermore requires a formal stuff to prove its correctness after finishing testing and model checking a small instance of the protocol. The designers are also happy with our verification products we provide because the found invariants are according with their design intuition. 
To the best of our knowledge, few people gives a complete proof to verify
the mutual exclusion  property of the German protocol
 in a theorem prover. This demonstrates the complexity of the parameterized verification in this field. Without a proof generator like {\tt proofGen}, it is too difficult to finish such a proof because the case analysis involved are too many to be manipulated by human being. 

 \begin{table}[htbp] \label{Summarization of experiment results}
\centering \caption{Summarization of results on benchmarks}
\begin{tabular}{|c|c|c|c|c|}
\hline
protocol &  ruleNum & invariantNum & time(s) & memory(M) \\
\hline
simpMutual& 4& 5 & 5.66 & 10.3 \\
\hline
MESI & 4& 3 & 4.66 & 11.5  \\
\hline
MOESI &  5& 3 &3.98 & 11.3  \\
\hline
 German-ish  & 6& 4 &35.8 & 15.1   \\
\hline
German & 13 & 48 & 1222.2 & 16.1   \\
\hline
German with data & 13 & 48 & 1222.2 & 16.1   \\
\hline
Flash & 13 & 48 & 1222.2 & 16.1   \\
\hline
Godson-T & 13 & 48 & 1222.2 & 16.1   \\
\hline
\end{tabular}
\end{table}

%=========================================
\section{Conclusion}
%=========================================
Our case studies on cache coherence protocols are typical examples
to illustrate the guiding principle of {\sf paraVerifier}. The
 consistency lemma based on the induction approach, is the
core of our work, which gives the heuristics to guide the tool
 to search invariants. Instead of ``invisible invariants in previous work
 (see e.g,~\cite{Pnueli2001}, our invariants are visible,
 which can be further refined to precisely
 analyze the correctness of the protocol both in theoretical and practical aspects.

\bibliographystyle{splncsnat}
\bibliography{gste,cache,refer}
\end{document}


\end{document}

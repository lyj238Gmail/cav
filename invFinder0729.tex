\documentclass{llncs}
%%%%%%%%%%%%%%%%%%%%%%
%%%%   PACKAGES   %%%%
%%%%%%%%%%%%%%%%%%%%%%
\usepackage{makeidx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{latexsym}
\usepackage{url}
\usepackage{color}
\usepackage{isabelle}
\usepackage{isabellesym}
\usepackage{theorem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%For Isabelle code
\newlength{\fminilength}
\newsavebox{\fminibox}
\newenvironment{fmini}[1][\linewidth]
  {\setlength{\fminilength}{#1\fboxsep-2\fboxrule}%
   \vspace{2ex}\noindent\begin{lrbox}{\fminibox}\begin{minipage}{\fminilength}%
   \mbox{ }\hfill\vspace{-2.5ex}}%
  {\end{minipage}\end{lrbox}\vspace{1ex}\hspace{0ex}%
   \framebox{\usebox{\fminibox}}}

\newenvironment{specification}
{\noindent\scriptsize
\tt\begin{fmini}\begin{tabbing}X\=X12345\=XXXX\=XXXX\=XXXX\=XXXX\=XXXX
\=\+\kill} {\end{tabbing}\normalfont\end{fmini}}
\def \twoSpaces {\ \ }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%for comments
\newcommand\JP[1]{\textcolor{magenta}{JP: #1}}
\newcommand\lyj[1]{\textcolor{green}{lyj: #1}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Additional math operators
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[colorlinks,
            linkcolor=black,
            anchorcolor=black,
            citecolor=blue,
            urlcolor=black,
            bookmarks=true
            ]{hyperref}

\input{tcilatex}

%=========================================
\begin{document}

\title{ {\sf InvFinder}: An Invariant Finder for Parameterized Verification of Cache Coherence Protocols}
\titlerunning{InvFinder: An Invariant Finder}
\author{~}
\authorrunning{~}
\institute{~}

\maketitle

%-------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------
The crux of parameterized verification of cache coherence protocols
is the construction of a set of auxiliary invariants. Our tool  {\sf
InvFinder} handles this hard problem and it is guided by heuristics
inspired by a so-called consistency lemma to discover auxiliary
invariants from a small reference instance of the verified protocol.
The invariants and the corresponding information found by {\sf
InvFinder} can be used to construct a formally parameterized proof
in a theorem prover (e.g., Isabelle) to prove the correctness of the
protocols. Moreover, using the discovered invariants, a guided
simulation flow of a single process can be provided to the
engineers. Our method is successfully applied to some typical
benchmarks including some snoopy-based and directory-based.

%-------------------------------------------------------------------------
\end{abstract}
%-------------------------------------------------------------------------

%=========================================
\section{Introduction}
%=========================================
Verification of parameterized concurrent systems is interesting in
the area of formal methods, mainly due to the practical importance
of such systems. Parameterized systems exist in many important
application areas: cache coherence protocols, security systems, and
network communication protocols, \emph{etc}. In this work, we will
focus on cache coherence protocols. The challenge posed by
parameterized verification is that the desired properties should
hold in any instance of the parameterized system. The core of
parameterized verification is the construction of a set of auxiliary
invariants~\cite{Pnueli2001,Chou2004,Pandav2005,cubicle2011}, which
are either used for inductive verification or abstraction model
construction. Therefore, how to find these auxiliary invariants is
the central problem in the research field of parameterized
verification.

The aim of tool {\sf InvFinder} is to find auxiliary invariants from
a protocol instance with fixed size. {\sf InvFinder} can be regarded
as both a  prover and a finder. Given an invariant $inv$ in an
invariant set $invs$, and a rule $r$ in a set of protocol rules
$rs$, {\sf InvFinder} works in a very simple way:  it tries to prove
the existence of some kind of casual relations between $r$ and
$inv$, then it tries to construct a new invariant $inv'$ and adds it
into the invariant set $invs$ if the current proving step is
blocked. At this time, it will analyze the form of rule and
invariant, then create new invariants. This searching procedure
stops until no new invariants are created. The orginality of our
work lies the following aspects: (1) {\sf InvFinder} is guided by
heuristics inspired by a so-called principle of consistency lemma,
which specifies several kinds of  casual relations which hold
between  of a set of invariants with the transition rules the
protocol instance;~\cite{LiCache13} (2) Although the invariants are
created from a finite protocol instance, they can be refined to
either construct a completely formal proof in a theorem prover(e.g.,
Isabelle) or an abstract model which fully models the behavior of a
single client. Here we emphasize that either the proof and the
abstract model can account for any parameterized model of the
protocol under study. The formal proofs and the abstract model with
the interpretation of the invariants can be used as the formal
documents of the analysis of the protocols.

%=========================================
\section{The Design Principle of {\sf InvFinder}}
%=========================================
Consider a set of state variables $V$,
$e$, $f$ and $S$ are an expression, a formula, and a statement over
the set of state variables $V$. A cache coherence protocol is formalized by a pair $(inis,rules)$,
where
%
\begin{itemize}
\item $inis $ is a set of initialization predicates;

\item $rules$ is a set of transition rules, each of which is defined as
  $g \vartriangleright  S$, where $g$ is a predicate, and $S$ is a
  parallel assignment to distinct  variables $v_i$ with expressions
  $e_i$.
\end{itemize}

A  state of a protocol $s$ is an instantaneous snapshot of its
behaviour given by a mapping from variables to their values. We
write $\mathsf{expEval}~e~s$ ($\mathsf{formEval}~f~s$) to denote the
evaluation of the expression $e$ (formula $f$) at the state $s$. %\lyj{$\mathsf{formEval}~f~s$)}
 Consider a parallel assignment
$S=\{x_i:=e_i | i>0\}$, we define
$\mathsf{preCond}~S~f=f[x_i:=e_i]$, which substitutes each occurrence
of $x_i$ by $e_t$. As usual, the reachable state set
$\mathsf{reachableSet}~ inis ~rules$ of the protocol $(inis,rules)$
can be inductively defined as usual: (1) a state $s$ is in
$\mathsf{reachableSet}~inis~ rules$ if
 there exists a formula $ini$ that is true in state $s$; (2) a result state $s'$, which is reached by triggering and
 executing a rule $r$ ,is also in
 $\mathsf{reachableSet}~inis~ rules$ if $s$ already is in
 $\mathsf{reachableSet}~inis~ rules$ and $r $ $\in$  $rules$.

Consider a protocol $(inis,rules)$, a natural
idea is to inductively define the reachable state set of a
parameterized protocol instance and to prove inductively a
property, in terms of an invariant $inv$, of the reachable state set.
However, it is usually too difficult to directly inductively prove the invariant under study.
We usually need to strengthen $inv$ into a stronger form:
$inv_1\wedge ...\wedge inv_n \wedge inv$.
How to figure out the set of auxiliary invariants ($inv_i$)
is always the central task of our tool {\sf InvFinder}.

Being different from previous work, {\sf InvFinder} is centered with
a so-called consistency relation $\mathsf{consistent}~ invs ~inis~
rs$,
 which holds between a protocol $(inis,rs)$ and
a set of invariants $invs=\{inv_1,\ldots, inv_n\}$.
The consistency relation captures the following two aspects:
%
\begin{itemize}
\item For any invariant $inv \in invs$,
initializing predicate $ini \in inis$, and
state $s$, if $ini$ is evaluated true at state $s$, then $inv$ is
also evaluated true at state $s$.

\item For any invariant $inv \in invs$, $r$ in the rule set
$rs$, either one of the following five types of relation holds,
i.e., $\mathsf{invHoldForRule_{1-5}}~inv~ r$.
%
%$\mathsf{invHoldForRule1 }~inv~ r$,
%$\mathsf{invHoldForRule2 }~inv~ r$, $\mathsf{invHoldForRule3 }~inv~
%r~invs$, or $\mathsf{invHoldForRule4 }~inv~ r~invs$ holds, or
%$\mathsf{invHoldForRule5}~inv~ r~invs$ holds.
%
Formally, let $r=g \vartriangleright  S$, $inv=ant \longrightarrow
cons$, where $cons$ is an atomic formula.
$\mathsf{invHoldForRule}_1~inv~ r$ is formally defined by
 $\mathsf{preCond}~S~inv=true$, which means that after rule $r$ is executed,
either the antecedent $ant$ is disabled or the consequent $cons$ is
enabled at the resulting state;
 $\mathsf{invHoldForRule}_2~inv~ r$ specifies that
 $\mathsf{preCond}~S~inv=inv$, intuitively this means that none of state variables in $inv$ is
 changed, and the execution of statement $S$ does not affect the
 evaluation of $inv$.
 $\mathsf{invHoldForRule}_3~inv~ r~invs$ states
  that $\mathsf{preCond}~S~cons=cons$ and there exists a formula $ant'$ such that
$(\mathsf{pre}~r )\wedge \mathsf{preCond}~S~ant$ implies $ant'$ and
another invariant $inv'=ant' \longrightarrow cons \in invs$. This
means that the execution of $S$ does not affect the evaluation of
$cons$, and from the conjunction of the precondition of $ant$ and
the guard condition $g$, we can infer $cons$;
 $\mathsf{invHoldForRule}_4~inv~ r~invs$ says
  that $\mathsf{preCond}~S~ant=ant$, and there exists formulas
  $ant'$ and $ant''$
such that  $ant'$ implies $ant$, and $(\mathsf{pre}~r )\wedge \neg
\mathsf{preCond}~S~cons$ implies  $ant''$, and there exists another
invariant $inv'=ant'' \longrightarrow \neg ant' \in invs$;
 This means that the execution of $S$ does not affect the evaluation of
$ant$, and from the conjunction of the precondition of $\neg cons$
and the guard condition $g$, we can infer $\neg ant$;
$\mathsf{invHoldForRule}_5~inv~ r~invs$ specifies that
$\mathsf{preCond}~S~inv$ is also an invariant in  $invs$. This
specifies that both $ant$ and $cons$ will be affected by $S$, and
simply $inv'$ is also an invariant, which also hold at the state
before the execution of $r$.
\end{itemize}

Suppose that the consistency relation $\mathsf{consistent}~ invs
~inis~ rs$ holds, for any $inv \in invs$, $inv$ holds for any
reachable state $s$ such that $s  \in \mathsf{reachableSet}~ inis~
rs$. This is formalized by a so-called consistency lemma.
%
\begin{theorem}\label{consistentLemma}[(consistency lemma)]
  $\isasymlbrakk \mathsf{consistent}~ invs ~inis~ rs$; $s  \in \mathsf{reachableSet}~ inis~ rs$
  $\isasymrbrakk\Longrightarrow$ $\forall inv. inv \in invs \longrightarrow
\mathsf{formEval}~ inv ~s$
\end{theorem}

The consistency lemma can be proved by induction. Interesting
readers can refer to \cite{LiCache13}. %\JP{`consistency lemma' is
%not explained and it is unclear why it can be proved by induction.}

%It is the cornerstone in our framework. \JP{No framework is
%mentioned before.} It is \JP{heuristics????} inspired by the
%consistency relation that guides the tool {\sf InvFinder} to find
%the strengthened invariants, which are used to prove the original
%invariant. The tool \texttt{invFinder} works in an iteratively
%semi-proving and semi-searching workflow. In an iterating step, it
%tries to prove some consistent relation exists between an invariant
%and a rule, and automatically generates a new auxiliary invariant if
%there is no such an invariant in the current invariant set, and
%records the corresponding consistency information. This workflow is
%not finished until no new counter example is created.
%\JP{`counter-example' comes from nowhere!}

\section{The Searching Algorithm of the {\sf invFinder}}
Note that almost no invariants but one in the invariant set $invs$
in Theorem~\ref{consistentLemma}
is need to be compute.
That is to say, usually only one invariant $inv_1$ is given
initially, which is called the initial invariant, the remaining invariants such as $inv_i(i>1)$ are needed
to find. For example, a mutual exclusion property such as
 $cache[1]=exlusive \longrightarrow cache[2]=invalid$, which reflects the aim of a cache coherence protocol,
 is the main or (initial) invariant. However, we cann't directly prove this main property. We must find all the other
 invariants in $invs$, which is usually called auxiliary invariants, and adopt the consistency lemma to prove it.
 It is the task of {\sf invFinder} to construct each one of the remaining
invariants by checking the causal relation between an invariant and
a rule instance. The core part of the searching algorithm of the
{\sf invFinder} is given as follows, which is implied by a function
programming language FL:

\begin{specification}
1\twoSpaces let findInvsFromRule  choose chooses chk tautChk isNew paraRule paras inv newInvs\\ invs casRel=\\
2\twoSpaces     let rule=ruleApp paraRule paras in\\
3\twoSpaces   val (guard g  S)=rule in\\
4\twoSpaces   val (implyForm ant cons)=inv in\\


5\twoSpaces   let inv'=preCond S inv in\\
6\twoSpaces   val (implyForm ant' cons')=inv' in\\


7\twoSpaces     inv=inv'=>\\

8\twoSpaces         let relItem=(paraRule, paras, inv, invHoldForRule2) in
         (newInvs, (relItem: casRel))\\



9\twoSpaces      | tautChk inv'\\
10\twoSpaces         =>(let relItem=(paraRule, paras, inv, invHoldForRule1) in         (newInvs, (relItem: casRel)   ))\\


11\twoSpaces       | cons=cons'=>\\

12\twoSpaces       let newAnt=  choose cons ((andList2Ands (g$\wedge$ant'))     then\\

13\twoSpaces       let inv'= (implyForm newAnt cons) in\\


14\twoSpaces       let relItem=(paraRule, paras, inv,  invHoldForRule3 inv'   ) in\\

15\twoSpaces       ((isNew inv' invs)=>           (newInvs@[inv'], relItem : casRel)\\
16\twoSpaces       |(newInvs,  relItem : casRel))\\

17\twoSpaces     | ant=ant' =>\\
18\twoSpaces        let antConjs= andList2Ands ant'  then\\

19\twoSpaces        val (newAntant, newCons) = chooses ((map $\neg$ antConjs) (andList2Ands (g$\wedge \neg$cons)) in\\
20\twoSpaces        let inv'=(implyForm newAntant newCons) in\\
21\twoSpaces        let relItem=(paraRule, paras, inv,  invHoldForRule4 inv'   ) in\\
22 \twoSpaces       ((isNew inv' invs)=>         (newInvs@[inv'], relItem : casRel)\\
23\twoSpaces       |(newInvs,  relItem : casRel))\\

24\twoSpaces   | chk inv'=>\\
25\twoSpaces      let relItem=(paraRule, paras, inv,  invHoldForRule5 inv'  ) in\\
26\twoSpaces        ((isNew inv' invs)=>        (newInvs@[inv'], relItem : casRel)\\
27\twoSpaces        |(newInvs,  relItem : casRel))\\
28\twoSpaces   | error "no new invariant";\\
\end{specification}

Provided that  {\tt chk} is an oracle that checks whether a ground
formula is an invariant in a given small reference model of the
protocol; {\tt choose} and {\tt chooses} are two strategies to
construct new formulas and call {\tt chk} to guarantee that the
constructed formula is an invariant in the given  reference model;
{\tt tautChk} is an oracle to check whether a formula is a tautlogy.
  The above function {\sf findInvsFromRule} tries to find new
invariants and construct the causal relation between the rule
instance $r=paraRule~ para$ and the invariant $inv$. The statement
{\tt cond => et|ef} is an abbreviation of the if-then-else
expression that if $cond$ is true then $et$ else $ef$. Parameters
$newInvs$, $invs$, and $casRel$ are new invariants, invariants, and
all the causal relations constructed up to now, the above oracle
functions are also passed as parameters. The returned result is
updated invariant sets, and causal relations.
%
\begin{description}
\item[(1)] After computing the pre-condition {\tt inv'=preCond~S~inv} at line 5,
{\sf invFinder} performs case analysis on $inv'$: if {\tt inv=inv'},
 then no change made to $inv$ by statement $S$, the new causal
relation item marked with tag {\tt invHoldForRule2} is recorded
between $r$ and $inv$, but at this moment there are no new
invariants to be added;

\item[(2)] Secondly, if {\tt tautChk inv'} is true, where {\tt tautChk} is
a tautology checker for the formula $inv'$ which is implemented by
an SMT solver, then the new causal relation item marked with tag
{\tt invHoldForRule1} is recorded between $r$ and $inv$, but at this
moment there are no new invariants to be added either;

 \item[(3)] Thirdly, if {\tt cons=cons'},
 then the function {\tt choose} at line 12 chooses the weakest precondition $newAnt$
 from the conjuncts of  $g \wedge \neg  ant'$.
 {\tt andList2Ands} destructs a conjunction into a list of atomic formulas,
 which are equivalence formulas or negation of equivalence formulas,
 an invariant $inv'=newAnt \longrightarrow cons$,
 which is checked to hold at any state of the finite reference protocol model,
 is generated, and function {\tt isNew} is used to check whether the invariant is new.
 If yes, the invariant is  added into $newInvs$,
 and the new causal relation item marked with tag {\tt invHoldForRule3 inv'} will be added into the causal relation.
Here, the meaning of the word ``new" is modulo to the symmetry relation.
%The intuitive meaning of the symmetry relation is that $\mathsf{mutualInv}~1~2$ is equivalent to $\mathsf{mutualInv}~2~1$.
%Namely, $\mathsf{mutualInv}~1~2$  is only one representive of the formula set
%$\{f. \exists i~j \le 3.f=i\neq j \wedge cache[i]=exclusive\longrightarrow cache[j]=invalid \}$.

  \item[(4)] Fourthly, if {\tt ant=ant'}, then the function {\tt chooses} at line 19 chooses
  the weakest precondition $newAnt$ from the conjuncts of
   $g \wedge \neg  cons'$, and proper $newCons$ from the negation of all the conjuncts of $ant$,
   namely, it holds that $newCons \longrightarrow \neg ant$,
   and the invariant  $inv'=newAnt \longrightarrow newCons$,
   which is checked to  at any state of the finite reference protocol model,  is also generated.
   If the invariant $newAnt \longrightarrow newCons$ is new, then it will be added into $newInvs$.
   A new causal relation item marked with tag {\tt invHoldForRule4 inv'} will be added into the causal
   relation.
   %Recall that $ant$ may be a conjunction of atomic
   %formulas, one of which being falsified means that $ant$ will be falsified.

    \item[(5)] Otherwise, $inv'$ will be checked whether it is an invariant holding at each state of the finite reference model. If thus, it
    will be checked whether it is new. $newInv$ will be updated
    accordingly. At last, a causal item marked with {\tt invHoldForRule5
    inv'} will be added into $casRel$.
 \end{description}

Note that the above algorithm is closely related with the
consistency lemma. It is heuristics inspired by checking the causal
relation between $rule$ and $inv$,  which guides the tool {\sf
InvFinder} to find the auxiliary invariants. The five parts of the
algorithm deals with 5 cases of the consistency relation between
$rule$ and $inv$ respectively.

The main body of {\sf invFinder}'s algorithm iteratively calls the function
{\sf findInvsFromRule}  by instantiating each parameterized rule
with different actual parameters of the finite reference protocol
model. This procedure is  finished until no more new invariants can be created.


%=========================================
\section{Applications of Auxiliary Invariant Sets}
%=========================================
 After the auxiliary invariants   are found,
 they can be fed into other
tools for further purposes. In our work, the auxiliary invariants
are given to a tool called $\mathsf{proofGen}$ to automatically
generate parameterized Isabelle proof script for the protocol under
study. Essentially, the generation of Isabelle proof script is a
generalization from a ground proof for a finite reference protocol
instance (if the search of auxiliary invariants is regarded as a
semi-proof) to a parameterized proof for a general parameterized
protocol instance in a theorem prover. The aforementioned
consistency lemma is the corner stone of both of the proofs. Firstly,
we need to generalize the ground invariants to the general
parameterized invariants. For instance,
 A technique of parameter mapping plays a key role in our proof generation in order to
generate these proofs automatically. The essence of this technique
is to map a symbolic proof in parameterized form to a sample proof
in the ground form. The proof pattern to prove that some causal
relation holds between a general rule and a general invariant must
be summarized and formulated into a formal proof template.
%
{\sf proofGen} will select a proper proof method among
$\mathsf{invHoldForRule1}$-$\mathsf{invHoldForRule5}$ to generate
proof commands according to the mapped proof cases in the reference
protocol model and the corresponding causal information passed from
{\sf invFinder}. A detailed proof for a rule instance and an
invariant instance can be created by instantiating the proof
templates with some parameters with the aid of {\sf proofGen}.
Isabelle provides a feature {\sf locale} to formalize typical proof
templates, and {\sf interpretation} to formalize proof template
instantiations. Interesting readers can refer to~\cite{LiCache13} ro
read the detailed proofs.

Although a parameterized proof in Isabelle gives the highest
assurances, such a proof script may be hard to be understood by
engineers. A simulation flow graph of a single client's $i$ activity
can be generated to illustrate intuitively the correctness of the
protocol with the aid of auxiliary invariants. Such a simulation
graph is an abstraction of all the protocol instance from the view
of a client (or node). A state of the abstracted state space
reserves all the values of local variables of  the client $i$  and
almost the global variables. Auxiliary invariants are used to decide
whether a rule involving clients except $i$ depending on partial
state of client $i$ and global variables. Interesting readers can
refer to~\cite{LiCache14} ro read the simulation flow of a client.
%In this graph, we can observe clearly how cache[i] are set true
%and the effect  of other's client's activities to client [i]. With
%the aid of auxiliary invariants, we can observe how the mutual
%invariants are kept.


%=========================================
\section{Experiments}
%=========================================
We implement our tool in Forte \cite{Forte}. More experiments are
done including typical bus-snoopy ones such as MESI and MOESI,
 directory-based ones such as  Germanish, and  German protocols. The detail experiment codes and data can
be found in \JP{\cite{LiCache14}}. Each experiment data includes the
${\sf invFinder}$ model, invariant sets found, Isabelle proof
scripts, and the simulation flow graph of one single node. A table
summarizes  our experiments below.
Among the benchmarks, the German protocol   was posted
 as
% Among the benchmarks, a case study is done
%on a directory-based protocol, German protocol, which was posted as
a challenge to the formal verification community by Steven German in
2000. German protocol is a moderate case.
To the best of our knowledge, few people but us give a complete proof to verify
the mutual exclusion  property of the German protocol
 in a theorem prover.

 \begin{table}[htbp] \label{Summarization of experiment results}
\centering \caption{Summarization of results on benchmarks}
\begin{tabular}{|c|c|c|c|c|}
\hline
protocol &  ruleNum & invariantNum & time(s) & memory(M) \\
\hline
simpMutual& 4& 5 & 5.66 & 10.3 \\
\hline
MESI & 4& 3 & 4.66 & 11.5  \\
\hline
MOESI &  5& 3 &3.98 & 11.3  \\
\hline
 German-ish  & 6& 4 &35.8 & 15.1   \\
\hline
German & 13 & 48 & 1222.2 & 16.1   \\
\hline
\end{tabular}
\end{table}

%=========================================
\section{Conclusion}
%=========================================
Our case studies on cache coherence protocols are typical examples
to illustrate the guiding principle of {\sf invFinder}. The
 consistency lemma based on the induction approach, is the
core of our work, which gives the heuristics to guide the tool
 to search invariants. Instead of ``invisible invariants" in previous work
 (see e.g,~\cite{Pnueli2001}, our invariants are visible,
 which can be further refined to precisely
 analyze the correctness of the protocol both in theoretical and practical aspects.

\bibliographystyle{splncsnat}
\bibliography{gste,cache,refer}
\end{document}

\documentclass{llncs}
%%%%%%%%%%%%%%%%%%%%%%
%%%%   PACKAGES   %%%%
%%%%%%%%%%%%%%%%%%%%%%
\usepackage{makeidx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{latexsym}
\usepackage{url}
\usepackage{color}
\usepackage{isabelle}
\usepackage{isabellesym}
\usepackage{theorem}
%\usepackage{times}
\usepackage{mathptmx}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%For Isabelle code
\newlength{\fminilength}
\newsavebox{\fminibox}
\newenvironment{fmini}[1][\linewidth]
  {\setlength{\fminilength}{#1\fboxsep-2\fboxrule}%
   \vspace{2ex}\noindent\begin{lrbox}{\fminibox}\begin{minipage}{\fminilength}%
   \mbox{ }\hfill\vspace{-2.5ex}}%
  {\end{minipage}\end{lrbox}\vspace{1ex}\hspace{0ex}%
   \framebox{\usebox{\fminibox}}}

\newenvironment{specification}
{\noindent\footnotesize
\tt\begin{fmini}\begin{tabbing}X\=X12345\=XXXX\=XXXX\=XXXX\=XXXX\=XXXX
\=\+\kill} {\end{tabbing}\normalfont\end{fmini}}
\def \twoSpaces {\ \ }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%for comments
\newcommand\JP[1]{\textcolor{magenta}{JP: #1}}
\newcommand\lyj[1]{\textcolor{green}{lyj: #1}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Additional math operators
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[colorlinks,
            linkcolor=black,
            anchorcolor=black,
            citecolor=blue,
            urlcolor=black,
            bookmarks=true
            ]{hyperref}

\input{tcilatex}

%=========================================
\begin{document}

\title{ {\sf paraVerifier}: An Automatic Framework for Proving Parameterized Cache Coherence Protocols}
\titlerunning{{\sf paraVerifier}: An Automatic Framework for Proving Parameterized Cache Coherence Protocols}

\author{Yongjian Li\inst{1,3} \and Jun Pang\inst{2} \and Yi Lv\inst{1}
\and Dongrui Fan\inst{4} \and \\ Shen Cao\inst{1} \and Kaiqiang Duan\inst{1}}

\authorrunning{Li et al.}

\institute{
State Key Laboratory of Computer Science, Institute of Software, CAS \and
Computer Science and Communications, University of Luxembourg, Luxembourg \and
College of Information Engineering, Capital Normal University, Beijing, China \and
State Key Laboratory of Computer Architecture, Institute of Computing Technology, CAS
}

\maketitle

%-------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------
Parameterized verification of cache coherence protocols is an important
but challenging research problem. We present in this paper our automatic framework {\sf paraVerifier}
to handle this problem:
(1) it first discovers auxiliary invariants and the
corresponding causal relations between invariants and protocol rules from a
small reference instance of the verified protocol; (2) the discovered
invariants and causal relations can then be generalized into their parameterized
form to automatically construct a formal proof to establish the correctness of the protocol.
{\sf paraVerifier} has been successfully applied to a number of benchmarks.

%-------------------------------------------------------------------------
\end{abstract}
%-------------------------------------------------------------------------

%=========================================
\section{Introduction}
%=========================================
Verification of parameterized systems
(e.g., see~\cite{Pnueli1996,Bjorner1997,Arons2001,Pnueli2001,Tiwari2001,Chou2004,PFHV07,Pandav2005,Lv2007,Bingham2008,cubicle2011})
is interesting in
the area of formal methods, mainly due to the practical importance
of such systems. Parameterized systems exist in many
application domains, including cache coherence protocols, security systems, and
network communication protocols. In this work, we
focus on cache coherence protocols, which play a key role in modern
computer architecture. They require complex algorithms that
deal with asynchrony, unpredictable message delays, and multiple
communication paths between many nodes. Therefore, the highest
possible assurance for the correctness of these
systems should be guaranteed by formal reasoning techniques.

The challenge posed by parameterized verification of cache coherence protocols
is that the desired safety properties, in terms of invariants, should hold for any instance of the studied
protocol, not just for a single protocol instance. Model checking is
automatic but is only able to verify an instance of the protocol.
The correctness of the reference instance does
not formally suffice to conclude the correctness for all instances.
Due to the extreme importance of cache coherence protocols, it is
preferable to have a proof for any instance of such protocols.

Advanced verification techniques such as compositional~\cite{McMillan2001} and abstraction model
checking~\cite{Chou2004} have been proposed to handle this challenge. However, auxiliary
invariants of a cache coherence protocol, which is usually provided by a human, based on his
insights of the protocol, are needed to make these
techniques work. How to find sufficient and necessary invariants
is the main difficulty in the field of parameterized verification.
Many works have focused on the
construction of a set of auxiliary
invariants, for example, see~\cite{Pnueli2001,Chou2004,Pandav2005,Bingham2008,cubicle2011}.
However, the theoretical foundation of these techniques and their
soundness proofs are often only discussed in the respective papers.
These theories themselves are not easy to understand, and are subjects
to be mechanically checked, mainly due to the fact that their soundness needs to be
guaranteed without any conditions.

The aim of our framework {\sf paraVerifier} is to solve the parameterized
verification of cache coherence protocols in a \emph{unified}, \emph{rigorous} and \emph{automated} way.
{\sf paraVerifier} consists of two parts: an invariant finder {\sf invFinder}
and a proof generator {\sf proofGen}. In order to verify that an
invariant ${\it inv}$ holds for any instance of a parameterized protocol,
a reference model of the protocol with a fixed parameter
is constructed first and successfully model checked, and {\sf invFinder} tries to search for
interesting auxiliary invariants and causal relations which are
capable of proving ${\it inv}$. Next, {\sf proofGen}
explores the outputs of {\sf invFinder} to construct a complete and parameterized
formal proof in a theorem prover (e.g., Isabelle). Such a proof can eventually
be checked automatically.

The originality of our work lies in the following aspects.
First, {\sf paraVerifier} is built on a simple but elegant theory. Three types of causal
relations between protocol rules and invariants are identified, which are
essentially the special cases of the general induction rule.
The correctness of the three causal relations is captured
by the so-called \emph{consistency lemma}.
It is heuristics-inspired by trying to
construct the consistency relation that guides the tool {\sf
invFinder} to find auxiliary invariants. On the other hand, the
consistency lemma provides a general guiding principle to prove
invariants in the parameterized model of a cache coherence
protocol. The lemma itself is verified as a formal theory in Isabelle~\cite{NPW02}.\footnote{We directly use parts of our IsabelleÕs theories to
introduce definitions and lemmas in the paper.
}
%
Second, {\sf paraVerifier} produces a list of invariants
and a readable proof script for a given parameterized cache coherence protocol.
The invariants are visible,
in the sense that they can characterize the semantical features of the protocol and
help users to precisely understand the design of the protocol.
The formal proof script models the protocol
rigorously and specifies its properties without any ambiguity, and more importantly
it is mechanically checked.
%
Third, {\sf paraVerifier} is automatic, i.e., requiring little human intervention, and scalable.
After the protocol is modeled in {\sf paraVerifier}, auxiliary invariants
are searched automatically via {\sf invFinder}.
The formal proof script in Isabelle is also automatically generated by {\sf proofGen},
and checked by Isabelle.
{\sf paraVerifier} is successfully applied to industrial case studies such as
the Flash protocol~\cite{Park1996a,McMillan2001}.\footnote{Flash is
considered as a standard and difficult benchmark for any proposed method for parameterized verification,
as Chou et al.~\cite{Chou2004} state
``if the method works on Flash, then there is a good chance that it will also work on many real-world cache coherence protocols".}


%=========================================
\section{Consistency Lemma}
%=========================================

In this section, we introduce the theoretical foundation underlining
{\sf paraVerifier}. Consider a set of state variables $V$,
we use $e$, $f$ and $S$ to denote an
expression, a formula, and a statement over the set of state
variables $V$.
Variables are divided into two classes: array variables or
non-array (global) variables.
A state $s$  of a protocol is an
instantaneous snapshot of its behavior given by a mapping from
all variables in $V$ to natural numbers.  We write
$\mathsf{expEval}~e~s$ (and $\mathsf{formEval}~f~s$) to denote the
evaluation of the expression $e$ (and formula $f$) at the state $s$.
With a parallel assignment $S=\{x_i:=e_i | i>0\}$,
we define $\mathsf{preCond}~S~f=f[x_i:=e_i]$, which substitutes each
occurrence of $x_i$ by $e_i$.

\smallskip
\noindent{\bf Protocols.}
A cache coherence protocol is formalized as a pair $({\it ini}, {\it rules})$, where
(1) ${\it ini}$ is an initialization formula; and
(2) ${\it rules}$ is a set of transition rules. Each rule $r\in {\it rules}$ is defined as
  $g \vartriangleright  S$, where $g$ is a predicate, and $S$ is a
  parallel assignment to distinct  variables $v_i$ with expressions
  $e_i$. We write $\mathsf{pre}~r=g$, and $\mathsf{act}~r=S$
  if $r=g \vartriangleright S$.


We identify three kinds of causal
relations that are essentially the special cases of the
general induction rule.
Consider a transition rule $r$, a formula $f$, and a formula set $F$,
the three causal relations are defined as follows:

\begin{definition}
We define the following relations
\begin{enumerate}
\item $\mathsf{invHoldForRule_1} ~f ~r \equiv \mathsf{pre}~ r \longrightarrow \mathsf{preCond}~ f ~(\mathsf{act}~ r)$;
\item $\mathsf{invHoldForRule_2}~ f~ r \equiv f = \mathsf{preCond}~ f~(\mathsf{act}~ r)$;
\item $\mathsf{invHoldForRule_3}~ f~ r ~F \equiv$  $\exists f' \in F$ s.t.
$(f' \wedge (\mathsf{pre}~ r)) \longrightarrow \mathsf{preCond} ~f ~(\mathsf{act}   ~r)$;
\item $\mathsf{invHoldForRule}~ f~ r ~F$ represents a disjunction of $\mathsf{invHoldForRule_1}$, $\mathsf{invHoldForRule_2}$
and $\mathsf{invHoldForRule_3}$.
%\item $\mathsf{invHoldForRule}~ f~ r ~F \equiv (\mathsf{invHoldForRule_1} ~f
%  ~r) \lor (\mathsf{invHoldForRule_2} ~f ~r) \lor (\mathsf{invHoldForRule_3}~ f~ r~F)$.
\end{enumerate}
\end{definition}
%The last one defines the disjunction of the three previously defined relations.
The first relation ($\mathsf{invHoldForRule}_1~f~ r$)
  means that after rule $r$ is executed,
 $f$ should hold.
 The second relation ($\mathsf{invHoldForRule}_2~f~ r$)
 intuitively means that none of the state variables in $f$ is
 changed and the execution of rule $r$ does not affect the
 evaluation of $f$.
 The third relation ($\mathsf{invHoldForRule}_3~f~ r~F$) states
  that  there exists another formula (invariant) $f' \in F$ such that
  the conjunction of the guard of $r$ and $f'$ implies
  that $f$ holds after the election of rule $r$.
Essentially, the causal relations
capture whether and how the execution of a particular protocol rule
changes the protocol state variables appearing in an invariant.
More importantly, the relations can be considered as induction proof tactics
designed for automatic proof generation (for example, used by {\sf proofGen}).

Intuitively, the disjunction of the above relations ($\mathsf{invHoldForRule} ~f ~r ~F$) defines a causal
relation, which can guarantee that if each formula $f$ in $F$ holds
before the execution of the rule $r$, then $f$ also holds after the
execution of the rule. Secondly, it can be considered as a
special inductive proof rule, which can be applied to prove that
each formula in $F$ holds for each protocol rule.

\begin{definition}
A consistency relation, i.e., $\mathsf{consistent}~ {\it invs} ~{\it ini}~ {\it rules}$,
that holds between a protocol $({\it ini}, {\it rules})$ and
a set of invariants ${\it invs}=\{inv_1,\ldots, inv_n\}$,  is defined as:
%
\begin{itemize}
\item For any invariant ${\it inv} \in {\it invs}$ and state $s$,
if ${\it ini}$ is
evaluated as true at state $s$
(i.e., $\mathsf{formEval}~{\it ini}~s={\it true}$), then ${\it inv}$ is also evaluated as true at the state $s$.

\item For any ${\it inv} \in {\it invs}$ and $r\in {\it rules}$,
$\mathsf{invHoldForRule}~{\it inv}~r~{\it invs}$.
\end{itemize}
\end{definition}

Now we proceed with  formally stating the \emph{consistency lemma} below.
Namely, if the consistency relation
$\mathsf{consistent}~{\it invs} ~{\it ini}~ {\it rules}$ holds, then for any ${\it inv} \in {\it invs}$
${\it inv}$ holds for any reachable state $s$ of a protocol $({\it ini}, {\it rules})$.

\begin{lemma}\label{consistentLemma}%[(Consistency lemma)]
For a protocol $({\it ini}, {\it rules})$,
we use $\mathsf{reachableSet}~ {\it ini}~{\it rules}$
to denote the set of reachable states of the protocol.
Given a set of invariants ${\it invs}$,
we have
  $$\isasymlbrakk \mathsf{consistent}~ {\it invs} ~{\it ini}~ {\it rules};
  s \in \mathsf{reachableSet}~ {\it ini}~{\it rules}\isasymrbrakk\!\Longrightarrow\!
  \forall {\it inv \in invs}. \mathsf{formEval}~ inv ~s$$
\end{lemma}
%
We have built a general theory {\tt cache.thy} in Isabelle
to model cache coherence protocols~\cite{LiCache14}, and the consistency lemma is also formally proved.

%=========================================
\section{Overview of Our Approach}
%=========================================
The steps of our framework {\sf paraVerifier} to parameterized
verification of cache coherence protocol is illustrated in Fig.~\ref{fig:arch}.
A small cache coherence protocol instance {\tt protoocl.fl}, is fed into the
tool {\sf invFinder}, which will search for all necessary ground auxiliary invariants
from the reference protocol instance.
A table {\tt protoocl.tbl} is used to store the set of ground invariants and
causal relations, which will then be used by {\sf proofGen} to
create an Isabelle proof script which models and verifies the
protocol in a parameterized form. In this step, ground invariants
will be generalized into a parameterized form, and accordingly
ground causal relations will be adopted to create parameterized
proof commands which essentially prove the existence of the
parameterized causal relations. At last, the Isabelle proof script {\tt protoocl.thy} is
given to Isabelle to check the protocol correctness automatically.

The consistency lemma plays a crucial role in {\sf paraVerifier}.
It behaves as a heuristics to construct a consistency relation that
guides the tool {\sf invFinder} to find auxiliary invariants. On the
other hand, it gives a general guiding principle
to prove invariants of a cache coherence protocol. The
consistency lemma eliminates the need of directly using the
induction proof method. It allows us to focus on  the causal
relationship between transition rules of the protocol and
its invariants. It also enables us to divide the proof of the invariants to a
series of subproofs to verify whether one of the relations
$\mathsf{invHoldForRule_{1-3}}$ hold for a rule and an invariant.
The strategy of `divide and conquer' is the key step
to make the series of sub-proofs
to be automated because the proof patterns for the subproofs are similar
and modular. The tool {\sf proofGen} will then
automatically generate a proof that applies the the consistency
lemma to prove correctness.

\begin{figure}[!t]
\centering %
\vspace{-0.8cm}
\includegraphics[width=1.0\textwidth]{paraVerifier.pdf}
\vspace{-0.6cm}
\caption{The workflow of {\sf paraVerifier}.}
\label{fig:arch}
\end{figure}


%%=========================================
%\medskip
%\noindent
%{\bf A running example.}
%%=========================================
%We present the verification of a simple cache coherence protocol {\tt mutual}
%to illustrate the functionalities of {\sf paraVerifier}.
%We need to write the protocol model in our modeling language below:
%
%\vspace{2mm}
%\begin{specification}\label{spec1}
%1\twoSpaces   pIni  N $\equiv$
%   x=true $\wedge$ (forallForm N ($\lambda$ i. n[i]=I))\\
%
%~2\twoSpaces    try i $\equiv$ n[i] = I $\vartriangleright$ n[i] := T; \\
%
%~3\twoSpaces    crit i $\equiv$ n[i] = T\& x = true $\vartriangleright$  n[i] := C; x := false;  ;\\
%
%~4\twoSpaces   exit i $\equiv$ n[i] = C $\vartriangleright$ n[i] := E; \\
%
%~5\twoSpaces   idle  i $\equiv$  n[i] = E $\vartriangleright$ n[i] := I;  x := true;\\
%
%~6\twoSpaces   prules  = [(``crit", crit), (``exit", exit), ("idle",idle),("try",try)]\\
%
%~7\twoSpaces inv1 i j $\equiv$ $\neg$ (n[i]= C $\wedge$ n[j]= C)\\
%
%~8\twoSpaces  search prules 3 [inv1 1 2] "mutual" \\
%
%~9\twoSpaces  createIsabelleModel pIni "mutual"
%\end{specification}
%%
%\noindent
%Line 1 specifies the initial states of the protocol;
%lines 2-5 describe four transition rules;
%line 6 states the set of all protocol rules and names them;
%line 7 defines the mutual exclusion property;
%line 8 is a command to invoke {\sf invFinder} to search for auxiliary invariants
%from a reference instance with 3 nodes,
%the starting invariant is the property itself, and the results are stored in a file ``{\tt mutual}";
%line 9 is a command to invoke {\sf proofGen}
%to generate a parameterized Isabelle proof script.

Starting from a given set of initial invariants,
{\sf invFinder} repeatedly tries to find new invariants,
in the form of ground formulas,
by constructing the causal relation between
the invariants and the protocol rules.
It uses an oracle\footnote{Implemented with NuSMV and the SMT solver Z3.} that checks whether a ground formula
is an invariant in the small reference model of the protocol.
{\sf invFinder} stops until no new invariants can be found.
The output of {\sf invFinder} is stored in file {\tt protocol.tbl}.
Each line of the table records
the index of an invariant,
the name of a parameterized rule,
the rule parameters to instantiate the rule,
a causal relation between the invariant and a causal relation
The table also records the proper formulas $f'$
which is used to construct the third causal relation $\mathsf{invHoldForRule}_3$.
An example of such table is shown in Tab.~\ref{label-ground-causal relation}.

%The output of {\sf invFinder}, stored in file {\tt mutual.tbl},
%is partly shown in Tab.~\ref{label-ground-causal relation}.
%Each line records
%the index of an invariant,
%the name of a parameterized rule,
%the rule parameters to instantiate the rule,
%a causal relation between the invariant and a causal relation
%The table also records the proper formulas $f'$
%which is used to construct the third causal relation $\mathsf{invHoldForRule}_3$.
%The auxiliary invariants found by {\sf invFinder} include:
%$\mathsf{inv_2}  \equiv  \neg (x=true  \wedge  n[1]=C)$, $\mathsf{inv_3}    \equiv \neg  ( n[1]=C \wedge n[2]=E)$,
%$\mathsf{inv_4}  \equiv  \neg (x=true  \wedge  n[1]=E)$,   $\mathsf{inv_5}    \equiv \neg  ( n[1]=C \wedge n[2]=C)$.

\begin{table}[!t]
\centering
\caption{An example fragment of {\tt protocol.tbl} generated by {\sf invFinder}.}\label{label-ground-causal relation}
\vspace{-2mm}
\begin{tabular}{|c|c|c|c|c|  }
\hline
protocol rule& ruleParas &~~invariant~~&~~~~causal relation~~~~&  formula ($f'$)  \\
\hline\hline
%  .. & ..&.. &..&.. \\
%\hline
  crit  & [1]& inv1 1 2& invHoldForRule3 &inv2~2 \\
\hline
  crit &[2]& inv1 1 2& invHoldForRule3 &inv2~1  \\
\hline
  crit & [3]& inv1 1 2 & invHoldForRule2  & \\
%\hline
%  .. & ..&.. &..&.. \\
\hline
\end{tabular}
\vspace{-4mm}
\end{table}

The formal Isabelle proof script {\tt protoocl.thy} generated by {\sf proofGen}
includes the definitions of control signals, rules, invariants, initializing formula,
lemmas and their proofs.
%
%Some main definitions and lemmas in {\tt mutual.thy} are listed below.
%\vspace{-2mm}
%\begin{specification} \label{spec2}
%1\twoSpaces pIniN  N $\equiv$  andList [ iniStateSpecOfx ,   iniStateSpecOfn N ]\\
%
%~2\twoSpaces
%prules N $\equiv$ \{r. ex1P N ($\lambda$i.  r=crit i)  $\vee$
%ex1P N ($\lambda$i.  r=exit i)  $\vee$\\
%\twoSpaces\twoSpaces ex1P N ($\lambda$i.  r=idle i)  $\vee$
%ex1P N ($\lambda$i.  r=try i)  \}\\
%
%~3\twoSpaces
%invariants N $\equiv$ \{f. ex2P N ($\lambda$ i j.  f = inv1 i j)  $\vee$ \\
%\twoSpaces\twoSpaces ex1P N ($\lambda$ i.  f= inv2 i)  $\vee$
%ex2P N ($\lambda$ i j.  f = inv3 i j)  $\vee$ \\
%\twoSpaces\twoSpaces ex1P N ($\lambda$ i.  f= inv4 i)  $\vee$
%ex2P N ($\lambda$ i j.  f = inv5 i j)   \}\\
%
%~4\twoSpaces lemma initImpInv1:
%    $\isasymlbrakk$ i1 $\le$ N; i2 $\le$ N;
%i1$\neq$i2; $\mathsf{formEval}$~(pIni~N)~s
%    $\isasymrbrakk$ \\
%\twoSpaces\twoSpaces $\Longrightarrow$
%invHoldForRule' (inv1  i1 i2 ) (crit iR1 ) (invariants   N)
% % (is $\forall$s. ?P1 s$\vee$?P2 s$\vee$?P3 s
%)\\
%
%~5\twoSpaces lemma critVsInv1: $\isasymlbrakk$ iR1 $\le$ N; i1 $\le$ N; i2 $\le$ N; i1$\neq$i2
%    $\isasymrbrakk$ \\
%\twoSpaces\twoSpaces $\Longrightarrow$
%invHoldForRule' (inv1  i1 i2 ) (crit iR1 ) (invariants   N)
%)\\
%
%~6\twoSpaces lemma main: $\isasymlbrakk$ s $\in$ reachableSet { pIni  N} (rules N); 0<N $\isasymrbrakk$ \\
%\twoSpaces\twoSpaces $\Longrightarrow$
%$\forall$inv. inv $\in$(invariants N)$\longrightarrow$
%formEval inv s
%\end{specification}
%
%\noindent
%Line 1 defines the specification formula of a paramaterized instance with $N$ nodes;
%line 2 lists  all the rules;
%line 3 lists all the invariant formulas;
%line 4 specifies a lemma that
%if the initial specification formula is evaluated true at a state $s$,
%then invariant formula {\tt invariants} is evaluated true at $s$ as well;
%line 5 states a lemma that the causal relation holds between rule {\tt crit} and invariant {\tt inv1};
%line 6 specifies the main lemma that  for all invariants ${\it inv}$ and for all reachable state $s$,
%${\it inv}$ is evaluated to be true at state $s$.
%
Here, we briefly explain the generalization principle involved in {\sf proofGen}.
For a ground invariant ${\it inv} $with parameters,
{\sf proofGen} analyzes the number of ground parameters in it
and defines a parameterized invariant ${\it pInv}$
by replacing the ground parameters with their corresponding symbolic parameters accordingly.
Then {\sf proofGen} explores symmetry relations
and uses the following three relations ${\sf ex1P}$ or ${\sf ex2p}$ or ${\sf ex3P}$ to define all the actually parameterized
invariants, where $\mathsf{ex1P}~ N~ P \equiv \exists i. (i \le N \wedge P~
i)$, $\mathsf{ex2P}~ N~ P \equiv \exists i~j. (i \le N \wedge j \le
N \wedge i\ne j \wedge P~ i~j)$, and $\mathsf{ex3P}~ N~ P \equiv
\exists i~j~k. (i \le N \wedge j \le N \wedge k \le N\wedge i\ne j
\wedge i\ne k \wedge j\ne k \wedge P~ i~j~k)$.
For instance, for the formula $\neg  ( n[1]=C \wedge n[2]=C)$,
two ground parameters 1 and 2 are extracted, and
a formal invariant formula $inv_1~i1~i2=\neg  ( n[i1]=C \wedge n[i2]=C)$
is defined by replacing 1 and 2 with symbolic parameters $i1$ and $i2$,
and $\{f.\mathsf{ex2P}~ N~ \lambda i1 i2. f= inv_1~i1~i2\}$ defines the set of  all the formulas, each of which is symmetric to $inv_1~1~2$.
The generalization of statements, rules, and causal relations can be defined accordingly.
Each line in the ground causal relation table (Tab.~\ref{label-ground-causal relation}),
is generalized into a parameterized relation,
which is the key to generate a proof command to select a proper causal relation to prove.

%=========================================
\section{Validation and Conclusion}
%=========================================
We implemented {\sf paraVerifier} in Forte~\cite{forte}
and tested it on a number of cache coherence protocols.
The detailed source codes and data can
be found in~\cite{LiCache14}. Each experimental data includes the
protocol model, the invariant sets, and the Isabelle proof script.
Tab.~\ref{Summarization of experiment results}
summarizes our verification results, recording
the resources needed to compute the invariants and generate the proof scripts.
Note that our proof of Flash is different from the one of Park et al.~\cite{Park1996a},
where they need to manually construct an abstract transaction model of Flash.
Our proof does not require this step and has less human interaction.

\begin{table}[!t] \label{Summarization of experiment results}
\centering
\caption{Verification results on benchmarks.}
\vspace{-2mm}
\begin{tabular}{|c|r|r|r|r|}
\hline
Protocols &  \#rules & \#invariants & time (seconds) & Memory (MB) \\
\hline\hline
MESI & 4& 3 & 0.68 & 11.5  \\
\hline
MOESI &  5& 3 &0.65 & 23.2  \\
\hline
Germanish~\cite{cubicle2011}  & 6&3&0.68 & 23.0   \\
\hline
German~\cite{Chou2004} & 13 & 24 & 4.09 & 26.7   \\
\hline
German with data~\cite{Chou2004} & 15 & 50 & 12.05 & 29.4   \\
\hline
Flash~\cite{Park1996a,McMillan2001} & 73 & 112 & 1457.42 & 169.4   \\
\hline
\end{tabular}
\vspace{-5mm}
\end{table}

%%=========================================
%\section{Conclusion}
%%=========================================
Within {\sf paraVerifier},
our automatic framework for parameterized verification of cache coherence protocol,
(1) instead of directly proving the invariants of a protocol by induction, we propose a general
proof method based on the consistency lemma to decompose the proof goal into a number of small ones;
(2) instead of proving the decomposed subgoals by hand,
we automatically generate proofs for them based on the information computed in a small protocol instance.\footnote{Technical details
of {\sf paraVerifier} will be made available in a technical report.}

As we demonstrate in this work, combining theorem proving with
automatic proof generation is promising in the field of formal
verification of industrial protocols. Theorem proving can guarantee the rigorousness of the verification results,
while automatic proof generation can release the burden of human interaction.

\paragraph*{Acknowledgments} %Yongjian Li, was supported by  grants 61170073 and  61170304 and 2011DFG13000 from the National Natural Science Foundation of China.
This work is partially supported by the National Natural Science Foundation of China under Grants No.61170073, No.61170304, No.2011DFG13000, No.61272135, No.61173007, and No.61332009.

%=========================================
%\bibliographystyle{splncsnat}
%\bibliography{gste,cache,refer}
%=========================================
\vspace{-0.5cm}
\begin{thebibliography}{10}

\bibitem{Pnueli1996}
Pnueli, A., Shahar, E.:
\newblock A platform for combining deductive with algorithmic verification.
\newblock In Porc.\ 16th Conference on Computer Aided Verification (CAV). LNCS 1102.
\newblock Springer (1996)  184--195

\bibitem{Bjorner1997}
Bj\"orner, N., Browne, A., Manna, Z.:
\newblock Automatic generation of invariants and intermediate assertions.
\newblock Theoretical Computer Science \textbf{173}(1) (1997)  49 -- 87

\bibitem{Arons2001}
Arons, T., Pnueli, A., Ruah, S., Xu, Y., Zuck, L.:
\newblock Parameterized verification with automatically computed inductive
  assertions?
\newblock In: Proc.\ 13th Conference on Computer Aided
  Verification (CAV). LNCS 2102.
\newblock Springer (2001)  221--234

\bibitem{Pnueli2001}
Pnueli, A., Ruah, S., Zuck, L.:
\newblock Automatic deductive verification with invisible invariants.
\newblock In: Proc.\ 7th Conference on Tools and Algorithms for the
  Construction and Analysis of Systems (TACAS). LNCS 2031.
\newblock Springer (2001)  82--97

\bibitem{Tiwari2001}
Tiwari, A., Rue\ss, H., Sa\"idi, H., Shankar, N.:
\newblock A technique for invariant generation.
\newblock In: Proc.\ 7th Conference on Tools and Algorithms for
  the Construction and Analysis of Systems (TACAS). LNCS 2031.
\newblock Springer (2001)  113--127

\bibitem{Chou2004}
Chou, C.T., Mannava, P., Park, S.:
\newblock A simple method for parameterized verification of cache coherence
  protocols.
\newblock In: Proc.\ 5th Conference on Formal Methods in
  Computer-Aided Design (FMCAD). LNCS 3312.
\newblock Springer (2004)  382--398

\bibitem{PFHV07}
Pang, J., Fokkink, W., Hofman, R., Veldema, R.:
\newblock Model checking a cache coherence protocol of a Java DSM implementation.
\newblock Journal of Logic and Algebraic Programming \textbf{71}(1) (2007)  1 -- 43

\bibitem{Pandav2005}
Pandav, S., Slind, K., Gopalakrishnan, G.:
\newblock Counterexample guided invariant discovery for parameterized cache
  coherence verification.
\newblock In: Proc.\ 13th IFIP Advanced Research Working Conference on Correct
  Hardware Design and Verification Methods (CHARME). LNCS 3725.
\newblock Springer (2005)  317--331

\bibitem{Lv2007}
Lv, Y., Lin, H., Pan, H.:
\newblock Computing invariants for parameter abstraction.
\newblock In: Proc.\ 5th IEEE/ACM Conference on Formal
  Methods and Models for Codesign (MEMOCODE). IEEE CS (2007)  29--38

\bibitem{Bingham2008}
Bingham B.:
\newblock Automatic non-interference lemmas for parameterized model checking.
\newblock In Proc.\ 8th Conference on Formal Methods in Computer-Aided Design (FMCAD).
\newblock IEEE CS (2008)  1--8

\bibitem{cubicle2011}
Conchon, S., Goel, A., Krstic, S., Mebsout, A., Za\"idi, F.:
\newblock Cubicle: A parallel SMT-based model checker for parameterized
  systems.
\newblock In Proc.\ 24th Conference on Computer Aided Verification (CAV). LNCS 7385.
\newblock Springer (2012)  718--724

\bibitem{McMillan2001}
McMillan, K.L., Labs, C.B.:
\newblock Parameterized verification of the Flash cache coherence protocol by
  compositional model checking.
\newblock In: Proc.\ 9th IFIP Advanced Research Working Conference on Correct
  Hardware Design and Verification Methods (CHARME). LNCS 2144. Springer
  (2001)  179--195

\bibitem{NPW02}
Nipkow, T., Paulson, L.C., Wenzel, M.:
\newblock Isabelle/{HOL} - A Proof Assistant for Higher-Order Logic. Volume
  2283 of LNCS.
\newblock Springer (2002)

\bibitem{Park1996a}
Park, S., Dill, D.L.:
\newblock Verification of Flash cache coherence protocol by aggregation of
  distributed transactions.
\newblock In: Proc.\ 8th Annual ACM Symposium on Parallel
  Algorithms and Architectures (SPAA). ACM (1996)  288--296

%\bibitem{Fan2012}
%Fan, D., Zhang, H., Wang, D., Ye, X., Song, F., Li, G., Sun, N.:
%\newblock Godson-t: An efficient many-core processor exploring thread-level
%  parallelism.
%\newblock Micro, IEEE \textbf{32}(2) (2012)  38--47

\bibitem{LiCache14}
Li, Y.:
\newblock {\sf invFinder}: An invariant finder (2014)
  \url{http://lcs.ios.ac.cn/~lyj238/invFinder.html}.

\bibitem{forte}
Technical Publications and Training, Intel Corporation:
\newblock Forte/FL User Guide. 2003.

\end{thebibliography}

\end{document}

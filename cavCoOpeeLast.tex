\documentclass{llncs}
%%%%%%%%%%%%%%%%%%%%%%
%%%%   PACKAGES   %%%%
%%%%%%%%%%%%%%%%%%%%%%
\usepackage{makeidx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{latexsym}
\usepackage{url}
\usepackage{color}
\usepackage{isabelle}
\usepackage{isabellesym}
\usepackage{theorem}
\usepackage{algorithmic}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
%\usepackage{program}
\usepackage{cases}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%For Isabelle code
\newlength{\fminilength}
\newsavebox{\fminibox}
\newenvironment{fmini}[1][\linewidth]
  {\setlength{\fminilength}{#1\fboxsep-2\fboxrule}%
   \vspace{2ex}\noindent\begin{lrbox}{\fminibox}\begin{minipage}{\fminilength}%
   \mbox{ }\hfill\vspace{-2.5ex}}%
  {\end{minipage}\end{lrbox}\vspace{1ex}\hspace{0ex}%
   \framebox{\usebox{\fminibox}}}

\newenvironment{specification}
{\noindent\scriptsize
\tt\begin{fmini}\begin{tabbing}X\=X12345\=XXXX\=XXXX\=XXXX\=XXXX\=XXXX
\=\+\kill} {\end{tabbing}\normalfont\end{fmini}}
\def \twoSpaces {\ \ }
\def \oneSpace {\ }
\def \eqc {\doteq }
\def \andc {\barwedge }
\def \negc {!}
\def \orc {\veebar }
\def \alt {$/\backslash$ }
\def \cat {\symbol{94}}

\def \dbRight {$\backslash\backslash$}
\def \iInv {iInv}
\def \iR {iR}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%for comments
\newcommand\JP[1]{\textcolor{magenta}{JP: #1}}
\newcommand\lyj[1]{\textcolor{green}{lyj: #1}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Additional math operators
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[colorlinks,
            linkcolor=black,
            anchorcolor=black,
            citecolor=blue,
            urlcolor=black,
            bookmarks=true
            ]{hyperref}

\input{tcilatex}

%=========================================
\begin{document}

\title{ {\sf A Novel Approach to Parameterized verification of Cache Coherence Protocols}}
\titlerunning{A Novel Approach to Parameterized verification of Cache Coherence Protocols}
\author{~}
\authorrunning{~}
\institute{~}

\maketitle

%-------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------
Parameterized verification of parameterized protocols like cache coherence protocols is important
but hard.   Our tool {\sf paraVerifier} handles this hard problem in
a unified framework: (1) it automatically  discovers auxiliary invariants and the
corresponding causal relations %between invariants and rules
 from a small reference instance of the verified protocol; (2) the above
invariants and causal relation information  can be also  automatically generalized into a parameterized
form to construct a formally parameterized proof in a theorem prover
(e.g., Isabelle). The principle underlying the generalization is the
symmetry mapping. Our method is successfully applied to typical
benchmarks including  snoopy-based and directory-based. Another novel
feature of our method lies in that the last verification result of a
protocol is provided by a formally readable proof.% in a theorem
%prover like Isabelle.

%-------------------------------------------------------------------------
\end{abstract}
%-------------------------------------------------------------------------
%-------------------------------------------------------------------------


\section{Introduction }
%-------------------------------------------------------------------------
%=========================================
Verification of parameterized concurrent systems is interesting in
the area of formal methods, mainly due to the practical importance
of such systems. Parameterized systems exist in many important
application areas, including cache coherence protocols, security systems, and
network communication protocols. %In this work, we will
%focus on cache coherence protocols, which play a key role in modern
%computer architectures. They require complex algorithms that must
%deal with asynchrony, unpredictable message delays, and multiple
%communication paths between many clients. Therefore, the highest
%possible assurance for the correctness of these complex
%parameterized systems should be guaranteed by formal reasoning
%techniques.
%The real challenge posed by parameterized verification is that the
%desired properties should hold in any instance of the parameterized
%system, not just for a single protocol instance. Model checking is
%automatical but is able to verify just an instance of the parameterized
% system. The correctness of the reference instance  does
%not formally suffice to conclude the correctness for all instances.
%Due to the extreme importance of many parameterized system, it is
%preferable to have a proof that the correctness holds for any
%instance.
The hardness of parameterized verification is mainly due to the requirement of correctness that
the desired properties should hold in any instance of the parameterized
system, not just for a single protocol instance. The model checking tools, although powerful in verification of
non-parameterized systems, becomes impractical to verify parameterized systems, as they can verify only an instance of the parameterized
system in each execution.
A desirable approach is to provide a proof that the correctness holds for any instance.

\paragraph*{Related Work} There have been a lot of research papers in the field of  parameterized
verification~\cite{Pnueli1996,Bj√∏rner1997,Arons2001,Pnueli2001,Tiwari2001,Chou2004,Pandav2005,Lv2007,cubicle2011}.
Among them, the `invisible invariants' method, proposed in~\cite{Arons2001},
is an automatic technique for parameterized verification. In this
method, auxiliary invariants are computed in a finite system
instance to aid inductive invariant checking.  % Work~\cite{Arons2001,Lv2007} attempts to automatically
%find invariants. However, the invisible invariants are raw boolean formulas transferred from the reachable sate set of a small finite instance
%of a protocol, which are BDDs computed by TLV (an variant of BDD\_based SMV model checker). They are too raw to have an intuitive meanings. The capacity of the invisible invariant method is seriously limited when computing the reachable  set of invisible invariants for  the inductive checking is not feasible in the case of a large example like FLASH . Until now, the  examples, which can be handled by the "invisible invariant" method, are quite small,  we still can't find successful experiments  on large examples like FLASH with data paths.
The CMP method, which adopts parameter abstraction and guard strengthening, is proposed
in~\cite{Chou2004} for verifying a safety property $inv$ of
a parameterized system.
 An abstract instance of the parameterized protocol %$, % which consists of m + 1
%nodes $\{P_1, \ldots , P_m, P^*\}$ with $m$ normal nodes and one
%abstract node $P^*$, is constructed iteratively. The abstract system
is constructed by a counter-example-guided refinement process in an  %However, this method's soundness is only argued in an
informal way. %To the best of our knowledge, no one has
%formally proved its correctness in a theorem prover although the authors argued for a mechanized proof for all the thing of CMP in \cite{Chou2004}. Besides, the analysis of counter-example and generation of new auxiliary invariants usually
% depend on human's deep insightful understanding of the protocol. It is too laborious for people to do these analysis. %and some effective automatic  tool is needed to help people.
%It was demonstrated in
%[7] that this method is powerful enough to handle complex
%cache coherence protocols such as FLASH effectively.





The degree of scalability and automatic is the most important of all to estimate an approach in the field of parameterized verification. For instance, FLASH is a hard real-world benchmark for all existing methods for parameterized verification. Human guidance plays a key role in the existing successful verifications for FLASH \cite{Park1996a,McMillan2001,Chou2004}, and this is still the case up to now. %: °∞if the method works on FLASH, then there is a good chance that it will also work on many real-world cache coherence protocols°± \cite{Chou2004}. However, the existing approaches, which have verified FLASH, need too much human intervention. The first full verification of safety properties of FLASH is done by work in \cite{Park1996a}. Park and Dill  proved the safety properties of FLASH using  PVS \cite{cade92-pvs}. %They introduce the aggressioned FLASH protocol, which
%is in fact an abstracted transaction version of FLASH,   need prove
%the correspondence between the abstract and the original FLASH
%protocol, and then prove the correctness of the abstracted protocol, and subsequently derive the correctness of  the
%original protocol by the correspondence. New   auxiliary state variables
%like {\tt fwdSrc} are   introduced  for verification. Deep human insight for FLASH is needed for both the construction of the aggressioned model  and  introducing new state variables.  Later research on FLASH must also rely on these auxiliary
%variables for verification.
%McMillan applied compositional
%model checking \cite{McMillan2001}  and used Candence SMV  \cite{cadenceSMV} to the verification of both safety and liveness properties of FLASH. In a different context, safety
%properties of German 2000 and FLASH were proved via
%Murphi tool \cite{alanHuMurphi} by adopting CMP method in \cite{Chou2004}. In
%all the three methods mentioned above, auxiliary invariants
%have to be supplied manually. Predicate abstraction based
%methods were applied to verify
%FLASH in \cite{dillPred}. Users need to manually provide plausible properties
%in predicate abstraction and automated predicate discovery
%techniques to find large predicates. So verifying large protocols
%like FLASH using predicate abstraction is also difficult. In contrast to previous work, our work need fewer human's aid in the verification of FLASH.   Both the auxiliary invariants and formal proof are generated automatically, and these   auxiliary invariants have intuitive meanings which can  be used to analyze FLASH.  %  The abstractions
%we used, the reliance on apparently circular reasoning, and the counterexampleguided
%discovery of noninterference lemmas are all deeply influenced by McMillan°Øs
%work.
In order to effectively verify complex parameterized protocols like FLASH, there are two critical problems which need to be handled.  The first one is  how to find a set of sufficient and necessary invariants, which is a core problem in the field of parameterized verification. It is desirable to get the invariants with less human intervention.
Previously, the theory foundation of a technique of parameterized verification and its soundness are only discussed in a paper proof style.  %We will compare our approach in \ref{sec:experiments}.%For instance,
%the theory contains the apparent circularity in reasoning and
%applying the auxialiary invariants, and is based on the classical
%notion of a so-called simulation proofs \cite{Chou2004}. Frankly speaking, the
%theory itself is not easy to be understood, and  needs to be
%checked mechanically due to its soundness of should be
%guaranteed without conditions.
It is preferable to formulate all the verification in a publicly-recognized trust-worthy framework like a theorem prover \cite{Chou2004}. However,
 theorem proving in a theorem prover like Isabelle is usually interactive, not automatical.

%which are either used for inductive verification or abstraction
%model construction. Therefore, how to find ans use these auxiliary
%invariants is the central problem in the research field of
%parameterized verification.

In order to solve the parameterized
verification of cache coherence protocols in a both automatical and rigorous way, we design a tool called {\sf paraVerifier}, which is based on a simple but elegant theory.  Three kinds of causal
relations are introduced, which are
essentially special cases of the general induction rule. Then, a
so-called consistency lemma is proposed, which is the cornerstone in
our method. Especially, the theory foundation itself is  verified as a
formal theory in Isabelle, which is the formal library for verifying protocol case studies. The library provides basic type and constant definitions to model protocol cases and lemmas to prove invariant properties. %Therefore, the theoretical foundation is rigorous.

Our tool {\sf paraVerifier} is composed of two parts:  an invariant finder {\tt invFinder}
and a proof generator {\tt proofGen}. %In order to verify  that an
%invariant $inv$ holds for any parameterizd instance of a protocol.
Given a protocol $\mathcal{P}$ and a property $inv$, {\tt invFinder} tries to find useful auxiliary invariants and causal relations which are capable of proving $inv$. To construct auxiliary invariants and causal relations, we employ heuristics inspired by consistency relation. Also, when several candidate invariants are obtained using the heuristics, we use oracles such as an SMT-solver to check each of them under a small reference model of $\mathcal{P}$, and chooses the one that has been verified.



After {\tt invFinder} finds the necessary auxiliary invariants and causal relations, {\tt proofGen} generalizes them  into a parameterized form, which are then used to construct a completely parameterized formal proof in a theorem prover (e.g., Isabelle) to model $\mathcal{P}$ and to prove the property $inv$. After the base theory is imported, the generated proof is checked automatically.  Usually, a proof is done interactively. Special efforts in the design of the proof generation are made in order to make the proof checking automatically. %In order to make the proof checking automatical, the basically formal library theory should be imported, and support

The organization of this work is as follows: Section \ref{sec:Preliminaries} introduces the theoretical foundation; \ref{sec:invFinder} the {\sf invFinder}; \ref{sec:generalization} the generalization strategy; \ref{sec:prooGen} the {\sf proofGen} and the generated proof. We go through these sections by verifying a small example - mutual exclusion example. Section \ref{} shows the further experiments on real-world protocols. Section \ref{} compares ours with the previous work.

\section{Preliminaries}\label{sec:Preliminaries}
%\subsection{Protocol syntax} \label{sec:protocolSyntax}
%Variable are defined by the following BNF grammar:
%\begin{equation*}
%\left.
%\begin{array}{l}
%\mathtt{
%var ::=id |var[int] |rcd.id}
%\end{array}%
%\right.
%\end{equation*}
There are three kinds of $variables$:
1) simple identifier, denoted by a string;
2) element of an array, denoted by a string followed by a natural inside a square bracket. E.g., $arr[i]$ indicates the $i$th element of the array $arr$;
3) filed of a record, denoted by a string followed by a dot and then another string. E.g., $rcd.f$ indicates the filed $f$ of the record $rcd$.
Each variable is associated with its $type$, which can be enumeration, natural number, and Boolean.

%%Expressions and formulas are defined recursively by the following BNF grammar:
%\begin{equation*}
%\left.
%\begin{array}{l}
%\mathtt{
%exp::=var | const | formula?exp:exp|}\\
%\mathtt{formula::=True| False| exp=exp | formula ~op~ formula | \neg formula }

%\end{array}%
%\right.
%\end{equation*}

$Experssions$ and $formulas$ are defined mutually recursively. $Experssions$ can be simple or compound. A simple expression is either a variable or a constant, while a compound expression is constructed with the ite(if-then-else) form $f?e_1:e_2$, where $e_1$ and $e_2$ are expressions, and $f$ is a formula.
A $formula$ can be an atomic formula or a compound formula. An atomic formula can be a boolean variable or boolean constant, or in the equivalence form $e_1\eqc e_2$, where $e_1$ and $e_2$ are two expressions. A $formula$ can also be constructed from formulas using the logic connectives, including negation ($\negc$), conjunction ($\andc$), disjunction ($\orc$), implication ($\dashrightarrow$). %, logical equivalence ($\longleftrightarrow$).

An $assignment$ is a mapping from a variable to an expression, and is denoted with the assigning operation symbol ``:=''. A $statement$ $\alpha$ is a set of assignments which are executed in parallel, e.g., $ x_1:=e_1;x_2:=e_2;...;x_k:=e_k $. If an assignment maps a variable to a (constant) value, then we say it is a $value$-$assignment$.  We use $\alpha|_x$ to denote the expression assigned to $x$ under the statement $\alpha$. For example, let $\alpha$ be $\{arr[1]:=C;x:=false\}$, then $\alpha|_x$ returns $false$. A $state$ is an instantaneous snapshot of its behavior given by a set of value-assignments.




For every expression $e$ and formula $f$, we denote the value of $e$ (or $f$) under the state $s::var \Rightarrow valueType $ as $\mathbb{A}[e,s]$ (or $\mathbb{B}[f,s]$).
For a state $s$ and a formula $f$, we write
$s\models f$ to mean %$\mathbb{A}[e,s]=c$ and
$\mathbb{B}[f,s]=true$.
Formal semantics of expressions and formulas are given in HOL (higer-order logics) as usual, which is shown in the appendix.\footnote{The logic to specify parameterized system is a special logic, which can be embedded in HOL supported by Isabelle. Therefore, HOL can be seen as the main meta-logic to specify our work.}


For an expression $e$ and a statement $\alpha= x_1:=e_1;x_2:=e_2;...;x_k:=e_k $, we use $\mathsf{vars(\alpha)}$ to denote the variables to be assigned $\{x_1,x_2,...x_k\}$; and use $e^{\alpha}$ to denote the expression transformed from $e$ by substituting each $x_i$ with $e_i$ simultaneously.
Similarly, for a formula $f$  and a statement $\alpha= x_1:=e_1;x_2:=e_2;...;x_k:=e_k $, we use $f^{\alpha}$ to denote the formula transformed from $f$ by substituting each $x_i$ with $e_i$.
Moreover, $f^{\alpha}$ can be regarded as the weakest precondition of formula $f$ w.r.t. statement $\alpha$, and we denote $preCond(f,\alpha)\equiv f^{\alpha}$. Noting that a state transition is caused by an execution of the statement, formally, we define: $s\overset{\alpha}{\twoheadrightarrow } s' \equiv$ $(\forall x \in \mathsf{vars}(\alpha). s'(x)= \mathbb{A}[\alpha|_x,s])$ $\wedge (\forall x \notin \mathsf{vars}(\alpha). s'(x)= s(x))$ .

A $rule$ $r$ is a pair $<g,\alpha>$, where $g$ is a formula and is called the $guard$ of rule $r$, and $\alpha$ is a statement and is called the $action$ of rule $r$.
 For convenience, we denote a rule with the guard $g$ and the statement $\alpha$ as $g \vartriangleright \alpha$. Also, we denote $\mathsf{act}(g \vartriangleright \alpha)\equiv \alpha$ and $\mathsf{guard}(g \vartriangleright \alpha)\equiv g$. If the guard $g$ is satisfied at state $s$, then $\alpha$ can be executed, thus a new state $s'$ is derived, and we say the rule $g \vartriangleright \alpha$ is triggered at $s$, and transited to $s'$. Formally, we define: $s\overset{r}{\rightarrow } s' \equiv s\models \mathsf{guard}(r) \wedge s\overset{\mathsf{act}(r)}{\twoheadrightarrow } s'$.

A $protocol$ $\mathcal{P}$ is a pair $(I,R)$, where $I$ is a set of $formulas$ and is called the initializing formula  set, and $R$ is a set of rules. %A $state$ is an instantaneous snapshot of its behavior given by a set of assignments.
 As usual, the reachable state set of protocol  $\mathcal{P}=(I,R)$, denoted as $\mathsf{reachableSet}(\mathcal{P})$, can be defined inductively: (1) a state $s$ is in
$\mathsf{reachableSet}(\mathcal{P})$ if there exists a formula $f \in I$, and $s \models  f$; (2) a state $s$ is in
$\mathsf{reachableSet}(\mathcal{P})$ if there exists a  state $s_0$  and a rule $r \in R$ such that $s_0 \in \mathsf{reachableSet}(\mathcal{P})$ and $s_0\overset{r}{\rightarrow } s$.

A parameterized object(T) is simple a function from a natural number to T, namely of type $nat \Rightarrow T$. For instance, a parameterized formula $pf$ is of type $nat \Rightarrow formula$, and we define
$\mathsf{forallForm}(1,pf)\equiv~pf(1)$, and $\mathsf{forallForm}((n+1),pf)\equiv\mathsf{forallForm}(n,pf) \andc pf(n +1)$. $\mathsf{existsForm}(1,pf)\equiv~pf(1)$, and $\mathsf{existsForm}((n+1),pf)\equiv\mathsf{existsForm}(n,pf) \orc pf(n +1)$.





Now we use a simple example to illustrate the above definitions by a simple mutual exclusion protocol with $N$ nodes. Let $\mathsf{I}$, $\mathsf{T}$,
 $\mathsf{C}$, and  $\mathsf{E}$  be three enumerating values, $x$,    $n$ are  simple and array variables, $N$ a natural number,  $pini(N)$   the predicate to specify the inial state, prules(N) the four rules of the protocol, $mutualInv(i,j)$ a property that $n[i]$ and $ n[j]$ cann't be $C$ at the same time. We want to verify that $mutualInv(i,j)$ holds for any $i\le N$, $j \le N$ s.t. $i \neq j$.

\begin{example}\label{example1}Mutual-exclusion example.

\begin{specification}
assignN(i)$\equiv$n[i]=I\\
 pini(N) $\equiv$
   x=true $\wedge$  forallForm(N,assignN )\\

    try(i) $\equiv$ n[i] $\eqc$ I $\vartriangleright$ n[i] := T \\

    crit(i) $\equiv$ n[i] $\eqc$ T$\wedge$ x = true $\vartriangleright$  n[i] := C; x := false\\

%
   exit(i) $\equiv$ n[i] $\eqc$ C $\vartriangleright$ n[i] := E \\


   idle(i) $\equiv$  n[i] $\eqc$ E $\vartriangleright$ n[i] := I;  x := true
  \\% \\
   prules(N) $\equiv$ \{r. $\exists$ i. i $\le$ N $\wedge$( r=crit(i)~$\vee$ r=exit(i)  $\vee$ r=idle (i)~$\vee$ r=try (i)\}\\
%\\

mutualEx(N)$\equiv$ (pIni(N), prules(N))\\

mutualInv(i,j) $\equiv$
  $\negc$ (n[i]$\eqc$ C $\andc$ n[j]$\eqc$ C)\\



\end{specification}
\end{example}


As Hoare logics specifies,  after executing statement $\alpha$, $f$ holds iff $\mathsf{preCond}?f, \alpha?$ holds before the execution.
\begin{lemma}\label{lemma-preCond}
Suppose $s\overset{\alpha}{\twoheadrightarrow } s'$,
$s\models \mathsf{preCond} (f, \alpha)$ if and only if $s'\models f$
\end{lemma}
%definition statementEnableForm:: rule $\Rightarrow$
%formula$\Rightarrow$bool
%\\
% where statementEnableForm r f$\equiv$
%$\forall$s. formEval (pre r) s \\
%$\longrightarrow$ formEval  (preCond f (act r)) s\\
%definition statementDisableForm::rule$\Rightarrow$formula$\Rightarrow$bool\\
%where statementDisableForm r f $\equiv$
 %    $\forall$s. formEval (pre r) s \\
%$\longrightarrow$ $\neg$ formEval  (preCond f (act r)) s
%\end{specification}

%Function $\mathsf{statementEnableForm}$ says that the guard of the rule implies
% the pre-condition of  formula $f$  w.r.t. statement of
% the rule. This means that $f$ must be valid after statement $S$ is executed.
%On the other hand,  $\mathsf{statementDisableForm}$ says that   the
%guard of the rule implies the negation of the pre-condition of
%formula $f$ w.r.t. statement of the rule. This means that $f$ must
%be invalid after statement $S$ is executed.
%For instance,  for the statement $S=\mathsf{assign}~
%((\mathsf{Para}~  n~ 0), (\mathsf{Const} ~\mathsf{T}))$, formula
%$f_1= \mathsf{eqn}~ (\mathsf{IVar}~ (\mathsf{Para}~ n 0))
%(\mathsf{Const}~ \mathsf{T})) $, $f_2= \mathsf{eqn}~ (\mathsf{IVar}~
%(\mathsf{Para}~ n ~0))\mathsf (\mathsf{Const}~ \mathsf{E}))$, we
%have $\mathsf{statementEnableForm}~S~f_1$ and
%$\mathsf{statementDisableForm}~S~f_2$. We also define two functions
%$\mathsf{varOfForm}~f$ and $\mathsf{varOfSent}~S$ to denote the set
%of variables used in the formula $f$ and statement $S$.


\section{Causal relations and consistency lemma} \label{sec:causal_rel}
A novel feature of our work lies in that three kinds of causal
relations are exploited, which are essentially special cases of the
general induction rule.  Consider a rule $r$, a formula $f$, and a formula set $fs$, three
 kinds of causal relations are defined as follows:\\
 \begin{definition}
We define the following relations: $\mathsf{invHoldRule_1}::state \times formula\times rule \Rightarrow bool$, $\mathsf{invHoldRule_2}::state\times  formula\times rule  \Rightarrow bool$,  $\mathsf{invHoldRule_3}::state \times formula\times rule \times rule set\Rightarrow bool$, and $\mathsf{invHoldRule_3}::state \times formula\times rule \times rule set\Rightarrow bool$.
\begin{enumerate}
\item $\mathsf{invHoldRule_1} (s,f,r) \equiv $$s \models \mathsf{pre}(r) \longrightarrow s \models \mathsf{preCond}(f ,\mathsf{act}(r))$;\footnote{Here  $\longrightarrow$ and $\longleftrightarrow$ are HOL connectives.  }
\item $\mathsf{invHoldRule_2}(s,f,r) \equiv  $$s \models f \longleftrightarrow s \models \mathsf{preCond}( f,(\mathsf{act}( r))$;
\item $\mathsf{invHoldRule_3}(s,f,r,fs) \equiv$  $\exists f' \in fs$ s.t.
$s \models ( f' \andc (\mathsf{pre}(r))  \longrightarrow s \models \mathsf{preCond}(f ,\mathsf{act}(r))$;
\item $\mathsf{invHoldRule}(s,f,r, fs) \equiv$   $s \models\mathsf{invHoldRule_1}(s,f,r) \vee s\models\mathsf{invHoldRule_2}(s,f,r) \vee s\models \mathsf{invHoldRule_3}(s,f,r,fs)$.
%\item $\mathsf{invHoldRule}~ f~ r ~fs \equiv (\mathsf{invHoldRule_1} ~f
%  ~r) \lor (\mathsf{invHoldRule_2} ~f ~r) \lor (\mathsf{invHoldRule_3}~ f~ r~fs)$.
\end{enumerate}
\end{definition}
%\begin{specification}
%definition invHoldRule1::
%formula $\Rightarrow$ state $\Rightarrow $ rule $\Rightarrow$ bool where\\
%invHoldRule1 s f  r$\equiv$ %\\
%(  formEval (pre r) s $\longrightarrow$
%  formEval  (preCond f  (act r)) s ) \\ %\\

%definition invHoldRule2:: state $\Rightarrow$ formula $\Rightarrow$ rule $\Rightarrow$ bool
% where \\

%invHoldRule2 s f  r $\equiv$  (  formEval  (preCond f  (act r)) s  =  formEval f s\\
%\end{specification}

%\vspace{2mm}
% \begin{specification}
%definition   invHoldRule3::
%state $\Rightarrow$ formula $\Rightarrow$ rule $\Rightarrow$formula set$\Rightarrow$ bool\\

% invHoldRule3 s f r fs  $\equiv$\\
%  (let pref=preCond f (act r) in\\
%  ( $\exists$f'. f' $\in$ fs $\wedge$  (formEval   (andForm (pre r)  f') s$\longrightarrow$
% formEval  pref s)))\\
%\\
%abbreviation invHoldRule::
%state $\Rightarrow$formula $\Rightarrow$ rule $\Rightarrow$ (formula set) $\Rightarrow$ bool
% where\\

%invHoldRule s inv0 r invs $\equiv$\\
%    invHoldRule1 s inv0 r $\vee$  invHoldRule2 s inv0 r $\vee$
 %  invHoldRule3 s inv0 r invs\\




%\%end{specification}

The relation $\mathsf{invHoldRule}(s, f,r,fs)$ defines a causality relation
between $f$, $r$, and $fs$, which guarantees that if each formula in $fs$ holds
before the execution of rule $r$, then $f$ holds after the execution of rule $r$. This includes three cases. 1) $\mathsf{invHoldRule}_1(s,f, r)$ means that after rule $r$ is executed, $f$ becomes true immediately;   2) $\mathsf{invHoldRule}_2(s,f, r)$ states that $\mathsf{preCond}(S,f)$ is equivalent to $f$, which intuitively means that none of state variables in $f$ is changed, and the execution of statement $S$ does not affect the evaluation of $f$;
 3) $\mathsf{invHoldRule}_3(s,f, r,fs)$ states that there exists another invariant $f' \in fs$ such that
  the conjunction of the guard of $r$ and $f'$ implies the precondition  $\mathsf{preCond}(S,f)$.
%Intuitively, $\mathsf{invHoldRule}(s, f, r, fs)$ defines a causal relation, which guarantees that if each of formula in $fs$ holds before the execution of the rule $r$, then  $f$ also holds after the execution of the rule $r$.

The second way to view $\mathsf{invHoldRule}(s, f, r, fs)$ is to regard it as a
special kind of inductive tactics, which can be applied to prove
each formula in $fs$ holds at each inductive protocol rule cases. Note that the three kind of inductive tactics can be done by a theorem prover, which is the cornerstone of our work.

With the $\mathsf{invHoldRule}$ relation, we define a consistency relation $\mathsf{consistent}( invs,inis, rs)$ between a protocol $(inis,rs)$ and a set of invariants $invs=\{inv_1,\ldots, inv_n\}$.

\begin{definition}
we define a relation $consistent::formula~ set \times formula~ set
\times rule ~set \Rightarrow bool$.
 $consistent( invs,inis, rs)$ holds if the following conditions hold:
\begin{enumerate}
\item for all formulas $inv\in invs$ and $ini\in inis$ and all states $s$,
$s \models ini$ implies $s \models inv$;
\item for all formulas $inv\in invs$ and rules  $r \in rs$ and all states $s$,  $\mathsf{invHoldRule}(s, inv, r, invs   )$
\end{enumerate}
\end{definition}

%Intuitively, the above definition specifies that:
%\begin{itemize}
%\item For any invariant $inv \in invs$,
%initializing predicate $ini \in ini$, and state $s$, if $ini$ is
%evaluated true at state $s$, then $inv$ is also evaluated true at
%state $s$.

%\item For any invariant $inv \in invs$, $r$ in the rule set
%$rs$, either one of the following five types of relation holds,
%i.e., $\mathsf{invHoldRule_{1-3}}inv r$.

%\end{itemize}

%For instance,

\begin{example}\label{example2}
Let us define a set of auxiliary invariants:

\begin{specification}
invOnXC(i)  $\equiv$ $\negc$(x $\doteq$ true $\andc$ n[i]$\doteq$ C)   \ \ \

invOnXE(i)   $\equiv \negc$ (x $\doteq$ true$\andc$ n[i] $\doteq$ E)  \\


aux$_1$(i,j)   $\equiv \negc$ ( n[i]$\doteq$ C$\andc$n[j] $\doteq$ E)   \ \ \

aux$_2$ (i,j) $\equiv \negc$  ( n[i]$\doteq$ E$\andc$n[j]$\doteq$ C)\\

  pinvs(N)$\equiv$ \{f. $\exists$ \iInv1 \iInv2. \iInv1 $\le$ N $\wedge$ \iInv2 $\le$ N $\wedge$ \iInv1 $\ne$ \iInv2 $\wedge$   f =mutualInv   \iInv1 \iInv2) \\
 $ \vee(\exists$ \iInv1. \iInv1 $\le$ N $\wedge$  f =invOnXC  \iInv1)   \\
$\vee(\exists$ \iInv1. \iInv1 $\le$ N $\wedge$  f= invOnXE \iInv1)    \\
$\vee(\exists$ \iInv1 \iInv2. \iInv1 $\le$ N $\wedge$ \iInv2 $\le$ N $\wedge$ \iInv1 $\ne$ \iInv2 $\wedge$ f =  aux1  \iInv1 \iInv2) \\
$\vee(\exists$ \iInv1 \iInv2. \iInv1 $\le$ N $\wedge$ \iInv2 $\le$ N $\wedge$ \iInv1 $\ne$ \iInv2 $\wedge$ f =  aux2  \iInv1 \iInv2) \}.

\end{specification}
\begin{itemize}
\item  $\mathsf{invHoldRule_1 }(s,\mathsf{invOnXC}( 1),
\mathsf{crit}(1))$ because $\mathsf{preCond}(\mathsf{act}(\mathsf{crit}(1)),
 \mathsf{invOnXC} (1))=\negc (\mathsf{flase}\eqc\mathsf{true}\andc \mathsf{C}\eqc\mathsf{C})$ which is a tautology;

\item  $\mathsf{invHoldRule_2 }(s,\mathsf{mutual}(
1,2), \mathsf{try}(3))$ because $\mathsf{preCond}(\mathsf{act}(\mathsf{try}(3)),
 \mathsf{mutual}( 1,2))=\mathsf{mutual} (1,2)$;

 \item   $\mathsf{invHoldRule_3 }(s,\mathsf{mutual} (1,2), \mathsf{crit}(1),(\mathsf{pinvs} (N))$.
   because
 $\mathsf{invOnXC}( 2) \in \mathsf{pinvs} (N)$, $\mathsf{preCond}(\mathsf{act}(\mathsf{crit}(1)),
 \mathsf{mutual} (1,2))=\negc (\mathsf{C}\eqc\mathsf{C}\andc n[2]\eqc\mathsf{C})$,
 and $  s \models \mathsf{guard}(\mathsf{crit}(1)) \andc \mathsf{invOnXC}(2)$ implies
 $ s \models \negc (\mathsf{C}\eqc\mathsf{C}\andc n[2]\eqc\mathsf{C})$. Notice that  the guard condition of
 $\mathsf{crit}(1)$ is $n[1]\eqc T \andc x\eqc\mathsf{true}$.
 \end{itemize}
\end{example}



  %It is not diffcult to verify
%$\mathsf{consistent}~ (\mathsf{pinvs}~ N) ~(\mathsf{pini}~N)~
%(\mathsf{prules}~N)$ also holds.



 Suppose that the consistency relation
$\mathsf{consistent}( invs, inis, rs)$ holds, for any $inv \in invs$,
$inv$ holds for any reachable state $s$ such that $s  \in
\mathsf{reachableSet}( ini, rs)$. The following lemma formalizes the essence of the aforementioned causal relation, and is called consistency lemma.

\begin{lemma}\label{consistentLemma}%[(consistency lemma)]
 If $P=(ini,rs)$, $\mathsf{consistent}( invs, ini, rs)$, and $s  \in \mathsf{reachableSet}(P)$, %  $\isasymrbrakk\Longrightarrow$
 then   for all $inv$ s.t. $inv \in invs$, $s \models inv $.
\end{lemma}

\section{  {\sf invFinder}}

In this section, we present an algorithm called {\tt InvFinder}, which finds all necessary ground invariants from a protocol instance.

\subsection{The InvSearch Algorithm}

The core of {\tt InvFinder} is an algorithm called {\tt InvSearch}, which works iteratively in a semi-proving and semi-searching fashion to create invariant.

\SetAlFnt{\small}


\begin{algorithm}\label{alg:invSearch}

\caption{Core Searching Algorithm: $InvSearch$}

\KwIn{$chk$, $tautChk$, $rule$, $inv$, $invs$   }

\KwOut{A formula  option $f$, a new causal relation $rel$}

{
    $g\leftarrow $the guard of rule, $S\leftarrow $the statement of rule\;

    $inv'\leftarrow preCond(inv, S)$\;

    \If{$inv=inv'$}
    {
    $relItem\leftarrow (rule, inv, invRule_2,-)$\;
    \Return $(NONE,  relItem )$\;
    }
    \ElseIf{$tautChk(g\rightarrow inv')=true$}
    {
    $relItem\leftarrow (rule, inv, invRule_1,-)$\;
    \Return $(NONE,  relItem )$\;
    }
    \Else
    {
    $candidates\leftarrow subsets(dualNeg(inv')\andc g)$\;
    $newInv\leftarrow choose(chk,candidates)$\;
    $relItem\leftarrow (rule, inv, invRule_3,newInv)$\;
    \If{$isNew(newInv,  invs)$}
    {
    $newInv \leftarrow  normalize(newInv)$\;%$ and insert it into the head of $newInvs$\;
    \Return $(SOME(newInv),   relItem )$\;
    }
    \Else{\Return $(NONE,  relItem )$\;}
    }
}

%}

\end{algorithm}


The {\tt InvSearch} algorithm needs to call two oracles. The first one, denoted by {\tt chk}, checks whether a ground formula is an invariant in a given small reference model of the protocol. Such an oracle can be implemented by translating the formula into a formula in SMV, and calling SMV to check whether it is an invariant. The second oracle, denoted by
{\tt tautChk}, checks whether a formula is a tautology. It is implemented by translating the formula into a form in the SMT (SAT Modulo Theories) format, which is checked by an SMT solver such as Z3.

There are some input parameters in {\tt InvSearch}, including a rule instance $rule$, an invariant $inv$, a sets of invariants $invs$, and a set of causal relations $casRel$. The algorithm {\tt InvSearch} searches for new invariants and    constructs the causal relation between the rule instance $r$ and the invariant $inv$. The sets $invs$  and the set $casRel$ stores causal relations constructed up to now.%  The above function {\sf findInvsFromRule} tries to find new
%invariants and construct the causal relation between the rule
%instance $rule$. %The statement {\tt
%cond => te|fe} is an abbreviation of the if-then-else expression
%that if $cond$ is true then $te$ else $fe$.
%Parameters $newInvs$, $invs$, and $casRel$ are new invariants, invariants, and all the
%causal relations constructed up to now, the above oracle functions
%are also passed as parameters.  % Causal relations  are still not
%checked between the ones in $newInvs$ and rules.
The returned result is a pair of the newly found invariant (if found)  and causal relation item.
%

After computing the pre-condition $ inv'$, which is the weakest precondition of the input formula $inv$ w.r.t. $S$, and takes further operations according to the cases it faces with:
{\sf InvSearch} performs case analysis on $inv'$:


First,  if $ inv=inv'$,
 which means that statement $S$ does not change $inv$, then no new invariant is created, and  new causal
relation item marked with tag {\tt invHoldRule$_2$} is recorded
between $rule$ and $inv$, but at this moment there are no new
invariants to be added. %; for instance, let $ rule=\mathsf{crit} (3)$,  $ inv=\mathsf{mutualInv}(1,2)$, thus $inv'=\mathsf{preCond}(S,inv)=inv$, then a pair  $ (\mathsf{NONE}, ( crit(3), inv, \mathsf{invHoldRule}_2,\_))$ will be returned, where $NONE$ means no new invariant formula is returned.

Secondly, if $\mathsf{ tautChk}$ verifies that $g \longrightarrow inv'$ is a tautology, then  no new invariant is created, and
the new causal relation item marked with tag
$ \mathsf{invHoldRule}_1$ is recorded between $rule$ and $inv$. %For instance, let $rule=\mathsf{crit}(2)$, $inv=\mathsf{invOnXC}(1)$, $inv'=\mathsf{preCond}(S,inv)=\neg(\mathsf{false }\eqc \mathsf{true} \andc n[1] \eqc \mathsf{C})$, obviously, $ g \longrightarrow_C inv'$ holds forever because $inv'$ is always evaluated true, thus a pair $(\mathsf{NONE},  (\mathsf{crit}(2), inv, \mathsf{invHoldRule}_1,\_))$ will be returned.


Thirdly, if neither of the above two cases holds, then a new auxiliary invariant $newInv$ will be constructed, which will make the causal relation $ \mathsf{invHoldRule}_3$  to hold.
 We first give some definitions. A formula $f$ can be composed into a set of sub-formulas $f_i$, denoted as $decompose(f)$, such that each $f_i$ is not of a conjunction form and $f$ is semantically equivalent to $f_1 \andc f_2 \andc ... \andc f_N$. For a formula $f$, we use $subsets(f)$ to denote the power set of $decompose(f)$.
Now we can describe the construction of the auxiliary invariant:
A proper formula is chosen from the candidate set $subsets(dualNeg(inv')\andc g)$ to construct a new invariant $newInv$. This is accomplished by the {\tt choose} function, which calls the oracle {\tt chk} to verify whether a formula is an invariant in the given reference model. After $newInv$ is chosen, the function $isNew$ checks whether this invariant is new w.r.t. $newInvs$ or $invs$. If this is the case, the invariant will be normalized, and then be  added into $newInvs$, and the new causal relation item marked with tag {\tt invRule$_3$} will be added into the causal relations. Here, the meaning of the word ``new" is modulo to the symmetry relation. For instance,   $\mathsf{mutualInv}(1,2)$ is equivalent to
$\mathsf{mutualInv}(2,1)$ in a symmetry view. The $\mathsf{ normalize}$ function normalizes the numbering order of the use of parameters in the invariant $inv$.
The result formula should be   a normal form, whose parameters
  always start from 1, and increase one by one if there are more
  parameters. %Namely,  $\negc (x\eqc\mathsf{true} \andc n[1]\eqc\mathsf{C})$ is normalized, but $\negc (x\eqc\mathsf{true} \andc n[2]\eqc\mathsf{C})$  not.    Let $ invs=\emptyset$, $ rule=\mathsf{crit}(1)$, $ inv=\mathsf{mutualInv}(1,2)$, $ inv'= \mathsf{preCond}(S,inv)=\negc(true\eqc true \andc n[2]\eqc C)$, from all the subsets of $\{n[1]\eqc T, x\eqc true, n[2]\eqc C\}$, the $ \mathsf{choose}$ oracle selects the subset $\{ x=true, n[2]\eqc C\}$ combines all the item in this candidate, then constructs a new invariant $ \neg(x\eqc true \andc n[2]\eqc C)$. After   normalization, the new invariant   $\neg(x=true \andc  n[1]\eqc C)$  and  a  relation item $ ((crit(1),   \mathsf{invHoldRule}_3, invs)$ will be returned.






%The main body of {\sf paraVerifier}'s algorithm iteratively calls
%the function {\sf findInvsFromRule}  by instantiating each
%parameterized rule with different actual parameters of the finite
%reference protocol model. This procedure is finished until no more
%5new invariants can be created.
There are three key techniques in our invariant candidate choosing policy. Recalling that our candidate choosing problem can be formulated as follows: Among a set $S$ of invariant formulas, choose a subset $S_1\subseteq S$ such that $S_1$ is the minimal set that satisfies $\neg \bigwedge S_1$ is an invariant. Meanwhile, for any formula set $S_2$ such that $|S_2|<|S_1|$,  $\neg \bigwedge S_2$ is not an invariant.

The first is about  checking whether a formula $\neg \bigwedge S_1$ is an invariant. In our implementation, the oracle firstly tries to use a reachable set of a simplified reference protocol instance within a small size $L$  to check the validity of the formula if each variable of $\neg \bigwedge S_1$ exists in the instance; otherwise, the oracle uses MURPHI or  BMC feature of NUSMV to rule out the non-invariant formulas within another reference protocol instance where all the variables of $\neg \bigwedge S_1$ exists, and regard the formula as an invariant if MURPHI or  BMC procedure time-outs. For verification of a complex protocol, the combination of the two strategies is critical  as we cannot enumerate a complete reachable set of a protocol instance. %For FLASH with data manipulations, it is not feasible to enumerate a complete reachable set of a reference protocol instance with size $3$  to check the validity of the  candidate; however we can use the  reachable set of a reference instance of simplified FLASH protocol without data manipulations with size $3$ to conjecture control properties, and use the second strategy from a full FLASH protocol with data with size $3$ to guess the properties on data properties or control properties involving a parameter which is greater than L.

Secondly, choosing policy are done in an augmenting way. Firstly, we initialize $size=1$ choose a set $S$ with $|S_1|=size$, if {\tt chk $S_1$}, then stops; otherwise increases $size$; this process repeats until $S=S_1$ or  {\tt chk $S_1$}.

Finally, heuristic choosing policies can be adopted based on experiences in this field. For instance, if the pre-condition {\tt inv'} contains only a parameterized variable $v$ with a parameter $i$, then $f$ in $S$ will be chosen with some priority which $v$ occurs in $f$. If we still cannot choose such a formula $f$, we  try to find another formula $g$ which contains a global variable $v'$ which will be assigned with a new value in the statement of the rule. $\{ f,g \}$ usually is the desired set $S_1$.



\subsection{The Parameter Instantiation Policy}

According to a parameter instantiation policy, main body of {\sf invFinder} generates a group of actual parameters to instantiate a parameterized rule $pr$ into a set of actual rules $R$, and call Algorithm \ref{alg:invSearch} to compute new invariant and causal relation between each rule   $r\in rs$ and an invariant formula $inv$. In order to formulate our parameter instantiation policy, we need introduce the concept of permutation modulo to symmetry relation $\sim_m^n$,  and a quotient set of $\mathsf{perms}_{m}^{n}$ (the set of all $n$-permutations of $m$) under the  relation.
\begin{definition}
Let $m$ and $n$ be two natural numbers, where $n \le m$,  $L$ and $L'$ are two lists which stand for two  $n$-permutations of $m$,
\begin{enumerate}
\item
$L \sim_m^n L' \equiv (|L| =|L'|) \wedge (\forall i. i<|L| \wedge L_{[i]} \le m-n \longrightarrow L_{[i]}=L'_{[i]})$.

%\item$[[L]]_{m}^{n} \equiv \{L'. L \in \mathsf{perms}_{m}^{n} \wedge L \sim_m^n L'\}$.

\item $\mathsf{semiP}(m,n,S)\equiv (\forall  L \in \mathsf{perms}_{m}^{n} \exists  L' \in S. L \sim_m^n L' ) \wedge (\forall  L\in S. \forall L'\in S. L \neq L' \longrightarrow \neg  (L \sim_m^n L' )$.

\item    A set $S$ is called a quotient of the set $\mathsf{perms}_{m}^{n}$ under the relation $\sim_m^n$ if and only if    $\mathsf{semiP}(m,n,S)$.
\end{enumerate}
\end{definition}

For instance, let $m=5$, $n=2$, $[1,2]\not\sim_5^2[2,1]$, $[1,3]\not \sim_5^2[1,4]$ and  $[5,4]\sim_5^2 [4,5]$. It is easy to see that, $[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2],[3,4]]$ is a quotient set of $\mathsf{perms}_{m}^{n}$ under $\sim_5^2$.

If $m>0$,   $\mathsf{perms}_{m}^{1}$ is the quotient set of itself under $\sim_m^1$.


{\bf Our Parameter Instantiation Policy:}
Let $cinv$  be a concrete invariant, $pr$ be a parameterized rule, $\mathsf{aPNumOfInv}(cinv) $ be the number of actual parameters occurring in $cinv$, and $\mathsf{fpNumOfRule}(pr) $  be the number of formal parameters occurring in $pr$,  our policy is to compute the set  $\mathsf{cmpSemiperm}(\mathsf{aPNumOfInv}(cinv)+\mathsf{fpNumOfRule}(pr),\mathsf{fpNumOfRule}(pr) )$, and use elements of it as a group of parameters to instantiate $pr$ into a set $R$ of actual rules.




The instantiation policy should be complete. That is,
%How many instantiations are needed? Here the underlying instantiation principle should guarantee that each typical proof case by comparing parameters occurring in a rule and an invariant in parameterized protocol instance,  should be covered by a sampling case in our parameter instantiation policy. That is to say,
if we regard the finite instantiations as samplings, it must guarantee that the samples are sufficient to be generalized in {\sf proofGen}
to parameterized forms  to finish  parameterized proofs. We first explain the concept of ``typical proof
case by comparing parameters occurring in a rule and an invariant".  Let $LR=[2]$, $LI=[1,2]$, we compare an element in $LR$ with another of $LI$, $LR_1 = LI_2$ is a formula characterizing the comparison between the first element in $LR$ with the second element in $LI$.
\begin{definition}
let $LR \in \mathsf{perms}_N^{|LR|}$ and $LI \in \mathsf{perms}_N^{|LI|}$ are two permutations s.t. $0<|LR|\le N$ and $0<|LI|\le N$
\begin{enumerate}
\item $\mathsf{equality}(LR,LI,i,j) \equiv LR_{[i]} = LI_{[j]}$. Recall that $LR_{[i]}$ is the $i-$th element of $LR$.
\item $LR' \in \mathsf{perms}_{N'}^{\mathsf|LR|)}$ and $LI' \in \mathsf{perms}_{N'}^{|LI'|}$ are two permutations s.t. $0<|LR'|\le N$ and $0<|LI'|\le N$ and $|LR|=|LR'|$, and $|LI|=|LI'|$, $\mathsf{reflection}((LR,LI),(LR',LI')) \equiv \forall i \le |LR|. \forall j\le |LI|. (\mathsf{equality}(LR,LI,i,j) \leftrightarrow \mathsf{equality}(LR',LI',i,j))$

\end{enumerate}
\end{definition}

The $\mathsf{reflection}((LR,LI),(LR',LI'))$ means that, if we do case analysis by comparing elements in $LR$ and in $LI$, the case pattern are the same with that by comparing those in $LR'$ and in $LI'$.


%Recall our parameter instantiation policy:  for a parameterized rule $pR$, a parameterized   formula $pinv$, we only use an identical permutation $ID$ to instantiate $pinv$, and permutations in $\mathsf{cmpSemiperm}(\mathsf{len}(LR)+\mathsf{len}(LI),\mathsf{len}(LR))$ to instantiate $pR$.

Now we look at the completeness of our instantiation policy:    let $LR$ and $LI$ are actual parameters to instantiate $pR$ and $pInv$, the case analysis pattern between $LR$ and  $LI$ can be reflected by that between some $LR'$ and $ID$, where $LR' \in \mathsf{cmpSemiperm}(\mathsf{len}(LR)+\mathsf{len}(LI),\mathsf{len}(LR))$, $ID$ is a permutation with the same length with $LI$. Luckily, the following lemma gives a positive answer.



%relation $LR_i=LI_j$  can be kept by a comparing  $LR'_i=ID_j$, where $LR'$ is a permutation in  $\mathsf{cmpSemiperm}(\mathsf{len}(LR)+\mathsf{len}(LI),\mathsf{len}(LR))$, $ID$ is identical permutation such that $ID_i=i$.
\begin{lemma}[completeness of parameter instantiation]\label{lemma:completeness}
let $LR \in \mathsf{perms}_N^{\mathsf{len}(LR)}$ and $LI \in \mathsf{perms}_N^{\mathsf{len}(LI)}$ are two permutations s.t. $|LR|>0$ and $|LI|)>0$ and $|LR| \le N$  and $|LI| \le N$, let $ID$ be an identical permutation which has the same length with $LI$, there exists a permutation $LR' \in \mathsf{cmpSemiperm}(|LR|+|LI|,|LR|)$ s.t. $\mathsf{reflection}((LR,LI),(LR',ID))$.
\end{lemma}

Here we use two examples to explain this lemma. Let $LR=[2]$, $LI=[2,1]$, there exists $LR'=[1]\in \mathsf{cmpSemiperm}(3,1)$ s.t. $reflect((LR,LI),(LR',ID))$; let $LI=[5,6]$, there exists $LR'=[3]\in \mathsf{cmpSemiperm}(3,1)$ s.t. $\mathsf{reflect}((LR,LI),(LR',ID))$.


\subsection{The Top-level Algorithm?}
Now we discuss the top level of {\sf invFinder}. First we show how to search
new invariants and causal relations between  a parameterized  rule   $pr$ and an invariant formula. The algorithm of parameter instantiation to the $pr$ and calling {\sf invSearch} to search  auxiliary invariants are listed in Algorithm \ref{alg:invFinder-II}:

\begin{algorithm}\label{alg:invFinder-II}

\caption{parameter instantiations: invFinder-II }\label{alg:parameterInstantiate}

\KwIn{parameterized rule $pr$,  a concrete invariant $cinv$, two formula set $invs$ and $newInvs$, a relation set $rel$ }

\KwOut{  two formula set $invs'$ and $newInvs'$, a relation set $rel'$ }

{  $ni\leftarrow \mathsf{aPNumOfInv}(cinv) $\;
   $nr \leftarrow \mathsf{fpNumOfRule}(pr)$\;

   $S \leftarrow \mathsf{cmpSemiperm}(ni+nr,nr)$\;
   $invs' \leftarrow invs$, $newInvs' \leftarrow newInvs$, $rel' \leftarrow rel$\;

     \While{$S  \neq \emptyset$}
     {
       $L \leftarrow \mathsf{hd}(S )$\;
        $S  \leftarrow \mathsf{tl}(S )$\;
        $r \leftarrow \mathsf{apply}(pr,L)$\;
        $(invOpt,relItem) \leftarrow  \mathsf{InvSearch}(chk,tauto,r,cinv,invs')$\;
      $rel' \leftarrow rel'@[relItem]$\;
       \If{$invOpt \neq NONE$}
        {$newInv \leftarrow \mathsf{getReal}(\mathsf{fst}(result)) $\;
        $invs' \leftarrow invs'@[newInv]$\;
         $newInvs' \leftarrow newInvs'@[newInv]$\;
        }
     }
    \Return $invs', newInvs'$  and  $rel'$
}



\end{algorithm}

Input formula set $invs$ and $newInvs$, a relation set $rel$ are the invariant formula set, and new invariant formula set and causal relation computed up to now. The meaning of ``new" is that a formula in $newInvs$ has not been used to search new invariants yet. The generated groups of parameters are stored in $S$, and are repeatedly  used to instantiate $pr$ into a rule $r$, and to search new invariants and causal relation items by calling $\mathsf{InvSearch}$.  The searched new invariant formulas are added into $invs'$ and $newInvs'$; new relation items $rel'$.



\begin{algorithm}{alg:topInvFinder}

\caption{top level algorithm of invFinder: invFinder}\label{alg:parameterInstantiate}

\KwIn{parameterized rule set $PR$,   a formula set $invs$  }

\KwOut{  a formula set $invs'$, a relation set $rel'$ }

{ % $ni\leftarrow \mathsf{aPNumOfInv}(cinv) $\;
  % $nr \leftarrow \mathsf{fpNumOfRule}(pr)$\;

  % $S \leftarrow \mathsf{cmpSemiperm}(ni+nr,nr)$\;
    $invs' \leftarrow invs$, $newInvs' \leftarrow invs$, $rel' \leftarrow \emptyset$\;

     \While{$newInvs'  \neq \emptyset$}
     { $cinv \leftarrow hd(newInvs')$\;
       $newInvs' \leftarrow tl(newInvs')$\;
       $PR' \leftarrow PR$\;
       \While{$PR'  \neq \emptyset$}
       {
        $pr\leftarrow \mathsf{hd}(PR' )$\;
        $PR'  \leftarrow \mathsf{tl}(PR' )$\;
        $(invs',newinvs',rel') \leftarrow  \mathsf{InvFinder-II}$($pr$,    $cinv$,   $invs'$, $newInvs'$,$rel')$\;
       }

     }
    \Return $invs'$,  and  $rel'$
}



\end{algorithm}

For a parameterized rule set $PR$ of a protocol, and a set of invariant set $invs$ under verification, the top level of algorithm {\sf invFinder} is outlined in Algorithm \ref{alg:topInvFinder}. $invs'$ and $newInvs'$ are initialized by $invs$, and $rel'$ by $\emptyset$. There are two level of loops in {\sf invFinder}. Head element of $newInvs'$ is pushed into a new invariant $cinv$, and head of $PR$ into $pr'$, then $\mathsf{InvFinder-II}$ is iteratively called to compute new invariant formulas and relation items. This searching procedure is not finished until no new invariant is searched.


For instance, let $PR=\{try, crit, exit, idel\}$, $invs=\{mutualInv(1,2)\}$,    {\sf invFinder} is called to compute invariant formulas and causal relations.  The output of the {\sf invFinder} is shown in Table \ref{label-ground-causal relation}. In the table,  each row records the  index of a normalized   invariant, name of a parameterized rule, the rule
  parameters to instantiate the rule, a causal relation between
  the ground invariant and a kind of causal relation which involves the kind and proper formulas
  $f'$   in need (which are used to construct
      causal relations $\mathsf{invHoldRule}_3$). The auxiliary invariants found by {\sf invFinder} includes: $\mathsf{inv_2}  \equiv  \negc (\mathsf{x} \eqc true  \andc  n[1]=C)$, $\mathsf{inv_3}    \equiv \negc  ( n[1]=C \andc n[2]=E)$,
$\mathsf{inv_4}  \equiv  \negc (x \eqc \mathsf{true}  \andc  n[1]\eqc \mathsf{E})$,   $\mathsf{inv_5}    \equiv \negc  ( n[1]\eqc \mathsf{C} \andc n[2] \eqc \mathsf{C})$.



 \begin{table}[!t]\label{table:ground-causal relation}
\centering \caption{A fragment of output of {\sf invFinder}} % {\tt
%simpMutual.tbl}
\begin{tabular}{|c|c|c|c|c|  }
\hline
  rule& ruleParas&inv&causal relation &   f'  \\
\hline
  .. & ..&.. &..&.. \\

\hline
  crit  & [1]&mutualInv(1,2)& invHoldRule3 &invOnXC(2) \\
\hline
  crit &[2]& mutualInv(1,2)& invHoldRule3 &invOnXC(1)  \\
\hline
  crit & [3]& mutualInv(1,2) & invHoldRule2  & \\
\hline
  .. & ..&.. &..&.. \\

\hline
  crit  & [1]&invOnX$_1$(1) & invHoldRule1 &\_ \\
\hline
  crit &[2]& invOnX$_1$(1) & invHoldRule1 &\_  \\
\hline
\end{tabular}
\end{table}




\section{Generalization}
%From this section, our modelling language has been extended to HOL (Higher-order Logic) provided by Isabelle, which not only include the language in Section \ref{sec:protocolSyntax}, but also higher-order logic features. This is not surprising because our formal theory for a parameterized instance of a protocol is done in HOL/Isabelle.  In order to include the theory formally in section \ref{sec:protocolSyntax} and \ref{sec:causal_rel}, we define a Isabelle theory {\tt cache.thy}.

Intuitively, generalization means that a concrete index (formula or rule) is generalized into a set of concrete indice (formulas or rules), which can be formalized  by a symbolic index (formula or rules) with side conditions  specified by the constraint formulas. There are two
main kinds generalization in our work: (1) generalization on model constraints; (2) generalization to instantiation parameters for generation of case-splittings in the proofs, e.g., $iR_1 = \iInv_1$ or $iR_1 = \iInv_2$  stand for case splitting by comparing  a symbolic rule parameter $iR_1$ and invariant parameters $\iInv_1$ and $\iInv_2$. These formulas should be formalized in HOL.    In order to do this, we  adopt a symbolic value $\mathsf{symb}(str)$, where $str$ is   a special identifier. In this work, we use  special symbolic values $\mathtt{\iInv_i}$  to denote parameters of an parameterized   formula,  and $\mathtt{\iR_i}$ parameters of an parameterized rule, and $\mathtt{N}$   size of an parameterized protocol instance. Generalization in (1) is rather straightforward, and is put in the appendix; here we focus on (2).


\begin{definition}
Let $LR$ be a permutation s.t. $|LR|>0$, which represents a list of actual parameters to instantiate a rule,    let $LI$  be an identical permutation $|LI|>0$,  which  represents a list of actual parameters to instantiate a normalized invariant, we define:
\begin{enumerate}
\item symbolic comparation  between $LR_i$ and $LI_j$: \\
\begin{numcases}{symbCmp(LR,LI,i,j)\equiv }
 \mathtt{\iR_i} = \mathtt{\iInv_j} &    $equality(LR,LI,i,j)$\\
\mathtt{\iR_i} \ne \mathtt{\iInv_j} , & otherwise
\end{numcases}
%$symbCmp(LR,LI,i,j)\equiv$ if $equality(LR,LI,i,j)$ then $\mathtt{\iR_i} = \mathtt{\iInv_j}$ else $ (\mathtt{\iR_i} \ne \mathtt{\iInv_j})$

\item symbolic case on a parameter $i$ between $LR_i$ and $LI$ :\\
\begin{numcases}{ symbcaseI(LR,LI,i)\equiv }
   symbCmp(LR,LI,i,j)& $\exists! j.  equality(LR,LI,i,j)$\\
   forallForm(|LI|,pf)& otherwise
 \end{numcases}
 where  $pf(j)= symbCmp(LR,LI,i,j)$, and $\exists!j.P$ is an qualifier meaning that  there exists a unique $j$ s.t. property $P$.

\item symbolic case  between $LR$ and $LI$ : $symbcaseI(LR,LI )\equiv forallForm(|LR|,pf)$, where $pf(i)= symbcaseI(LR,LI,i )$

\item symbolic partition decided by a $LRS$ and $LI$, where $LRS$ is a set of permutations with the same length: $partition(LRS,LI) \equiv existsForm(|LRS|,pf)$,  where $pf(i)= symbcase(LRS_i,LI)$

\end{enumerate}
\end{definition}

$symbCmp(LR,LI,i,j)$ defines a symbolic formula according to the condition $equality(LR,LI,i,j)$, which represents the semantics of the equality between $LR_i$ and $LI_j$; $symbCmp(LR,LI,i)$  a symbolic formula equality matching conditions between $LR_{[i]}$  and all $LI_{[j]}$ such that $j \le |LI|$; $symbcaseI(LR,LI )$ a subcase decided by all $LR_{[i]}$  and all $LI_{[j]}$; $partition(LRS,LI)$  is a disjunction of subcases $symbcase(LRS_{[i]},LI )$.  Recall the examples in the previous section:
\begin{itemize}
\item when   $LI=[1]$ is a list of parameters occuring in $invOnXC(1)$
\begin{itemize}
  \item $LR=[1]$ is the actual parameter list to instantiate $crit$, $symbCmp(LR,LI,1,1)=(\mathtt{\iR_1} = \mathtt{\iInv_1})$, $symbcase(LR,LI)=symbcaseI(LR,LI,1)=(\mathtt{\iR_1} = \mathtt{\iInv_1})$.

  \item  $LR=[2]$ is the actual parameter list to instantiate $crit$, $symbCmp(LR,LI,1,1)= (\mathtt{\iR_1} \ne \mathtt{\iInv_1})$, $symbcase(LR,LI)=symbcase(LR,LI,1)=(\mathtt{\iR_1} \ne \mathtt{\iInv_1})$

   \item let $LRS=[[1],[2]]$, $partition(LRS,LI)= (\mathtt{\iR_1} = \mathtt{\iInv_1}) \vee  (\mathtt{\iR_1} \ne \mathtt{\iInv_1})$
\end{itemize}
\item when   $LI=[1,2]$ is a list of parameters occuring in $mutualEx(1,2)$
\begin{itemize}

  \item $LR=[1]$ is the actual parameter list to instantiate $crit$, $symbCmp(LR,LI,1,1)=(\mathtt{\iR_1} = \mathtt{\iInv_1})$, $symbcase(LR,LI,1)=(\mathtt{\iR_1} = \mathtt{\iInv_1})$.

  \item  $LR=[2]$ is the actual parameter list to instantiate $crit$, $symbCmp(LR,LI,1,1)= (\mathtt{\iR_1} \ne \mathtt{\iInv_1})$, $symbcase(LR,LI)=(\mathtt{\iR_1} = \mathtt{\iInv_2})$ becasue $LR_{[1]}=LI_{[2]}$.


 \item  $LR=[3]$ is the actual parameter list to instantiate $crit$, $symbCmp(LR,LI,1,1)=\neg(\mathtt{\iR_1} = \mathtt{\iInv_1})$, $symbcase(LR,LI)=symbcaseI(LR,LI,1)= (\mathtt{\iR_1} \ne \mathtt{\iInv_1}) \wedge  (\mathtt{\iR_1} \ne \mathtt{\iInv_2})$ because neither $LR_{[1]}=LI_{[1]}$ nor $LR_{[1]}=LI_{[2]}$.

  \item let $LRS=[[1],[2],[3]]$, $partition(LRS,LI)= (\mathtt{\iR_1} = \mathtt{\iInv_1}) \vee (\mathtt{\iR_1} = \mathtt{\iInv_2}) \vee ( (\mathtt{\iR_1} \ne \mathtt{\iInv_1}) \wedge  (\mathtt{\iR_1} \ne \mathtt{\iInv_2}))$
\end{itemize}
\end{itemize}

Note that $partition(LRS,LI)$ is a complete partition if it is a tautology. In the above example, the two partitions are both complete.

If we see a line as a concrete test case for some concrete causal relation in table \ref{table:groundCausalRelation},  then $symbcase(LR, ID)$ is an abstraction predicate to generalize the concrete case, where $LR$ and $ID$ are the concrete rule and invariant parameters in the line. %If another $LR'$ and $LI'$ are permutations s.t.  $symbcase(LR', LI')$, then the same kind of causal relation  should hold, thus we can apply the same proof tactics to prove.
The last thing is how to transform the formula $f'$ in a line of table \ref{table:groundCausalRelation} where the causal relation $\mathsf{invHoldRule_3}$ holds. An index occuring in $f'$ can   occur in the invariant formula, or in the rule. We need look up the parameters occurring in the formula  or in the rule to determine the   transformation.

\begin{definition}
Let $LI$ and $LR$ are two permutations,\\
$lookup(LI,LR, i)\equiv$
 if $i\in LI$ then $\iInv_{find\_first(LI,i)}$ else $iR_{find\_first(LR,i) }$\\
$symbolize'(f,LI,LR)$ is a formula transformed from $f$ by substituting each $i$ with $lookup(LI,LR, i)$.
\end{definition}

For instance, let $LI=[1,2]$, $LR=[2]$, then $symbolize'(invOnXC(2),LI,LR)$ is $\neg(x\eqc true \wedge n[\iInv_2]\eqc C)$. %Let $LI=[1]$, $LR=[1,2]$, then $symbolize'(mutualInv(1,2),LI,LR)$ is $\neg(n[\iInv_1]\eqc C \wedge n[\iR_2]\eqc C)$. Here the latter exmple is only  artificial because there is no rule which will be instantiated by $[1,2]$. But for complex protocols like FLASH, the case exits where a rule with two parameters and an invariant with only a parameter exits.
For convenience in generating Isabelle proofs,      %a formula $\mathsf{diffConGen}~(\mathsf{paraMumsOfInv}~cr~"iR"$ to specify with the assumptions that mutual difference between the parameters of the symbolic invariant.  Here we assume that the string $"iR"$ does not occur in $cr$.
 A table $symbCausalTab$ is generated, which  stores causal relation between a parameterized rule and an  invariant w.r.t. a  size $N$. An entry of the table is referenced by concatation of the name of a rule and an invariant formula. Such an entry is a record containing fields {\tt symbCases} and  {\tt relationItems}, and created by collecting all the lines on the concrete relation items between the rule and the invariant. {\tt symbCases}  stores the list of symbolic cases each of which is derived by $\mathtt{symbcase}(LR, 1~\mathsf{upto}~n)$, where $LR$ is the rule parameters, and $n$ the number of parameters occuring in the invariant. relations store a list of generalized causal relation items.  For instance, for the rule $crit$ and $inv5$, a record $(|\mathtt{symbcases}=[\mathtt{\iR_1} = \mathtt{\iInv_1},\mathtt{\iR_1} = \mathtt{\iInv_2},(\mathtt{\iR_1} \ne \mathtt{\iInv_1}) \wedge  (\mathtt{\iR_1} \ne \mathtt{\iInv_2})]$; $\mathtt{relationItems}= [invHoldRule_3(f_1')$,$invHoldRule_3(f_2')$,$invHoldRule_2]|)$, where $f_1'=symbolize'([1,2],[1],invONXC(2))$, and $f_2'=symbolize'([1,2],[2],invONXC(1))$.

\end{document}

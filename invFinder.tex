\documentclass{llncs}
%%%%%%%%%%%%%%%%%%%%%%
%%%%   PACKAGES   %%%%
%%%%%%%%%%%%%%%%%%%%%%
\usepackage{makeidx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{latexsym}
\usepackage{url}
\usepackage{color}
\usepackage{isabelle}
\usepackage{isabellesym}
\usepackage{theorem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%For Isabelle code
\newlength{\fminilength}
\newsavebox{\fminibox}
\newenvironment{fmini}[1][\linewidth]
  {\setlength{\fminilength}{#1\fboxsep-2\fboxrule}%
   \vspace{2ex}\noindent\begin{lrbox}{\fminibox}\begin{minipage}{\fminilength}%
   \mbox{ }\hfill\vspace{-2.5ex}}%
  {\end{minipage}\end{lrbox}\vspace{1ex}\hspace{0ex}%
   \framebox{\usebox{\fminibox}}}

\newenvironment{specification}
{\noindent\scriptsize \tt\begin{fmini}\begin{tabbing}X\=X12345\=XXXX\=XXXX\=XXXX\=XXXX\=XXXX
\=\+\kill} {\end{tabbing}\normalfont\end{fmini}}
\def \twoSpaces {\ \ }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%for comments
\newcommand\JP[1]{\textcolor{magenta}{JP: #1}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Additional math operators
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[colorlinks,
            linkcolor=black,
            anchorcolor=black,
            citecolor=blue,
            urlcolor=black,
            bookmarks=true
            ]{hyperref}

\input{tcilatex}

%=========================================
\begin{document}

\title{ {\sf InvFinder}: An Invariant Finder for Parameterized Verification of Cache Coherence Protocols}
\titlerunning{InvFinder: An Invariant Finder}
\author{~}
\authorrunning{~}
\institute{~}

\maketitle

%-------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------
The crux of parameterized verification of cache coherence protocols is the construction of a set of auxiliary invariants.
 Our tool  {\sf InvFinder}  handles this hard problem
 and it is inspired by induction heuristics to originate auxiliary invariants from a small reference instance of the verified protocol.
 The invariants and the corresponding information found by {\sf InvFinder}
 can be used to construct a formally parameterized proof in a theorem prover (e.g., Isabelle) to prove
 the correctness of the protocols. At last, a guided simulation flow of a single process can be provided
to the engineers, which is created with the aid of the auxiliary invariants to unveil intuitively the correctness of the protocol.
\JP{It is unclear why the guided simulation flow of a single process is a nice feature of the tool.}
\JP{After reading the paper, this guided simulation is never described.}

%-------------------------------------------------------------------------
\end{abstract}
%-------------------------------------------------------------------------

\JP{For a tool paper, HVC only allows 6 pages!!!!!}

%=========================================
\section{Introduction}
%=========================================
Verification of parameterized concurrent systems is
interesting in the area of formal methods,
mainly due to the practical importance of such systems.
Parameterized systems exist in many
important application areas: cache coherence protocols, security
systems, and network communication protocols,
\emph{etc}. In this work, we will focus on cache coherence
protocols. The challenge posed by
parameterized verification is that the desired properties should hold in any instance of the parameterized system. The core of parameterized verification is the construction of a set of auxiliary invariants~\cite{Pnueli2001,Chou2004,Pandav2005,cubicle2011},
which are either for inductive verification or abstraction model construction.
%Essentially, we believe that parameterized verification should be solved by theorem-proving,
%as
\JP{It is unclear what is the initial invariant and what are the correctness proofs.}
\JP{To make the concepts clear, it will be better to briefly describe the standard
procedure for parameterized verification.
Then you can talk about initial invariant, correctness proofs, auxiliary invariants, etc.
(Such terms are not explained so far in the current paper.)}

The aim of tool {\sf InvFinder} is to find auxiliary invariants from a protocol
instance with fixed size.
{\sf InvFinder} can be regarded as both a  prover and a finder.
\JP{I guess nobody has encountered either semi-prover or semi-finder before.}
Given an invariant $inv$ in an invariant set $invs$,
and a rule $r$ in a set of protocol rules $rs$,
{\sf InvFinder} works in a very simple way:  it tries to prove the
existence of some kind of casual relations between $r$ and $inv$,
then it tries to construct a new invariant $inv'$ and adds it into the invariant set $invs$
if the current proving step is blocked due to the ? of the invariants. At this time, it will analyze the form of rule and
 invariant, then create new invariants.
\JP{`fails'? why $inv'$ is an invariant if it fails?}
This searching procedure stops until no new invariants are created.
%The originality of {\sf InvFinder} lies in
% its essence of induction.
% \JP{What is essence of  induction?} Be
The orginality of our work lies the following aspects: (1)
{\sf InvFinder} is guided by heuristics inspired by a so-called principle of consistency lemma,
 which specifies several kinds of  casual relations which hold between  of a set of invariants with the transition rules the protocol instance; \cite{LPParamterProof} (2)
 Although the invariants are created from a finite protocol instance, they can be refined to either construct a completely formal proof   in a theorem prover(e.g., Isabelle) or an abstract model which fully models the behavior of a single client. Here we emphasize that either the proof and the abstract model
  can  account for any parameterized model of the protocol under study. The formal proofs and the abstract model with the interpretation of the invariants can be used as the formal documents of the analysis of the protocols.
\JP{Give a reference other to a paper or to some new section.}

%=========================================
\section{The Design Principle of {\sf InvFinder}}
%=========================================
Consider a set of state variables $V$,
$e$, $f$ and $S$ are an expression, a formula, and a statement over
the set of state variables $V$. A cache coherence protocol is formalized by a pair $(inis,rules)$,
where
%
\begin{itemize}
\item $inis $ is a set of initialization predicates;

\item $rules$ is a set of transition rules, each of which is defined as
  $g \vartriangleright  S$, where $g$ is a predicate, and $S$ is a
  parallel assignment to distinct  variables $v_i$ with expressions
  $e_i$.
\end{itemize}

A  state of a protocol $s$ is an instantaneous snapshot of its
behaviour given by a mapping from variables to their values. We
write $\mathsf{expEval}~e~s$ ($\mathsf{formEval}~e~s$) to denote the
evaluation of the expression $e$ (formula $f$) at the state $s$.
Consider a parallel assignment  $S=\{x_i:=e_i | i>0\}$, we define
$\mathsf{preCond}~S~f=f[x_i:=e_i]$.

Consider a protocol $(inis,rules)$, a natural
idea is to inductively define the reachable state set of a
parameterized protocol instance and to prove inductively a
property, in terms of an invariant $inv$, of the reachable state set.
However, it is usually too difficult to directly inductively prove the invariant under study.
We usually need to strengthen $inv$ into a stronger form:
$inv_1\wedge ...\wedge inv_n \wedge inv$.
How to figure out the set of auxiliary invariants ($inv_i$)
is always the central task of our tool {\sf InvFinder}.

Different from previous work, {\sf InvFinder} is centered with a
so-called consistency relation $\mathsf{consistent}~ invs ~inis~
rs$, is originated between a protocol $(inis,rs)$ and a set of
invariants $invs=\{inv_1,..., inv_n\}$. \JP{It is very confusing
here: our aim is to derive $inv_i$s. But here it seems that $inv_i$s
are given.} The consistency relation specifies two aspects: \JP{What
is `it'?}
%
\begin{itemize}
\item For any invariant $inv \in invs$,
any initializing predicate $ini \in inis$, any
state $s$, if $ini$ is evaluated true at state $s$, then $inv$ is
evaluated true at state $s$ as well.

\item For any invariant $inv \in invs$, any $r$ in rule set
$rs$, either $\mathsf{invHoldForRule1 }~inv~ r$,
$\mathsf{invHoldForRule2 }~inv~ r$, $\mathsf{invHoldForRule3 }~inv~
r~invs$, or $\mathsf{invHoldForRule4 }~inv~ r~invs$ holds, or
$\mathsf{invHoldForRule5}~inv~ r~invs$ holds. Formally, let $r=g
\vartriangleright  S$, $inv=ant \longrightarrow cons$, where $cons$
is simply atomic formulas such equivalence formulas, and $ant$ is a
conjunction of atomic formulas. $\mathsf{invHoldForRule1 }~inv~ r$
means that
 $\mathsf{preCond}~S~inv=true$; $\mathsf{invHoldForRule2 }~inv~ r$ that  $\mathsf{preCond}~S~inv=inv$; $\mathsf{invHoldForRule3 }~inv~ r~invs$
  that $\mathsf{preCond}~S~cons=cons$ and there exists an invariant $ant'$ such that
$(\mathsf{pre}~r )\wedge \mathsf{preCond}~S~ant \longrightarrow  ant'$ and $ant' \longrightarrow cons \in invs$; $\mathsf{invHoldForRule4}~inv~ r~invs$
  that$\mathsf{preCond}~S~ant=ant$, and there exists   antecedent $ant'$
such that $inv'=ant'' \longrightarrow \neg ant'$, $ant' \longrightarrow ant$, and
$(\mathsf{pre}~r )\wedge \neg \mathsf{preCond}~S~cons \longrightarrow  ant''$; $\mathsf{invHoldForRule5}~inv~ r~invs$ that
$\mathsf{preCond}~S~inv$ is also an invariant in the invariant set $invs$.
\end{itemize}

Suppose that the consistency relation $\mathsf{consistent}~ invs ~inis~ rs$ holds, then for any $inv$ such that $inv \in invs$, $inv$ holds for any reachable state $s$ such that $s  \in \mathsf{reachableSet}~ inis~ rs$.
\begin{theorem}\label{consistentLemma}
  $\isasymlbrakk \mathsf{consistent}~ invs ~inis~ rs$; $s  \in \mathsf{reachableSet}~ inis~ rs$
  $\isasymrbrakk\Longrightarrow$ $\forall inv. inv \in invs \longrightarrow
\mathsf{formEval}~ inv ~s$    \end{theorem}


In order to understand the causal relation
$\mathsf{invHoldForRule1}$-$\mathsf{invHoldForRule5}$,
\JP{Still they are not defined and explained.}
we must relate them to an induction proof method.
Consider an invariant of the form $inv=ant \longrightarrow cons$ in $invs$ and a rule $r\in rs$,
suppose with the induction hyposthesis (IH)  $\mathsf{formEval}~ inv'~ s $ for all $inv'\in invs$ (not only  $\mathsf{formEval}~ inv~ s $),
and $\mathsf{formEval}~(\mathsf{pre}~r)~ s$,
we need to show (1) $\mathsf{formEval}~ inv~ ((\mathsf{trans})~(\mathsf{act}~r)~s) $.
Roughly speaking, there are five kinds of proof case:
%
 \begin{enumerate}
 \item after rule $r$ is executed,
either the antecedent $ant$ is disabled or the consequent $cons$ is enabled
at the resulting state, thus (1) is proved immediately.
This  case is described by $\mathsf{invHoldForRule1 }~inv~ r$.

\item after rule $r$ is executed,
none of state variables in $inv$ is changed,
therefore by IH, we immediately prove (1).
This  case is described by $\mathsf{invHoldForRule2}~inv~ r$.

\item after rule $r$ is executed, none of state variables in $cons$ is changed,
we also can figure out another antecedent $ant'$
such that $inv'=ant' \longrightarrow cons$ and $inv' \in rs$,
$(\mathsf{pre}~r )\wedge \mathsf{preCond}~(\mathsf{act}~r)~ant \longrightarrow  ant'$.
This  case is described by $\mathsf{invHoldForRule3}~inv~r~rs$.
Note that $\mathsf{preCond}~(\mathsf{act}~r)~ant$ is the weakest pre-condition at state $s$
to make $ant$ true at the resulting state after $r$ is executed.

Essentially this case proves that $cons$ holds at the state $s$
assuming the conjunction of  $\mathsf{preCond}~(\mathsf{act}~r)~ant$ and guard condition of $r$ to be true.
From this and none of state variables in $cons$ is changed after the execution of $r$,
we can have that $cons$ also holds after the execution of $r$.

\item after rule $r$ is executed, none of state variables in $ant$ is changed,
we also can figure out another antecedents two $ant'$ and $ant''$ such that
$inv'=ant' \longrightarrow \neg ant''$,
$inv' \in rs$, $(\mathsf{pre}~r )\wedge \mathsf{preCond}~(\mathsf{act}~r)~(\neg cons) \longrightarrow   ant'$,
$ant''\longrightarrow ant$ (usually $ant$ is a conjunction of a list formulas and $ant''$ is one of the formulas).
This  case is described by $\mathsf{invHoldForRule4}~inv~r~rs$.

Essentially this tries to prove $\neg ant$
assuming $\neg cons$ at the resulting state $\mathsf{trans}~(\mathsf{act}~r)~s$.
Because $\neg cons$ holds at the state $\mathsf{trans}~(\mathsf{act}~r)~s$,
we have that $\mathsf{preCond}~(\mathsf{act}~r)~(\neg cons)$ holds at the state $s$.
With the guard of $r$: $\mathsf{pre}~r$, we can prove that $ant'$ holds at the state $s$.
Therefore, $\neg ant'$ holds, and $\neg ant$ holds at $s$.
Because none of state variables in $ant$ is changed,
we can conclude that $\neg ant$ holds at the resulting state $\mathsf{trans}~(\mathsf{act}~r)~s$.

\item the last one is that both state variables in $ant$ and $cons$ are changed,
and $\mathsf{preCond}~(\mathsf{act}~r)~inv$ is also an invariant in the invariant set $invs$.
By IH, we have that $\mathsf{preCond}~(\mathsf{act}~r)~inv$ holds at the state $s$.
Therefore $inv$ holds at the resulting state after $r$ is executed.

\end{enumerate}

The consistency lemma can be proved by induction.
\JP{`consistency lemma' is not explained and it is unclear why it can be proved by induction.}
It is the cornerstone in our framework.
\JP{No framework is mentioned before.}
It is \JP{heuristics????} inspired by the
consistency relation that guides the tool {\sf InvFinder} to
find the strengthened invariants,
which are used to prove the original invariant.
The tool \texttt{invFinder} works in an iteratively semi-proving and semi-searching workflow.
In an iterating step, it tries to prove some consistent relation exists between an invariant and a rule,
and automatically generates a new auxiliary invariant
if there is no such an invariant in the current invariant set,
and records the corresponding consistency information.
This workflow is not finished until no new counter example is created.
\JP{`counter-example' comes from nowhere!}

\JP{Basically, I stop here. So far, it is not a tool paper to me.
For a tool paper, the structure should be as follows:
(1) intro: the motivation, the problem, and the current approach,
(2) the tool itself: workflow and design, functionalities, modules, and algorithm (if you have) etc.,
(3) case studies and results,
(4) related tools (if any),
(5) future work and conclusions.}

\section{The Searching Algorithm of the {\sf invFinder}}
Note that the invariant set $invs$ which satisfies is need to be compute. That is to say, usually only one invariant $inv_1$ is  given, the remaining invariants such as $inv_i(i>1)$ are needed to find. It is the task that {\sf invFinder} constructs one of the remaining invariants by checking the causal relation between an invariant and a rule instance. The corresponding searching algorithm of the {\sf invFinder} is as follows:

\begin{specification}
1let findInvsFromRule choose chooses chk tautChk isNew paraRule paras inv newInvs invs casRel=\\
2\twoSpaces     let rule=ruleApp paraRule paras in\\
3\twoSpaces   val (guard g  S)=rule in\\
4\twoSpaces   val (implyForm ant cons)=inv in\\


5\twoSpaces   let inv'=preCond S inv in\\
6\twoSpaces   val (implyForm ant' cons')=inv' in\\


7\twoSpaces     inv=inv'=>\\

8\twoSpaces         let relItem=(paraRule, paras, inv, invHoldForRule2) in
         (newInvs, (relItem: casRel))\\



9\twoSpaces      | tautChk inv'\\
10\twoSpaces         =>(let relItem=(paraRule, paras, inv, invHoldForRule1) in         (newInvs, (relItem: casRel)   ))\\


11\twoSpaces       | cons=cons'=>\\

12\twoSpaces       let newAnt=  choose cons ((andList2Ands (g$\wedge$ant'))     then\\

13\twoSpaces       let inv'= (implyForm newAnt cons) in\\


14\twoSpaces       let relItem=(paraRule, paras, inv,  invHoldForRule3 inv'   ) in\\

15\twoSpaces       ((isNew inv' invs)=>           (newInvs@[inv'], relItem : casRel)\\
16\twoSpaces       |(newInvs,  relItem : casRel))\\

17\twoSpaces     | ant=ant' =>\\
18\twoSpaces        let antConjs= andList2Ands ant'  then\\

19\twoSpaces        val (newAntant, newCons) = chooses ((map $\neg$ antConjs) (andList2Ands (g$\wedge \neg$cons)) in\\
20\twoSpaces        let inv'=(implyForm newAntant newCons) in\\
21\twoSpaces        let relItem=(paraRule, paras, inv,  invHoldForRule4 inv'   ) in\\
22 \twoSpaces       ((isNew inv' invs)=>         (newInvs@[inv'], relItem : casRel)\\
23\twoSpaces       |(newInvs,  relItem : casRel))\\

24\twoSpaces   | chk inv'=>\\
25\twoSpaces      let relItem=(paraRule, paras, inv,  invHoldForRule5 inv'  ) in\\
26\twoSpaces        ((isNew inv' invs)=>        (newInvs@[inv'], relItem : casRel)\\
27\twoSpaces        |(newInvs,  relItem : casRel))\\
28\twoSpaces   | error "no new invariant";\\
\end{specification}

The above function {\sf findInvsFromRule} tries to find new invariants and construct the causal relation between the rule instance $r=paraRule~ para$ and
 the invariant $inv$. The statement { \tt cond => et|ef} is an abbreviation of the if-then-else expression that if $cond$ is true then $et$ else $ef$. Parameters  $newInvs$, $invs$, and  $casRel$ are new invariants,  $invariants$, and all the causal relations constructed up to now. The returned result is updated invariant sets, and causal relations.
 \begin{description}
 \item[(1)] After computing the pre-condition {\tt inv'=preCond~ S ~inv} in line 5, then  {\sf invFinder} do case analysis on $inv'$: if {\tt inv=inv'}, then no change made to $inv$ by statement $S$, the new causal relation item marked with tag {\tt invHoldForRule2} is recorded between $r$ and $inv$, but there is no new invariants to be added;
  \item[(2)]    Secondly, if {\tt tautChk inv'} is true, where {\tt tautChk} is a tautlogy checker for the formula $inv'$ which is implemented
  by an SMT solver, then  the new causal relation item marked with tag {\tt invHoldForRule1} is recorded between $r$ and $inv$,  there is no new invariants to be added too;

 \item[(3)]   Thirdly, if  {\tt cons=cons'}, then the function {\tt choose} in line 12 chooses the weakest precondition $newAnt$ from the conjunctals of
 $g \wedge \neg  ant'$. {\tt andList2Ands} destructs a conjunction into a list of atomic formulas, which are equivalence formulas or negation of equivalence formulas, an   invariant $inv'=newAnt \longrightarrow cons$, which is checked to hold at any state of the finite reference protocol model,  is generated, and function {\tt isNew} is used to check whether the invariant is new. If thus, the invariant is  added into $newInvs$, and the new causal relation item marked with tag {\tt invHoldForRule3 inv'} will be added into the cuasal relation.
     Here Here we must point the meaning of the word "new" is modulo to the symmetry relation. The intuitive meaning of the symmetry relation is that $\mathsf{mutualInv}~1~2$ is equivalent to $\mathsf{mutualInv}~2~1$. Namely, $\mathsf{mutualInv}~1~2$  is only one representive of the formula set $\{f. \exists i~j \le 3.f=i\neq j \wedge cache[i]=exclusive\longrightarrow cache[j]=invalid \}$.

  \item[(4)]    Fourthly, if if  {\tt ant=ant'}, then the function {\tt chooses} in line 19 chooses the weakest precondition $newAnt$ from the conjunctals of
   $g \wedge \neg  cons'$, and proper  $newCons$ from the negation of all the conjunctals of $ant$, namely, it holds that $newCons \longrightarrow \neg ant$,
   and the invariant  $inv'=newAnt \longrightarrow newCons$, which is checked to  at any state of the finite reference protocol model,  is also generated.
   If the invariant $newAnt \longrightarrow newCons$ is new, then it will be added into $newInvs$ if thus.
   A new causal relation item marked with tag {\tt invHoldForRule4 inv'} will be added into the causal
   relation. Recall that $ant$ may be a conjunction of atomic
   formulas, one of which being falsified means that $ant$ will be
   falsified.

    \item[(5)] Otherwise, $inv'$ will be checked whether it is an invariant holding at each state of the finite reference model. If thus, it
    will be checked whether it is new. $newInv$ will be updated
    accordingly. At last, a causal item marked with {\tt invHoldForRule5
    inv'} will be added into $casRel$.
 \end{description}
 %=========================================
\section{An Illustrating Example}
%=========================================
We use a moderate-size example to illustrate our tool: the German protocol, a
directory-based protocol which was proposed as a challenge to the
formal verification community by Steven German in 2000. An informal description of this protocol in
Murphi language and its complete model in {\sf invFinder} can be found in~\cite{}.

\JP{It is better not to explain the protocol and not to give the code.}

\begin{specification}
//1. constant declarations for the control signals\\
 let emptyC= 4; let grant\_shared=5; let grant\_exclusive=6;\\
......\\
//2. type definitions for control signals\\
let channel1Type=[emptyCh1, req\_shared, req\_exclusive];\\

let channel2\_4Type=[emptyCh2\_4,invalidate, grant\_shared,
grant\_exclusive];\\
......\\
//3. rule definitions  \

let sharer\_invalidates\_cache i=\\
    let form1= (eqn (left -> (Var (Param "channel2\_4" i)))  (right ->(Const invalidate))) in\\
    let form2= (eqn (left -> (Var (Param "channel3" i)))  (right ->(Const emptyC))) in\\
    let form=andList [form1,form2] in\\
    let assgn1=(assign (  (Param "channel2\_4" i)) ( (Const emptyC))) in\\
    let assgn2=(assign (  (Param "channel3" i)) ( (Const invalidate\_ack))) in\\
    let assgn3=(assign  (  (Param "cache" i)) ( (Const invalid))) in\\
    guard form ( parallel [assgn1, assgn2, assgn3]);\\

let client\_receives\_exclusive\_grant i=\\
    let form1= (eqn (left -> (Var (Param "channel2\_4" i)))  (right ->(Const grant\_exclusive))) in\\
    let assgn1=(assign  (  (Param "channel2\_4" i)) ( (Const emptyC))) in\\
    let assgn2=(assign  (  (Param "cache" i)) ( (Const exclusive))) in\\
    guard form1 ( parallel [assgn1, assgn2]);\\
......\\
let rules=[......,  sharer\_invalidates\_cache ,......,client\_receives\_exclusive\_grant  ];\\
//4.invariant definitions......\\
let mutualInv=
   let form1= eqn  (Var (Param "cache" i1)) (Const exclusive) then\\
  let form2= eqn  (Var (Param "cache" i2)) (Const invalid) then\\
  implyForm form1 form2 ;\\

  findInvsFromParaRulesByInvs  typeTable [1,2,3] "cache" "german" enumValTab [mutualInv] rules  [] [];
 \end{specification}


In order to verify the invariant $mutualEx$,  we use
{\sf invFinder} to find auxiliary invariants of a small
protocol instance of size $3$. The script \JP{which script?} contains three parts:
(1) constant declarations for the control signals used in the
protocol such as {\tt req\_shared}, and actual parameters such as
{\tt paras}; (2) parameterized rules of the protocol such as {\tt
client\_receives\_exclusive\_grant}; (3) initial state definitions
{\tt  iniStatement ~N}; (4) the definition of mutual exclusion
property. At last, we call the function{\tt
findInvsFromParaRulesByInvs} to return a pair $(invs,calRel)$, where
the former is the auxiliary invariant sets plus the main invariant,
and the latter is the causal relation between each rule and
invariant.

We illustrate how {\sf invFinder} works by checking the consistency relation between
an invariant $inv=ant \longrightarrow cons$ and some rule in an iterative step.
Here, we will select the invariant $mutualEx$ and some rule instance.
%
\begin{description}
\item[(1)]   First, {\sf invFinder} tries to prove the consequent $cons$ holds or the
antecedent $ant$ is false after the rule $r$ is triggered.
%, and some state variables in the invarint is   changed by the action of the rule.
    For instance, for the rule $r=\mathsf{sharer\_invalidates\_cache}~ 2$,
    the invariant $inv=cache[1] = exclusive \longrightarrow  cache[2] =invalid$,
    the conclusion of $inv$ holds after the assignment. Therefore for the rule, and the invariant $r$, the induction proof step can be  finished immediately.
    On the other side, for the rule $r=\mathsf{sharer\_invalidates\_cache}~1$, the antecedent of the invariant is falsified immediately, thus the induction
    proof step can also  be  finished immediately. The causal
    relation $\mathsf{invHoldForRule1}~inv~r$ is also recorded in a
    table $causalTab$ by {\sf invFinder}.
%rule "sharer invalidates cache"
%      $channel2_4[cl] = invalidate \& channel3[cl] = empty ==>$
%      begin
%       channel2_4[cl] := empty;
%       channel3[cl] := invalidate_ack;
%       cache[cl] := invalid;
%      end;

\item[(2)]  Or it try to check that none of the variables in the invariant is changed by the action of $r$.
For the rule $r=\mathsf{sharer\_invalidates\_cache}~ 3$, no
variables of the invariant $inv$ will be changed. Therefore, simply
by IH, the invariant holds at the resulting state
after the triggering of the rule. The causal
    relation $\mathsf{invHoldForRule2}~inv~r$ is also recorded in a
    table $causalTab$ by {\sf invFinder}.

%Unfortunately, the tool {\sf InvFinder} cann't always use the two above cases to prove the invariant holds w.r.t. a rule by induction. For instance, for %the rule $r=\mathsf{client\_receives\_exclusive\_grant~ 1}$, the invariant $inv=cache[1] = exclusive \longrightarrow  cache[2] =invalid$, neither the %antecedent can be falsified nor the consequent of the invariant holds after the triggering of the rule. At this time, {\sf InvFinder} will try to %construct another invariant, which combines the guard condition of rule will guaranttee that $inv$ holds after the triggering of the rule $r$. Here %{\sf InvFinder} will try to use hints from the current proof state:

\item[(3)] if the antecedent   $ant$ holds after the triggering and the variables of the consequent   $cons$ does not change in the statements of the rule,
then it  will select some (usually one) condition $ant'$ from the
guard of the rule, and construct $inv'=ant' \longrightarrow cons$.
For instance, for the rule
$r=\mathsf{client\_receives\_exclusive\_grant~ 1}$, the invariant
$inv=cache[1] = exclusive \longrightarrow  cache[2] =invalid$,
neither the antecedent can be falsified nor the consequent of the
invariant holds after the triggering of the rule. At this time,
{\sf invFinder} will construct a new antecedent $ant'=channel2
[1] = grant\_exclusive$. {\sf invFinder} firstly verify that
$inv'$ is also an invariant holds at all the states of the small
protocol instance. Secondly, {\sf InvFinder} will check that
whether $inv'$ has been in the current invariant sets, if not, then
adds it into the invariant sets; otherwise do nothing. Now $inv$
regard that it finish the current induction proof step. The causal
    relation $\mathsf{invHoldForRule3}~inv~r~invs$ is   recorded in  the
    table $causalTab$.

\item[(4)] if the consequent of $inv$ is falsefied after the triggerring and the variables of the antecedent of $inv$ does not change in the statements of the
rule, then it  will select some (usually one) condition $ant'$ from
the guard of the rule, and construct $inv'=ant' \longrightarrow \neg
ant$. For instance, for the rule $r=\mathsf{client\_ receives\_
exclusive\_ grant}~ 2$, the the consequent of the invariant $inv$ is
falsified after the execution of the statement of the rule. Now
{\sf InvFinder} will select $channel2\_4[2] = grant_exclusive$
as $ant'$ from the guard of the rule, and construct a new invariant
$inv'=ant' \longrightarrow \neg ant$. {\sf InvFinder} firstly
verify that $inv'$ is also an invariant holds at all the states of
the small protocol instance. Secondly, {\sf InvFinder} will
check that whether $inv'$ has been in the current invariant sets, if
not, then adds it into the invariant sets; otherwise do nothing. Now
$inv$ regard that it finish the current induction proof step. The
causal
    relation $\mathsf{invHoldForRule4}~inv~r~invs$ is   recorded in  the
    table $causalTab$.

\item[(5)] otherwise,  {\sf InvFinder} will directly generate  $\mathsf{preCond}~inv~S$,
and simplify it by removing some useless antecedents of it. For instance,
for the rule $r=home\_ picks\_new\_request2$, the invariant
 $inv= home\_exclusive\_granted  \wedge  home\_invalidate\_list[1] \longrightarrow \neg
 home\_invalidate\_list[2]$.
 {\sf InvFinder} cann't use any the former   patterns to derive any new invariants.
 Instead it will compute $\mathsf{preCond}~inv~S=home\_exclusive\_granted  \wedge  home\_sharer\_list[1]
    \longrightarrow  \neg home\_sharer\_list[2]$
  as a new invariant, where $S$ is the statement of the rule $r$. Similarly this formula must be verified
  through the small protocol instance
   before it is added into the current invariant sets. The
causal
    relation $\mathsf{invHoldForRule5}~inv~r~invs$ is   recorded in  the
    table $causalTab$.

\end{description}

Here we emphasize some points:
The first is to rely
heuristics to guest new auxiliary invariant when we try to use
consistency lemma to verify the causal relation between a rule
instance and an invariant, which has been discovered up to now; The
second is to use a small protocol instance to briefly verify our
conjecture; The third is to use the symmetry property of the
protocol to generalize our invariants found in the small protocol
instance.
\begin{itemize}
\item The heuristics of originating new auxiliary invariant $inv'$ is inspired by creating invariants that satisfies one of the causal relation
  $\mathsf{invHoldForRule3}-$ $\mathsf{invHoldForRule5}$.


\item In order to guarantee a conjectured formula to be an invariant in (3) - (5), the reachable
 set of the  small protocol instance in external tools (e.g., Murphi or SMV) will be referenced by many times to check the conjectured  formula. Only a formula is checked to be an invariant by the external tool, it will be added into the invariant set.

\item Not only invariants are created, but also all the causal relations
between all invariants   and all rules are recorded, and kept in
$causalTab$. Both theses invariants and causal relations will be
used by $\mathsf{proofGen}$.

\item The invariant generation procedure will not stop until no new invariants can not be created again. Here we must point the meaning of the word "new" is modulo to the symmetry relation. The intuitive meaning of the symmetry relation is that $\mathsf{mutualInv}~1~2$ is equivalent to $\mathsf{mutualInv}~2~1$. Namely, $\mathsf{mutualInv}~1~2$  is only one representive of the formula set $\{f. \exists i~j \le 3.f=i\neq j \wedge cache[i]=exclusive\longrightarrow cache[j]=invalid \}$.

\item An SMT solver (e.g., z3) is called to  check whether a formula is a tautology,  which is crated in (1) or the equivalence checking   between the newly generated invariant and  an old invariant.

\end{itemize}

%=========================================
\section{Applications of Auxiliary Invariant Sets}
%=========================================

German protocol is a moderate case. In order to prove  the main mutual exclusion
property $\mathsf{mutualInv}~1~2$, {\sf InvFinder} generates  another 47 auxiarly invariants, which is listed in Table \ref{tab:foundInvs}. Being different from previous work, our work makes the auxiliary invariants to be visible. That is to say, we can use these invariant to illustrate the correctness of the protocol. Rougly speaking, $\mathsf{mutualInv}~1~2$ holds because (1) $\lnot home\_sharer\_list[1]\longrightarrow \lnot cache[1]=exclusive$, (2) $home\_sharer\_list[1]\wedge home\_exclusive\_granted
\longrightarrow \lnot home\_sharer\_list[2]$; (3) $\lnot home\_sharer\_list[1]\longrightarrow   cache[1]=invalid$; and (4) $\lnot home\_exclusive\_granted\longrightarrow \lnot cache[1]=exclusive$. (1) and (4) says that $cache[1]$ being $ exclusive$ must follow $home\_sharer\_list[1]$ and $home\_exclusive\_granted$ being true; and (3) $cache[1]$ being $ exclusive$ must follow $home\_sharer\_list[1]$ being true. (2) is the real mutual property, which says that $home\_sharer\_list[1]$ and $ home\_exclusive\_granted$ being true guarantee that $home\_sharer\_list[2]$ being false. Obviously, $\mathsf{mutualInv}~1~2$ is a more complex invariant, which can boil down to (1)-(4). Among them, (2) is the simplest one because it can be directly proved by induction without any other auxiliary invariants. Any one of the others must be proved with the aid of some other auxiliary invariants.
\begin{table}
\label{tab:foundInvs} \caption{Ground Invariant set $gInvs$ found by
{\sf InvFinder}}
 {\scriptsize
\begin{tabular}{|l|}
invariant \\ \hline $\left.
\begin{array}{l}
home\_sharer\_list[1]\wedge home\_exclusive\_granted \\
\longrightarrow \lnot home\_sharer\_list[2]%
\end{array}%
\right. $ \\
\\ \hline
$\left.
\begin{array}{l}
home\_invalidate\_list[1]\wedge home\_exclusive\_granted \\
\longrightarrow \lnot home\_invalidate\_list[2]%
\end{array}%
\right. $ \\
\\ \hline
$\left.
\begin{array}{l}
(channel2[1]=invalidate)\wedge home\_exclusive\_granted \\
\longrightarrow \lnot home\_invalidate\_list[2]%
\end{array}%
\right. $ \\ \hline $\left.
\begin{array}{l}
home\_exclusive\_granted\wedge home\_invalidate\_list[1] \\
\longrightarrow \lnot (channel2[2]=invalidate)%
\end{array}%
\right. $ \\ \hline $\left.
\begin{array}{l}
home\_invalidate\_list[1]\wedge home\_exclusive\_granted \\
\longrightarrow \lnot channel2[2]=invalidate%
\end{array}%
\right. $ \\ \hline
$channel2[1]=invalidate\longrightarrow \lnot home\_invalidate\_list[1]$ \\
\hline $\left.
\begin{array}{l}
channel3[1]=invalidate\_ack\wedge home\_exclusive\_granted \\
\longrightarrow \lnot home\_invalidate\_list[2]%
\end{array}%
\right. $ \\ \hline $\left.
\begin{array}{l}
home\_exclusive\_granted\wedge home\_invalidate\_list[1] \\
\longrightarrow \lnot channel3[2]=invalidate\_ack%
\end{array}%
\right. $ \\ \hline $\left.
\begin{array}{l}
channel2[1]=invalidate\wedge home\_exclusive\_granted \\
\longrightarrow \lnot channel2[2]=invalidate%
\end{array}%
\right. $ \\ \hline $\left.
\begin{array}{l}
home\_invalidate\_list[1]\wedge home\_exclusive\_granted \\
\longrightarrow \lnot (channel3[2]=invalidate\_ack)%
\end{array}%
\right. $ \\ \hline $channel3[1]=invalidate\_ack\longrightarrow
\lnot home\_invalidate\_list[1]$
\\ \hline
$\left.
\begin{array}{l}
channel3[1]=invalidate\_ack\wedge home\_exclusive\_granted \\
\longrightarrow \lnot channel2[2]=invalidate%
\end{array}%
\right. $ \\ \hline $\left.
\begin{array}{l}
channel2[1]=invalidate\wedge home\_exclusive\_granted \\
\longrightarrow \lnot channel3[2]=invalidate\_ack%
\end{array}%
\right. $ \\ \hline $channel2[1]=invalidate\longrightarrow \lnot
home\_current\_command=empty$
\\ \hline
$channel3[1]=invalidate\_ack\longrightarrow \lnot channel2[1]=invalidate$ \\
\hline $\lnot home\_sharer\_list[1]\longrightarrow \lnot
home\_invalidate\_list[1]$
\\ \hline
$channel2[1]=grant\_exclusive\longrightarrow \lnot home\_sharer\_list[2]$ \\
\hline $\left.
\begin{array}{l}
(\lnot home\_exclusive\_granted\wedge  \\
home\_current\_command=req\_shared) \\
\longrightarrow \lnot channel2[1]=invalidate%
\end{array}%
\right. $ \\ \hline $\left.
\begin{array}{l}
channel3[1]=invalidate\_ack\wedge home\_exclusive\_granted \\
\longrightarrow \lnot channel3[2]=invalidate\_ack%
\end{array}%
\right. $ \\ \hline $\left.
\begin{array}{c}
home\_current\_command=empty \\
\longrightarrow \lnot channel3[1]=invalidate\_ack%
\end{array}%
\right. $ \\ \hline
$\lnot home\_sharer\_list[1]\longrightarrow \lnot channel2[1]=invalidate$ \\
\hline $channel2[1]=grant\_exclusive\longrightarrow \lnot
home\_invalidate\_list[2]$
\\ \hline
$home\_sharer\_list[1]\longrightarrow \lnot cache[2]=exclusive$ \\
\hline $\left.
\begin{array}{l}
(\lnot home\_exclusive\_granted\wedge  \\
home\_current\_command=req\_shared) \\
\longrightarrow \lnot channel3[1]=invalidate\_ack%
\end{array}%
\right. $ \\ \hline $\lnot home\_sharer\_list[1]\longrightarrow
\lnot channel3[1]=invalidate\_ack $ \\ \hline
$channel2[1]=grant\_exclusive\longrightarrow \lnot
channel2[2]=invalidate$
\\ \hline
$channel3[1]=invalidate\_ack\longrightarrow \lnot
channel2[1]=grant\_shared$
\\ \hline
$channel2[1]=grant\_exclusive\longrightarrow \lnot
channel3[1]=invalidate\_ack$ \\ \hline
$channel2[1]=grant\_exclusive\longrightarrow \lnot
channel3[2]=invalidate\_ack$ \\ \hline
$channel2[1]=invalidate\longrightarrow \lnot cache[2]=exclusive$ \\
\hline $channel2[1]=grant\_exclusive\longrightarrow
home\_sharer\_list[1]$ \\ \hline
$channel3[1]=invalidate\_ack\longrightarrow cache[1]=invalid$ \\
\hline $home\_sharer\_list[1]=false\longrightarrow \lnot
channel2[1]=grant\_shared$
\\ \hline
$channel2[1]=grant\_exclusive\longrightarrow home\_exclusive\_granted$ \\
\hline
$channel3[1]=invalidate\_ack\longrightarrow \lnot cache[1]=exclusive$ \\
\hline
$channel3[1]=invalidate\_ack\longrightarrow \lnot cache[2]=exclusive$ \\
\hline
$\lnot home\_sharer\_list[1]\longrightarrow \lnot cache[1]=exclusive$ \\
\hline $channel2[1]=grant\_exclusive\longrightarrow \lnot
channel2[2]=grant\_exclusive$ \\ \hline $\lnot
home\_sharer\_list[1]\longrightarrow cache[1]=invalid$ \\ \hline
$channel2[1]=grant\_exclusive\longrightarrow \lnot
channel2[2]=grant\_shared$
\\ \hline
$\lnot home\_exclusive\_granted\longrightarrow \lnot cache[1]=exclusive$ \\
\hline
$channel2[1]=grant\_exclusive\longrightarrow \lnot cache[2]=exclusive$ \\
\hline $channel2[1]=grant\_exclusive\longrightarrow
cache[2]=invalid$ \\ \hline
$channel2[1]=grant\_shared\longrightarrow \lnot cache[2]=exclusive$
\\ \hline $cache[1]=exclusive\longrightarrow cache[2]=invalid$ \\
\hline
\end{tabular}
}
 \end{table}

 After the auxiliary invariants are found, they can be fed into other
tools for further purposes. In our work, the auxiliary invariants
are passed to a tool called $\mathsf{proofGen}$ to automatically
generate parameterized Isabelle proof script for the protocol under
study. In essence, the generation of Isabelle proof script is a
generalization from a ground proof for a finite reference protocol
instance (if the search of auxiliary invariants is regarded as a
semi-proof) to a parameterized proof for a general parameterized
protocol instance in a theorem prover. The aforementioned
consistency lemma is the corner stone of both the proofs. Firstly,
we need generalize the ground invariants to the general
parameterized invariants. For instance,
 A technique of parameter mapping plays a key role in our proof generation in order to
generate these proofs automatically. The essence of this technique
is mapping a symbolic proof in parameterized form to a sample proof
in the ground form. The proof pattern to prove that some causal
relation holds between a general rule and an general invariant must
be summarized and formulated a formal proof template.
\texttt{proofGen} will select proper proof method among
$\mathsf{invHoldForRule1}$-$\mathsf{invHoldForRule5}$ to generate
proof commands according to the mapped proof cases in the reference
protocol model and the corresponding causal information passed from
\texttt{invFinder}.  A detail proof for a rule instance and an
invariant instance can be created by instantiating the proof
templates with some parameters with the aid of \texttt{proofGen}.
Isabelle provides a feature {\sf locale} to formalize typical proof
templates, and {\sf interpretation} to formalize proof template
instantiations. Interesting readers can refer to \cite{} ro read the
detailed proofs.

Although a parameterized proof in Isabelle gives the highest
assurances to the mathematicians, such a proof script may be hard to
be understood for engineer. A simulation flow graph of a single
client's $i$ activity can be generated to illustrate intuitively the
correctness of the protocol with the aid of auxiliary invariants. In
essence, such a simulation graph is an abstraction of all the
protocol instance in the view of a client. A state of the abstracted
state space reserves all the values of local variables of the client
$i$ and almost the global variables. Auxiliary invariants are used
to decide whether a rule involving clients except $i$ depending on
partial state of client $i$ and global variables. Interesting
readers can refer to \cite{} ro read the simulation flow of a client
1. In this graph, we can observe clearly how cache[i] are set true
and the effect  of other's client's activities to client [i]. With
the aid of auxiliary invariants, we can observe how the mutual
invariants are kept.

The key point of the German protocol lies in the synchronization of
operations to $home\_sharer\_list$ of all the clients and global
variable $home\_exclusive\_granted$ in order to keep the mutual
exclusion property. When a client $i$ requests an exclusive
occupation or a shared request to an already exclusive holder, after
his request being the current command, and $i$ becomes the current
client,  global actions to invalidate all the clients must be
performed immediately. This is just done by rule {\sf
home\_picks\_new\_request} . Only after all the
$home\_sharer\_list[j]$ of all the clients are false, the
$home\_sharer\_list$ of the current client $i$ and
$home\_exclusive\_granted$ will be set True, and the current command
in this round will be finished, and reset to empty. A subtle feature
of this protocol is that only $channel2[i]$ is set
$grant\_exclusive$, but $cache[i]$ is not set $exclusive$. If
next-round request of clients may be picked before the rule
$home\_sends\_reply\_to\_client\_exclusive$ is performed. In this
case, the condition $channel[i]=empty$ in the guard of the rule
$home\_sends\_invalidate\_message$ forces this new round of
invalidating action to local state of client $i$ to be performed
after the performed action of the previous round of rule
$home\_sends\_reply\_to\_client\_exclusive$, which updates
$cache[i]$ to be $exclusive$.

%=========================================
\section{Experiments}
%=========================================
We implement our tool in Forte \cite{Forte}. More experiments are
done including simple mutual exclusion, German-ish, and  protocols.
The detail experiment codes and data can be found in \cite{}.
\JP{Here, give a table to summarise the results,
e.g., the size of the protocol, the number of invariants found,
the time/memory cost, etc.}

%=========================================
\section{Conclusion}
%=========================================
Our case studies on cache coherence protocols are typical examples
to illustrate the guiding principle of {\sf invFinder}. The
 consistency lemma based on the induction approach, is the
core of our work, which gives the heuristics to guide the tool
 to search invariants. Instead of ``invisible invariants" in previous work
 (see e.g,~\cite{Pnueli2001}, our invariants are visible,
 which can be further refined to precisely
 analyze the correctness of the protocol both in theoretical and practical aspects.

\bibliographystyle{splncsnat}
\bibliography{gste,cache,refer}
\end{document}

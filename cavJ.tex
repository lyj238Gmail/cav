\documentclass{llncs}
%%%%%%%%%%%%%%%%%%%%%%
%%%%   PACKAGES   %%%%
%%%%%%%%%%%%%%%%%%%%%%
\usepackage{makeidx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{latexsym}
\usepackage{url}
\usepackage{color}
\usepackage{isabelle}
\usepackage{isabellesym}
\usepackage{theorem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%For Isabelle code
\newlength{\fminilength}
\newsavebox{\fminibox}
\newenvironment{fmini}[1][\linewidth]
  {\setlength{\fminilength}{#1\fboxsep-2\fboxrule}%
   \vspace{2ex}\noindent\begin{lrbox}{\fminibox}\begin{minipage}{\fminilength}%
   \mbox{ }\hfill\vspace{-2.5ex}}%
  {\end{minipage}\end{lrbox}\vspace{1ex}\hspace{0ex}%
   \framebox{\usebox{\fminibox}}}

\newenvironment{specification}
{\noindent\footnotesize
\tt\begin{fmini}\begin{tabbing}X\=X12345\=XXXX\=XXXX\=XXXX\=XXXX\=XXXX
\=\+\kill} {\end{tabbing}\normalfont\end{fmini}}
\def \twoSpaces {\ \ }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%for comments
\newcommand\JP[1]{\textcolor{magenta}{JP: #1}}
\newcommand\lyj[1]{\textcolor{green}{lyj: #1}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Additional math operators
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[colorlinks,
            linkcolor=black,
            anchorcolor=black,
            citecolor=blue,
            urlcolor=black,
            bookmarks=true
            ]{hyperref}

\input{tcilatex}

%=========================================
\begin{document}

\title{ {\sf paraVerifier}: An Automatic Framework for Proving Parameterized Cache Coherence Protocols}
\titlerunning{{\sf paraVerifier}: An Automatic Proof Framework for Parameterized Cache Coherence Protocols}
\author{~}
\authorrunning{~}
\institute{~}

\maketitle

%-------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------
Parameterized verification of cache coherence protocols is an important
but challenging research problem.  In this paper, we present our tool {\sf paraVerifier}
to handle this research problem within a unified and automatic framework:
(1) it first discovers auxiliary invariants and the
corresponding causal relations between invariants and protocol rules from a
small reference instance of the verified protocol; (2) the discovered
invariants and causal relations can then be generalized into a parameterized
form to construct a formal proof to establish the correctness of the protocol.
%The principle underlying our generalization is symmetry mapping,
%and a novel feature of our work lies in that the last verification result of a
%protocol is provided by a formally readable proof in a theorem prover like Isabelle.
{\sf paraVerifier} has been successfully applied to typical benchmarks. 

%-------------------------------------------------------------------------
\end{abstract}
%-------------------------------------------------------------------------

%=========================================
\section{Introduction}
%=========================================
Verification of parameterized concurrent systems is interesting in
the area of formal methods, mainly due to the practical importance
of such systems. Parameterized systems exist in many
application areas, including cache coherence protocols, security systems, and
network communication protocols. In this work, we
focus on cache coherence protocols, which play a key role in modern
computer architecture. They require complex algorithms that must
deal with asynchrony, unpredictable message delays, and multiple
communication paths between many nodes. Therefore, the highest
possible assurance for the correctness of these complex
parameterized systems should be guaranteed by formal reasoning
techniques.

The real challenge posed by parameterized verification of cache coherence protocols
is that the desired properties should hold in any instance of the parameterized
protocol, not just for a single protocol instance. Model checking is
automatic but is only able to verify an instance of the parameterized
protocol. The correctness of the reference instance does
not formally suffice to conclude the correctness for all instances.
Due to the extreme importance of many parameterized system, it is
preferable to have a proof that the correctness holds for any
instance.

Some advanced techniques such as compositional and abstraction model
checking are proposed to handle this challenge. However, auxiliary
invariants, which is usually provided by a human, based on his
insights of the verification cases, are needed to make these
techniques work. How to find sufficient and necessary invariants
is the core in the field of parameterized verification.
Many papers in the literature have focused on the
construction of a set of auxiliary
invariants, for example, see~\cite{Pnueli2001,Chou2004,Pandav2005,cubicle2011}.
Besides, the theoretical foundation of these techniques and their
soundness proofs are often only discussed in the respective papers.
%For instance, many of these theories contain the apparent circularity in reasoning and
%applying the auxiliary invariants, and are based on the classical
%notion of a so-called simulation proofs. Frankly speaking,
These theories themselves are not easy to understand, and are subjects
to be mechanically checked, since their soundness needs to be
guaranteed without any conditions.

The aim of our tool {\sf paraVerifier} is to solve the parameterized
verification of cache coherence protocols in a unified and automatic way.
{\sf paraVerifier} mainly consists of two parts:  an invariant finder {\sf invFinder}
and a proof generator {\sf proofGen}. In order to verify the that an
invariant $inv$ holds for any instance of a parameterizd protocol.
First, a reference model of the protocol with a fixed parameter
is constructed, and {\sf invFinder} tries to search for
interesting auxiliary invariants and causal relations which is
capable of proving $inv$. Next, {\sf proofGen}
uses the outputs of {\sf invFinder} to construct a complete and parameterized
formal proof in a theorem prover (e.g., Isabelle). Such a proof can eventually
be checked automatically.

The originality of our work lies in the following aspects:
\begin{itemize}
\item {\sf paraVerifier} is based on a simple but elegant theory. Three types of causal
relations between protocol rules and invariants are introduced, which are
essentially special cases of the general induction rule.
The correctness of the three causal relations is captured
by the so-called \emph{consistency lemma}.
One one side, it is heuristics inspired by trying to
construct the consistency relation that guides the tool {\sf
invFinder} to find auxiliary invariants. On the other side, the
consistency lemma provides a general guiding principle to prove
invariants  in the parameterized model of a cache coherence
protocol. Especially, the lemma itself is verified as a
formal theory in Isabelle.

\item {\sf paraVerifier} produces a list of interesting invariants
and a formally readable proof script for a given parameterized cache coherence protocol.
The invariants are visible,
which can characterise the semantical features of the protocol and aid human to
precisely understand the design of the protocol.
The formal proof script not only models the protocol
rigorously and specifies its properties without any ambiguity, but also
is mechanically checked in a theorem prover.
Therefore, it achieves the highest possible
assurance for formal reasoning of the protocol.

\item {\sf paraVerifier} is automatic and scalable.
After the protocol is modelled in {\sf paraVerifier}, auxiliary invariants
are searched automatically ({\sf invFinder}).
The formal proof script in Isabelle is also automatically generated ({\tt proofGen}),
and checked by Isabelle without human intervention.
Furthermore, our tool is able to handle industrial case studies such as
the Flash protocol, the German 2004 protocol, and the Godson-T protocol.
\JP{add references to the protocols.}
\end{itemize}

To the best of our knowledge, {\sf paraVerifier} is the first tool
that generates automatically formal proofs in a theorem prover for
parameterized verification of cache coherence protocols.

%\JP{The following part needs revision and will be moved to evaluation/case studies section.}
%Besides, we also generate a new
%proof for original flash protocol without adding new auxiliary
%variables. This proof is different from those of Park et al \cite{}
%because  they introduce the aggressioned Flash protocol model, which
%is in fact an abstract transaction model of Flash,   need prove
%the correspondence between the abstract model and the original Flash
%model, and then prove the correctness of the protocol in the abstract
%model, and subsequently derive the correctness of protocol in the
%original model by the correspondence. New   auxiliary state variables
%like {\tt fwdSrc} are   introduced  for verification.
%Deep human insight for Flash is needed for both the construction of the aggressioned model
%and  introducing new state variables.  Later research on Flash must also rely on these auxiliary
%variables for verification. Our work need fewer human's aid in the verification of Flash.


%=========================================
%\section{The Design Principle of {\sf paraVerifier}}
%=========================================

\section{Preliminaries}
Consider a set of state variables $V$, we use $e$, $f$ and $S$ to denote an
expression, a formula, and a statement over the set of state
variables $V$. ${\sf andList}~fs$  is an abbreviation of
$fs_1\wedge...\wedge fs_n$, where $n$ is the number of elements in $fs$.
\JP{The above notations are not used in the following discussions.}
Variables are divided into two categories: array variables or
non-array (global) variables. \JP{Explain more about the two categories.} A state of a protocol $s$ is an
instantaneous snapshot of its behaviour given by a mapping from
variables $V$ to natural numbers.

\paragraph*{Semantics of expressions and formulas.}
We write
$\mathsf{expEval}~e~s$ (and $\mathsf{formEval}~f~s$) to denote the
evaluation of the expression $e$ (and formula $f$) at the state $s$.
\JP{$s$ is not introduced before.}

\paragraph*{Precondition} Consider a parallel assignment $S=\{x_i:=e_i | i>0\}$,
we define $\mathsf{preCond}~S~f=f[x_i:=e_i]$, which substitutes each
occurrence of $x_i$ by $e_i$.


\paragraph*{Protocols.} A protocol is formalized by a pair
$(ini,rules)$, where
%
\begin{itemize}
\item $ini $ is an initialization predicate; \JP{What is a predicate?}

\item $rules$ is a set of transition rules, each of which is defined as
  $g \vartriangleright  S$, where $g$ is a predicate, and $S$ is a
  parallel assignment to distinct  variables $v_i$ with expressions
  $e_i$. We write $\mathsf{pre}~r=g$, and $\mathsf{act}~r=g$ if $r=g \vartriangleright
  S$.
\end{itemize}

\paragraph*{Parameterized protocols.}
A parameterized protocol can be formalized by a pair
$(pini,prules)$, where $pini$, and each $prule$ in $prules$ are
functions from natural numbers to an actual predicate and  rule.
\JP{It is unclear what $(pini,prules)$ is.}
Usually the number of parameters of a parameterized rule is one.
\JP{Why? Give a motivation.}
An instance of a parameterized protocol, which is called the
N-parameterized model, is obtained by instantiating $prule$ with
parameters $i$ such that $i \le N$, where $N$ is an arbitrary
natural number. %Obviously, if $j \le N$ and $i \ne j$, then
%$prule~j$ also exists in the rules of the instance. We can see
%$prule~j$ is the symmetric mirror of $prule~i$ by a permutation
%$[i\mapsto j]$.
\JP{The above description is very unclear.}


\paragraph*{Symmetry and generalization.}
Here symmetry is defined with respect to
a permutation on the set of natural numbers $\{i. i \le N\}$.We can
define symmetry transformation to a variable w.r.t. a permutation
$\tau$, $symApp~\tau~a[i]=a[\tau~i]$; accordingly we can lift the
symmetry transformation to a formula, statement, and rule. Formally
our work  relies on three kinds of predicates to \JP{define actual rules
(formulas) from a formal definition of a parameterized rule
(formula) (confused!)}: $\mathsf{ex1P}~ N~ P \equiv \exists i. (i \le N \wedge P~
i)$, $\mathsf{ex2P}~ N~ P \equiv \exists i~j. (i \le N \wedge j \le
N \wedge i\ne j \wedge P~ i~j)$, and $\mathsf{ex3P}~ N~ P \equiv
\exists i~j~k. (i \le N \wedge j \le N \wedge k \le N\wedge i\ne j
\wedge i\ne k \wedge j\ne k \wedge P~ i~j~k)$.
\JP{Explain the idea of each symmetry.}
For instance, let
$prule~i$ a formal parameterized rule, then the set $\{r.
\mathsf{ex1P}~ N~ \lambda i. prule ~i\}$ is all the actual rules of
the N-paramterized model, each of which are symmetric to  any one of
the others. Namely, the set is the equivalence class of all the
parameterized rules which are symmetric to $prule~1$, thus we can
view the set is an generalization of $prule~1$ in the sense of
symmetry. In this work, symmetry is inherent property of
parameterized cache coherence protocol, which we will fully exploit
in this work.

\paragraph*{Reachable state sets.}
As usual, the reachable state set
$\mathsf{reachableSet}~ ini ~rules$ of the protocol $(ini,rules)$
can be inductively defined: (1) a state $s$ is in
$\mathsf{reachableSet}~ini~ rules$ if
 $\mathsf{formEval}~ini~s$; (2) \JP{a result state $s'$?}, which is reached by triggering and
 executing a rule $r$ from a state $s$, is also in
 $\mathsf{reachableSet}~ini~ rules$ if  $s$ already is in
 $\mathsf{reachableSet}~ini~ rules$ and $r $ $\in$  $rules$.

\paragraph*{Invariants.}
In this work, invariants are formulas in a unform: $\neg\mathsf{andList}~atoms$.
\JP{the form of the invariant is really strange!}
Each $atoms_i$ is of the form such that
$cache[1]=\mathsf{exclusive}$. An invariant is required to be
evaluated as true in any one of the reachable state set.

Let $\mathsf{I}$, $\mathsf{T}$, $\mathsf{C}$,  $\mathsf{E}$,
$\mathsf{true}$, and $\mathsf{false}$ are different  constants. $n$
is a parameterized variable, $x$ a global variable. Below we use
abbreviations:
$\mathsf{forallForm}~N~pf\equiv\mathsf{andList}~[pf~0,...,pf~N]$.

\begin{specification}
 pini  N $\equiv$
   x=true $\wedge$ (forallForm N ($\lambda$ i. n[i]=I))\\

    try i $\equiv$ n[i] = I $\vartriangleright$ n[i] := T; \\

    crit i $\equiv$ n[i] = T\& x = true $\vartriangleright$  n[i] := C; x := false;  ;\\

%
   exit i $\equiv$ n[i] = C $\vartriangleright$ n[i] := E; \\


   idle  i $\equiv$  n[i] = E $\vartriangleright$ n[i] := I;  x := true;
  \\% \\
   prules N $\equiv$ \{r. exLessP N ($\lambda$ i. r=crit   i)~$\vee$~exLessP N ($\lambda$ i. r=exit
i)  $\vee$\\
 exLessP N ($\lambda$ i. r=idle i)~$\vee$ exLessP N ($\lambda$ i.r=try i)\}\\
%\\

mutualInv i j $\equiv$
  $\neg$ (n[i]= C $\wedge$ n[j]= C)\\



\end{specification}

Let $N \ge 3$, $(prules~N, pini~N)$ is a parameterized protocol
instance, now we want to prove that mutual exclusion property
$mutualInv~1~2$ holds at any one of the reachable state set of the
protocol.

\paragraph*{Formal proofs inIsabelle/Isar } A formal proof script
will be a product in our formal verification.  A theory is a file
with a named collection of types, functions, and theorems, proofs.
The general format of a theory $T$ is as
follows: \\

$\mathsf{theory}\ T$

${\it declarations\ for\ types,\ definitions,\ lemmas,\ and\
proofs}$

$\mathsf{end}$ \\
A lemma is written as $\mathsf{lemma}~name:
\mathsf{assumes}~a_{1}:``A_{1}"~{\sf and} \dots~{\sf and}~a_{n}:
``A_{n}"~\mathsf{shows}~B$.


A typical proof  has a more human-readable structure as follows: \\

$\mathsf{proof}$

$\mathsf{assume}~asm_{0}~\mathsf{and}~\ldots~\mathsf{and}~asm_{m}$

$\mathsf{have}~{\it formula_{1}}$

$~~~~\mathsf{proof}$ ....(*proof script for $formula_{1}$*)
$\mathsf{qed}$

...

$\mathsf{have}~{\it formula_{n}}$

$~~~~\mathsf{proof}$ ....(*proof script for $formula_{n}$*)
$\mathsf{qed}$

$\mathsf{show}~{\it thesis}$

$~~~~\mathsf{proof}$ ....(*proof script for $thesis$*)
$\mathsf{qed}$

$\mathsf{qed}$\\

A formal proof theory can be checked automatically by a
theorem-prover. Modern theorem prover have provided good support for
automatical reasoning on many problems which falls in the decidable
theories supported by the prover. However, for a  formalized theory
 which specific to an application like the verification of cache coherence properties,
  the key proof
points which need the most human intelligence such as rule induction
and case analysis, needs the human's insight in this application
field to write them. In our work, our tool {\tt proofGen} generates
these key proof steps automatically.

\section{Consistency Lemma}
A novel feature of our work lies in that three kinds of causal
relations are exploited, which are essentially special cases of the
general induction rule.

 Consider a rule $r$, a formula $f$, and a formula set $fs$, three
 kinds of causal relations are defined as follows:

\begin{definition}  Relation
$\mathsf{invHoldForRule_1} ~f ~r$ if    $ \mathsf{pre}~ r
\longrightarrow \mathsf{preCond}~ f ~(\mathsf{act}~ r)$ ;
$\mathsf{invHoldForRule_2}~ f~ r$ if $f = \mathsf{preCond}~ f
(\mathsf{act}~ r)$; $\mathsf{invHoldForRule_3}~ f~ r ~fs$ if there
exits a formula $f'$ in $fs$ such that
  $(f' \wedge (\mathsf{pre}~ r)) \longrightarrow \mathsf{preCond} ~f ~(\mathsf{act}
  ~r)$; $\mathsf{invHoldForRule}~ f~ r ~fs$ holds if $\mathsf{invHoldForRule_1} ~f
  ~r$, or $\mathsf{invHoldForRule_2} ~f ~r$, or $\mathsf{invHoldForRule_3}~ f~ r
  ~fs$ holds.
\end{definition}

 We can view the relation $\mathsf{invHoldForRule}~ f
r ~fs$ in two ways. Firstly it defines some causality relation
between $inv$, $r$, and $invs$.  $\mathsf{invHoldForRule}_1~f~ r$
  means that after rule $r$ is executed,
 $f$ will be true immediately;   $\mathsf{invHoldForRule}_2~f~ r$ specifies that
 $\mathsf{preCond}~S~f=f$, intuitively this means that none of state variables in $f$ is
 changed, and the execution of statement $S$ does not affect the
 evaluation of $f$.
 $\mathsf{invHoldForRule}_3~f~ r~invs$ states
  that  there exists another invariant $f' \in invs$ such that
  the conjunction of the guard of $r$ and $f'$ implies the precondition  $\mathsf{preCond}~S~f$.
Intuitively, $\mathsf{invHoldForRule} ~f ~r ~fs$ defines a causal
relation, which can guaranttee that if each of formula in $fs$ holds
before the execution of the rule $r$, then  $f$ also holds after the
execution of the rule $r$ f. Secondly the relation
$\mathsf{invHoldForRule} ~f ~r ~fs$ can also be regarded as a
special kind of inductive proof rules, which can be applied to prove
each formula in $fs$ holds at each inductive protocol rule cases.


\begin{definition}
A consistency relation $\mathsf{consistent}~ invs ~ini~ rs$,
 which holds between a protocol $(inis,rs)$ and
a set of invariants $invs=\{inv_1,\ldots, inv_n\}$,  is defined as
follows:
%
\begin{itemize}
\item For any invariant $inv \in invs$,
initializing predicate $ini \in ini$, and state $s$, if $ini$ is
evaluated true at state $s$, then $inv$ is also evaluated true at
state $s$.

\item For any invariant $inv \in invs$, $r$ in the rule set
$rs$, either one of the following five types of relation holds,
i.e., $\mathsf{invHoldForRule_{1-3}}~inv~ r$.

\end{itemize}
\end{definition}


For instance,

\begin{specification}
invOnX$_1$ ~i $\equiv$ $\neg$(x=true $\wedge$ n[i]=C)   \ \ \

invOnX$_2$ ~i $\equiv \neg$ (x=true$\wedge$ n[i]=E)  \\


aux$_1$ ~i~j $\equiv \neg$ ( n[i]=C$\wedge$n[i]=E)   \ \ \

aux$_2$ ~i~j $\equiv \neg$  ( n[i]=E$\wedge$n[i]=C)\\

  pinvs N$\equiv$ \{f. exTwoLessP N ($\lambda$ i j.  f = invonX1 i j) $\vee$exTwoLessP N ($\lambda$ i j.  f = invOnX2 i j)   \\
$\vee$exLessP N ($\lambda$ i.  f= mutualInv i j)    $\vee$exTwoLessP N ($\lambda$ i j.  f =  aux1 i j) \\
$\vee$exTwoLessP N ($\lambda$ i j.  f =  aux2 i j) \}.

\end{specification}

We have  $\mathsf{invHoldForRule_1 }~(\mathsf{invOnX_1} ~1)~
(\mathsf{crit}~1)$, $\mathsf{invHoldForRule2 }~(\mathsf{invOnX_1}
~1)~ (\mathsf{try}~2)$,
 and $\mathsf{invHoldForRule_3 }~(\mathsf{mutual_1} ~1~2)~ (\mathsf{crit}~1)$.
 The last holds because
 $\mathsf{invOnX_1} ~2 \in invs$, $\mathsf{preCond}~(\mathsf{act}~(\mathsf{crit}~1))~
 (\mathsf{mutual_1} ~1~2)=\neg (\mathsf{C}=\mathsf{C}\wedge n[2]=\mathsf{C})$,
 and $ x=true \wedge \mathsf{invOnX_1}~2 \longrightarrow \mathsf{preCond}~
 (\mathsf{act}~(\mathsf{crit}~1))~~(\mathsf{mutual_1}
 ~1~2)$. It is not diffcult to verify
$\mathsf{consistent}~ (\mathsf{pinvs}~ N) ~(\mathsf{pini}~N)~
(\mathsf{prules}~N)$ also holds.

Notice that the formula set $\mathsf{pinvs}~ N$ gives a complete
logical characterization of the semantics of the protocol.
$\mathsf{invOnX_1} ~i$ specifies that the flag $x$ shows the
availability of the critical section. Once some node state variable
$n[i]$ is set $C$ or $E$, $x$ will be set $true$. Formulas
$\mathsf{mutualInv}~ i ~j$, $\mathsf{aux_1} ~i~j$, and
$\mathsf{aux_2} ~i~j$ state the mutual exclusion properties between
a node's $\mathsf{C}(\mathsf{E})$ state and another different node's
$\mathsf{C}(\mathsf{E})$ state.

Now we can formally prove the essence of the aforementioned
causality. Suppose that the consistency relation
$\mathsf{consistent}~ invs ~inis~ rs$ holds, for any $inv \in invs$,
$inv$ holds for any reachable state $s$ such that $s  \in
\mathsf{reachableSet}~ ini~ rs$. This is formalized by a so-called
consistency lemma.

\begin{lemma}\label{consistentLemma}[(consistency lemma)]
  $\isasymlbrakk \mathsf{consistent}~ invs ~ini~ rs$; $s  \in \mathsf{reachableSet}~ ini~ rs$
  $\isasymrbrakk\Longrightarrow$ $\forall inv. inv \in invs \longrightarrow
\mathsf{formEval}~ inv ~s$.
\end{lemma}

\end{document}

\documentclass{llncs}
%%%%%%%%%%%%%%%%%%%%%%
%%%%   PACKAGES   %%%%
%%%%%%%%%%%%%%%%%%%%%%
\usepackage{makeidx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{latexsym}
\usepackage{url}
\usepackage{color}
\usepackage{isabelle}
\usepackage{isabellesym}
\usepackage{theorem}
\usepackage{algorithmic}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
%\usepackage{program}
\usepackage{cases}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%For Isabelle code
\newlength{\fminilength}
\newsavebox{\fminibox}
\newenvironment{fmini}[1][\linewidth]
  {\setlength{\fminilength}{#1\fboxsep-2\fboxrule}%
   \vspace{2ex}\noindent\begin{lrbox}{\fminibox}\begin{minipage}{\fminilength}%
   \mbox{ }\hfill\vspace{-2.5ex}}%
  {\end{minipage}\end{lrbox}\vspace{1ex}\hspace{0ex}%
   \framebox{\usebox{\fminibox}}}

\newenvironment{specification}
{\noindent\scriptsize
\tt\begin{fmini}\begin{tabbing}X\=X12345\=XXXX\=XXXX\=XXXX\=XXXX\=XXXX
\=\+\kill} {\end{tabbing}\normalfont\end{fmini}}
\def \twoSpaces {\ \ }
\def \oneSpace {\ }
\def \eqc {\doteq }
\def \andc {\barwedge }
\def \negc {!}
\def \orc {\veebar }
\def \alt {$/\backslash$ }
\def \cat {\symbol{94}}

\def \dbRight {$\backslash\backslash$}
\def \iInv {iInv}
\def \iR {iR}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%for comments
\newcommand\JP[1]{\textcolor{magenta}{JP: #1}}
\newcommand\lyj[1]{\textcolor{green}{lyj: #1}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Additional math operators
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[colorlinks,
            linkcolor=black,
            anchorcolor=black,
            citecolor=blue,
            urlcolor=black,
            bookmarks=true
            ]{hyperref}

\input{tcilatex}

%=========================================
\begin{document}

\title{ {\sf A Novel Approach to Parameterized verification of Cache Coherence Protocols}}
\titlerunning{A Novel Approach to Parameterized verification of Cache Coherence Protocols}
\author{~}
\authorrunning{~}
\institute{~}

\maketitle
\vspace{-2.6cm}
%-------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------
Parameterized verification of parameterized protocols like cache coherence protocols is important
but hard.   Our tool {\sf paraVerifier} handles this hard problem in
a unified framework: (1) it automatically  discovers auxiliary invariants and the
corresponding causal relations %between invariants and rules
 from a small reference instance of the verified protocol; (2) the above
invariants and causal relation information  can be also  automatically generalized into a parameterized
form to construct a formally parameterized proof in a theorem prover
(e.g., Isabelle). The principle underlying the generalization is the
symmetry mapping. Our method is successfully applied to typical
benchmarks including  snoopy-based and directory-based. Another novel
feature of our method lies in that the last verification result of a
protocol is provided by a formally readable proof.% in a theorem
%prover like Isabelle.

%-------------------------------------------------------------------------
\end{abstract}
%-------------------------------------------------------------------------
%-------------------------------------------------------------------------
\vspace{-1.5cm}
\section{Introduction }
%-------------------------------------------------------------------------
%=========================================
Verification of parameterized concurrent systems is interesting in
the area of formal methods, mainly due to the practical importance
of such systems. Parameterized systems exist in many important
application areas: cache coherence protocols, security systems, and
network communication protocols, \emph{etc}. %In this work, we will
%focus on cache coherence protocols, which play a key role in modern
%computer architectures. They require complex algorithms that must
%deal with asynchrony, unpredictable message delays, and multiple
%communication paths between many clients. Therefore, the highest
%possible assurance for the correctness of these complex
%parameterized systems should be guaranteed by formal reasoning
%techniques.
The real challenge posed by parameterized verification is that the
desired properties should hold in any instance of the parameterized
system, not just for a single protocol instance. Model checking is
automatical but able to verify just an instance of the parameterized
 system. The correctness of the reference instance  does
not formally suffice to conclude the correctness for all instances.
Due to the extreme importance of many parameterized system, it is
preferable to have a proof that the correctness holds for any
instance.

\paragraph*{Related Work} There have been a lot of research papers in the field of  parameterized
verification~\cite{Pnueli1996,Bj√∏rner1997,Arons2001,Pnueli2001,Tiwari2001,Chou2004,Pandav2005,Lv2007,cubicle2011}.
Among them, the `invisible invariants' method, proposed in~\cite{Arons2001},
is an automatic technique for parameterized verification. In this
method, auxiliary invariants are computed in a finite system
instance to aid inductive invariant checking.  % Work~\cite{Arons2001,Lv2007} attempts to automatically
%find invariants. However, the invisible invariants are raw boolean formulas transferred from the reachable sate set of a small finite instance
%of a protocol, which are BDDs computed by TLV (an variant of BDD\_based SMV model checker). They are too raw to have an intuitive meanings. The capacity of the invisible invariant method is seriously limited when computing the reachable  set of invisible invariants for  the inductive checking is not feasible in the case of a large example like FLASH . Until now, the  examples, which can be handled by the "invisible invariant" method, are quite small,  we still can't find successful experiments  on large examples like FLASH with data paths.
The CMP method, which adopts parameter abstraction and guard strengthening, is proposed
in~\cite{Chou2004} for verifying a safety property $inv$ of
a parameterized system.
 An abstract instance of the parameterized protocol %$, % which consists of m + 1
%nodes $\{P_1, \ldots , P_m, P^*\}$ with $m$ normal nodes and one
%abstract node $P^*$, is constructed iteratively. The abstract system
is constructed by a counter-example-guided refinement process.  %However, this method's soundness is only argued in an
informal way. %To the best of our knowledge, no one has
%formally proved its correctness in a theorem prover although the authors argued for a mechanized proof for all the thing of CMP in \cite{Chou2004}. Besides, the analysis of counter-example and generation of new auxiliary invariants usually
% depend on human's deep insightful understanding of the protocol. It is too laborious for people to do these analysis. %and some effective automatic  tool is needed to help people.
%It was demonstrated in
%[7] that this method is powerful enough to handle complex
%cache coherence protocols such as FLASH effectively.





The degree of scalability and automatic is the most important of all to estimate an approach in the field of parameterized verification. For instance, FLASH is a hard real-world benchmark for any proposed method for parameterized verification. Human guidance still plays a key role in the existing successful verification for FLASH in \cite{Park1996a,McMillan2001,Chou2004} up to now.%: °∞if the method works on FLASH, then there is a good chance that it will also work on many real-world cache coherence protocols°± \cite{Chou2004}. However, the existing approaches, which have verified FLASH, need too much human intervention. The first full verification of safety properties of FLASH is done by work in \cite{Park1996a}. Park and Dill  proved the safety properties of FLASH using  PVS \cite{cade92-pvs}. %They introduce the aggressioned FLASH protocol, which
%is in fact an abstracted transaction version of FLASH,   need prove
%the correspondence between the abstract and the original FLASH
%protocol, and then prove the correctness of the abstracted protocol, and subsequently derive the correctness of  the
%original protocol by the correspondence. New   auxiliary state variables
%like {\tt fwdSrc} are   introduced  for verification. Deep human insight for FLASH is needed for both the construction of the aggressioned model  and  introducing new state variables.  Later research on FLASH must also rely on these auxiliary
%variables for verification.
%McMillan applied compositional
%model checking \cite{McMillan2001}  and used Candence SMV  \cite{cadenceSMV} to the verification of both safety and liveness properties of FLASH. In a different context, safety
%properties of German 2000 and FLASH were proved via
%Murphi tool \cite{alanHuMurphi} by adopting CMP method in \cite{Chou2004}. In
%all the three methods mentioned above, auxiliary invariants
%have to be supplied manually. Predicate abstraction based
%methods were applied to verify
%FLASH in \cite{dillPred}. Users need to manually provide plausible properties
%in predicate abstraction and automated predicate discovery
%techniques to find large predicates. So verifying large protocols
%like FLASH using predicate abstraction is also difficult. In contrast to previous work, our work need fewer human's aid in the verification of FLASH.   Both the auxiliary invariants and formal proof are generated automatically, and these   auxiliary invariants have intuitive meanings which can  be used to analyze FLASH.  %  The abstractions
%we used, the reliance on apparently circular reasoning, and the counterexampleguided
%discovery of noninterference lemmas are all deeply influenced by McMillan°Øs
%work.
There are two central problems which need better solution in the parameterized verification for complex protocols like FLASH.  How to find a set of sufficient and necessary invariants
is the core in the field of parameterized verification. It is desirable that the
invariants are provided with less human intervention.
Besides, the theory foundation of a technique of parameterized verification and its
soundness are only discussed in a paper proof style.  We will compare our approach in \ref{sec:experiments}.%For instance,
%the theory contains the apparent circularity in reasoning and
%applying the auxialiary invariants, and is based on the classical
%notion of a so-called simulation proofs \cite{Chou2004}. Frankly speaking, the
%theory itself is not easy to be understood, and  needs to be
%checked mechanically due to its soundness of should be
%guaranteed without conditions.
It is preferable to make all the verification can be formulated in a publicly-recognized trust-worthy framework like a theorem prover\cite{Chou2004}. However,
 theorem proving in a theorem prover like Isabelle usually is interactive, not automatical.

%which are either used for inductive verification or abstraction
%model construction. Therefore, how to find ans use these auxiliary
%invariants is the central problem in the research field of
%parameterized verification.

In order to solve the parameterized
verification of cache coherence protocols in a both automatical and rigorous way, we design a tool {\sf
paraVerifier}, which is based on a a simple but elegant theory.  Three kinds of causal
relations are introduced, which are
essentially special cases of the general induction rule. Then a
so-called consistency lemma is proposed, which is the cornerstone in
our framework. Especially, the theory foundation itself is  verified as a
formal theory in Isabelle, which is the basically formal library to verify protocol case studies. The library provides basical type and constant definitions to model protocol cases and lemmas to prove invariant properties. Therefore the theoretical foundation is
the most rigourous.

{\sf
paraVerifier} composed of two parts:  an invariant finder {\tt invFinder}
and a proof generator {\tt proofGen}. %In order to verify  that an
%invariant $inv$ holds for any parameterizd instance of a protocol.
Given a protocol $\mathcal{P}$, and a property $inv$. {\tt invFinder} tries to search
interesting auxiliary invariants and causal relations which are
capable of proving $inv$. This process is guided by the heuristics inspired by constructing auxiliary invariants and causal relations that satisfy
consistency relation.  Oracles will be used such as  a reference model of $\mathcal{P}$ with a fixed number
of clients in different model-checkers, and a SMT-solver


Next, {\tt proofGen}
 generalizes the auxiliary invariants and causal relations, which  are output  in the first stage,  into a parameterized form, and uses them
 construct a completely parameterized
formal proof in a theorem prover(e.g., Isabelle) to model $\mathcal{P}$ and to prove the property $inv$. After the base theory is imported, the generated proof is  checked automatically.  Usually a proof is done interactively. Special efforts in the design of the proof generation are made in order to make the proof checking automatically. %In order to make the proof checking automatical, the basically formal library theory should be imported, and support

The organization of this work is as follows: Section \ref{sec:Preliminaries} introduces the theoretical foundation; \ref{sec:invFinder} the {\sf invFinder}; \ref{sec:generalization} the generalization strategy; \ref{sec:prooGen} the {\sf proofGen} and the generated proof. We go through these sections by verifying a small example - mutual exclusion example. Section \ref{} shows the further experiments on real-world protocols. Section \ref{} compares ours with the previous work.

\section{Preliminaries}\label{sec:Preliminaries}
%\subsection{Protocol syntax} \label{sec:protocolSyntax}
%Variable are defined by the following BNF grammar:
%\begin{equation*}
%\left.
%\begin{array}{l}
%\mathtt{
%var ::=id |var[int] |rcd.id}
%\end{array}%
%\right.
%\end{equation*}
There are three kinds of $variables$:
1) simple identifier, denoted by a string;
2) element of an array, denoted by a string followed by a natural inside a square bracket. E.g., $arr[i]$ indicates the $i$th element of the array $arr$;
3) filed of a record, denoted by a string followed by a dot and then another string. E.g., $rcd.f$ indicates the filed $f$ of the record $rcd$.
Each variable is associated with its $type$. There are three types in our model, including enumeration, natural number, and Boolean.

%%Expressions and formulas are defined recursively by the following BNF grammar:
%\begin{equation*}
%\left.
%\begin{array}{l}
%\mathtt{
%exp::=var | const | formula?exp:exp|}\\
%\mathtt{formula::=True| False| exp=exp | formula ~op~ formula | \neg formula }

%\end{array}%
%\right.
%\end{equation*}

$Experssions$ and $formulas$ are define mutually recursively. can be simple or compound. A simple expression is either a variable or a constant, while a compound expression is constructed with the ite(if-then-else) form $f?e_1:e_2$, where $e_1$ and $e_2$ are expressions, and $f$ is a formula.
A $formula$ can be an atomic formula or a compound formula. An atomic formula can be a boolean variable or boolean constant, or in the equivalence form $e_1\eqc e_2$, where $e_1$ and $e_2$ are two expressions. A $formula$ can also be constructed from formulas using the logic connectives, including negation ($\negc$), conjunction ($\andc$), disjunction ($\orc$), implication ($\dashrightarrow$). %, logical equivalence ($\longleftrightarrow$).

An $assignment$ is a mapping from a variable to an expression, and is denoted with the assigning operation symbol ``:=''. A $statement$ $\alpha$ is a set of assignments which are executed in parallel, e.g., $ x_1:=e_1;x_2:=e_2;...;x_k:=e_k $. If an assignment maps a variable to a (constant) value, then we say it is a $value$-$assignment$.  We use $\alpha|_x$ to denote the expression assigned to $x$ under the statement $\alpha$. For example, let $\alpha$ be $\{arr[1]:=C;x:=false\}$, then $\alpha|_x$ returns $false$. A $state$ is an instantaneous snapshot of its behavior given by a set of value-assignments.




For every expression $e$ and formula $f$, we denote the value of $e$ (or $f$) under the state $s::var \Rightarrow valueType $ as $\mathbb{A}[e,s]$ (or $\mathbb{B}[f,s]$)
For   a formula $f$, we write %$s,e\mapsto c$ and
$s\models f$ to mean %$\mathbb{A}[e,s]=c$ and
$\mathbb{B}[f,s]=true$.
Formal semantics of expressions and formulas are given in HOL (higer-order logics) as usual, which is shown in the appendix.   \footnote{The  logic to specify parameterized system is a special logic, which can be embedded in HOL supported by Isabelle. Therefore HOL can be seen as the main meta-logic to specify our work.}


For an expression $e$ and a statement $\alpha= x_1:=e_1;x_2:=e_2;...;x_k:=e_k $, we use $\mathsf{vars(\alpha)}$ to denote the variables to be assigned $\{x_1,x_2,...x_k\}$; and use $e^{\alpha}$ to denote the expression transformed from $e$ by substituting each $x_i$ with $e_i$ simultaneously.
Similarly, for a formula $f$  and a statement $\alpha= x_1:=e_1;x_2:=e_2;...;x_k:=e_k $, we use $f^{\alpha}$ to denote the formula transformed from $f$ by substituting each $x_i$ with $e_i$.
Moreover, $f^{\alpha}$ can be regarded as the weakest precondition of formula $f$ w.r.t. statement $\alpha$, and we denote $preCond(f,\alpha)\equiv f^{\alpha}$. Noting that a state transition is caused by an execution of the statement, formally, we define: $s\overset{\alpha}{\twoheadrightarrow } s' \equiv$ $(\forall x \in \mathsf{vars}(\alpha). s'(x)= \mathbb{A}[\alpha|_x,s])$ $\wedge (\forall x \notin \mathsf{vars}(\alpha). s'(x)= s(x))$ .

A $rule$ $r$ is a pair $<g,\alpha>$, where $g$ is a formula and is called the $guard$ of rule $r$, and $\alpha$ is a statement and is called the $action$ of rule $r$.
 For convenience, we denote a rule with the guard $g$ and the statement $\alpha$ as $g \vartriangleright \alpha$, $\mathsf{act}(g \vartriangleright \alpha)\equiv \alpha$ and $\mathsf{guard}(g \vartriangleright \alpha)\equiv g$. If the guard $g$ is satisfied at state $s$, then $\alpha$ can be executed, thus a new state $s'$ is derived. We call the rule $g \vartriangleright \alpha$ is triggered at $s$, and transitioned into $s'$. Formally we define: $s\overset{r}{\rightarrow } s' \equiv s\models \mathsf{guard}(r) \wedge s\overset{\mathsf{act}(r)}{\twoheadrightarrow } s'$.

A $protocol$ $\mathcal{P}$ is a pair $(I,R)$, where $I$ is a set of $formulas$ and is called the initializing formula  set, and $R$ is a set of rules. %A $state$ is an instantaneous snapshot of its behavior given by a set of assignments.
 As usual, the reachable state set of protocol  $\mathcal{P}=(I,R)$, denoted as $\mathsf{reachableSet}(\mathcal{P})$, can be defined inductively: (1) a state $s$ is in
$\mathsf{reachableSet}(\mathcal{P})$ if there exists a formula $f \in I$, and $s \models  f$; (2) a state $s$ is in
$\mathsf{reachableSet}(\mathcal{P})$ if there exists a  state $s_0$  and a rule $r \in R$ such that $s_0 \in \mathsf{reachableSet}(\mathcal{P})$ and $s_0\overset{r}{\rightarrow } s$.

A parameterized object(T) is simple a function from a natural number to T, namely of type $nat \Rightarrow T$. For instance, a parameterized formula $pf$ is of type $nat \Rightarrow formula$, and we define
$\mathsf{forallForm}(1,pf)\equiv~pf(1)$, and $\mathsf{forallForm}((n+1),pf)\equiv\mathsf{forallForm}(n,pf) \andc pf(n +1)$. $\mathsf{existsForm}(1,pf)\equiv~pf(1)$, and $\mathsf{existsForm}((n+1),pf)\equiv\mathsf{existsForm}(n,pf) \orc pf(n +1)$.





Now we use a simple example to illustrate the above definitions by a simple mutual exclusion protocol with $N$ nodes. Let $\mathsf{I}$, $\mathsf{T}$,
 $\mathsf{C}$, and  $\mathsf{E}$  be three enumerating values, $x$,    $n$ are  simple and array variables, $N$ a natural number,  $pini(N)$   the predicate to specify the inial state, prules(N) the four rules of the protocol, $mutualInv(i,j)$ a property that $n[i]$ and $ n[j]$ cann't be $C$ at the same time. We want to verify that $mutualInv(i,j)$ holds for any $i\le N$, $j \le N$ s.t. $i \neq j$.

\begin{example}\label{example1}Mutual-exclusion example.

\begin{specification}
assignN(i)$\equiv$n[i]=I\\
 pini(N) $\equiv$
   x=true $\wedge$  forallForm(N,assignN )\\

    try(i) $\equiv$ n[i] $\eqc$ I $\vartriangleright$ n[i] := T \\

    crit(i) $\equiv$ n[i] $\eqc$ T$\wedge$ x = true $\vartriangleright$  n[i] := C; x := false\\

%
   exit(i) $\equiv$ n[i] $\eqc$ C $\vartriangleright$ n[i] := E \\


   idle(i) $\equiv$  n[i] $\eqc$ E $\vartriangleright$ n[i] := I;  x := true
  \\% \\
   prules(N) $\equiv$ \{r. $\exists$ i. i $\le$ N $\wedge$( r=crit(i)~$\vee$ r=exit(i)  $\vee$ r=idle (i)~$\vee$ r=try (i)\}\\
%\\

mutualEx(N)$\equiv$ (pIni(N), prules(N))\\

mutualInv(i,j) $\equiv$
  $\negc$ (n[i]$\eqc$ C $\andc$ n[j]$\eqc$ C)\\



\end{specification}
\end{example}


As Hoare logics specifies,  after executing statement $S$, $f$ holds iff $\mathsf{preCond}~f~S$ holds before the execution.
\begin{lemma}\label{lemma-preCond}
Suppose $s\overset{S}{\twoheadrightarrow } s'$,
$s\models (\mathsf{preCond} (f, S))$ if and only if $s'\models f$
\end{lemma}
%definition statementEnableForm:: rule $\Rightarrow$
%formula$\Rightarrow$bool
%\\
% where statementEnableForm r f$\equiv$
%$\forall$s. formEval (pre r) s \\
%$\longrightarrow$ formEval  (preCond f (act r)) s\\
%definition statementDisableForm::rule$\Rightarrow$formula$\Rightarrow$bool\\
%where statementDisableForm r f $\equiv$
 %    $\forall$s. formEval (pre r) s \\
%$\longrightarrow$ $\neg$ formEval  (preCond f (act r)) s
%\end{specification}

%Function $\mathsf{statementEnableForm}$ says that the guard of the rule implies
% the pre-condition of  formula $f$  w.r.t. statement of
% the rule. This means that $f$ must be valid after statement $S$ is executed.
%On the other hand,  $\mathsf{statementDisableForm}$ says that   the
%guard of the rule implies the negation of the pre-condition of
%formula $f$ w.r.t. statement of the rule. This means that $f$ must
%be invalid after statement $S$ is executed.
%For instance,  for the statement $S=\mathsf{assign}~
%((\mathsf{Para}~  n~ 0), (\mathsf{Const} ~\mathsf{T}))$, formula
%$f_1= \mathsf{eqn}~ (\mathsf{IVar}~ (\mathsf{Para}~ n 0))
%(\mathsf{Const}~ \mathsf{T})) $, $f_2= \mathsf{eqn}~ (\mathsf{IVar}~
%(\mathsf{Para}~ n ~0))\mathsf (\mathsf{Const}~ \mathsf{E}))$, we
%have $\mathsf{statementEnableForm}~S~f_1$ and
%$\mathsf{statementDisableForm}~S~f_2$. We also define two functions
%$\mathsf{varOfForm}~f$ and $\mathsf{varOfSent}~S$ to denote the set
%of variables used in the formula $f$ and statement $S$.
%\section{Causal relations and consistency lemma} \label{sec:causal_rel}
A novel feature of our work lies in that three kinds of causal
relations are exploited, which are essentially special cases of the
general induction rule.  Consider a rule $r$, a formula $f$, and a formula set $fs$, three
 kinds of causal relations are defined as follows:\\
 \begin{definition}
We define the following relations: $\mathsf{invHoldForRule_1}::state \times formula\times rule \Rightarrow bool$, $\mathsf{invHoldForRule_2}::state\times  formula\times rule  \Rightarrow bool$,  $\mathsf{invHoldForRule_3}::state \times formula\times rule \times rule set\Rightarrow bool$, and $\mathsf{invHoldForRule_3}::state \times formula\times rule \times rule set\Rightarrow bool$.
\begin{enumerate}
\item $\mathsf{invHoldForRule_1} (s,f,r) \equiv $$s \models \mathsf{pre}(r) \longrightarrow s \models \mathsf{preCond}(f ,\mathsf{act}(r))$;\footnote{Here  $\longrightarrow$ and $\longleftrightarrow$ are HOL connectives.  }
\item $\mathsf{invHoldForRule_2}(s,f,r) \equiv  $$s \models f \longleftrightarrow s \models \mathsf{preCond}( f,(\mathsf{act}( r))$;
\item $\mathsf{invHoldForRule_3}(s,f,r,fs) \equiv$  $\exists f' \in fs$ s.t.
$s \models ( f' \andc (\mathsf{pre}(r))  \longrightarrow s \models \mathsf{preCond}(f ,\mathsf{act}(r))$;
\item $\mathsf{invHoldForRule}(s,f,r, fs) \equiv$   $s \models\mathsf{invHoldForRule_1}(s,f,r) \vee s\models\mathsf{invHoldForRule_2}(s,f,r) \vee s\models \mathsf{invHoldForRule_3}(s,f,r,fs)$.
%\item $\mathsf{invHoldForRule}~ f~ r ~fs \equiv (\mathsf{invHoldForRule_1} ~f
%  ~r) \lor (\mathsf{invHoldForRule_2} ~f ~r) \lor (\mathsf{invHoldForRule_3}~ f~ r~fs)$.
\end{enumerate}
\end{definition}
%\begin{specification}
%definition invHoldForRule1::
%formula $\Rightarrow$ state $\Rightarrow $ rule $\Rightarrow$ bool where\\
%invHoldForRule1 s f  r$\equiv$ %\\
%(  formEval (pre r) s $\longrightarrow$
%  formEval  (preCond f  (act r)) s ) \\ %\\

%definition invHoldForRule2:: state $\Rightarrow$ formula $\Rightarrow$ rule $\Rightarrow$ bool
% where \\

%invHoldForRule2 s f  r $\equiv$  (  formEval  (preCond f  (act r)) s  =  formEval f s\\
%\end{specification}

%\vspace{2mm}
% \begin{specification}
%definition   invHoldForRule3::
%state $\Rightarrow$ formula $\Rightarrow$ rule $\Rightarrow$formula set$\Rightarrow$ bool\\

% invHoldForRule3 s f r fs  $\equiv$\\
%  (let pref=preCond f (act r) in\\
%  ( $\exists$f'. f' $\in$ fs $\wedge$  (formEval   (andForm (pre r)  f') s$\longrightarrow$
% formEval  pref s)))\\
%\\
%abbreviation invHoldForRule::
%state $\Rightarrow$formula $\Rightarrow$ rule $\Rightarrow$ (formula set) $\Rightarrow$ bool
% where\\

%invHoldForRule s inv0 r invs $\equiv$\\
%    invHoldForRule1 s inv0 r $\vee$  invHoldForRule2 s inv0 r $\vee$
 %  invHoldForRule3 s inv0 r invs\\




%\%end{specification}

We can view the relation $\mathsf{invHoldForRule}(s, f,r,fs)$ in two ways. Firstly it defines some causality relation
between $f$, $r$, and $fs$.  $\mathsf{invHoldForRule}_1(s,f, r)$
  means that after rule $r$ is executed,
 $f$ will be true immediately;   $\mathsf{invHoldForRule}_2(s,f, r)$ specifies that
 $\mathsf{preCond}(S,f)$ is equivalent to $f$, intuitively this means that none of state variables in $f$ is
 changed, and the execution of statement $S$ does not affect the
 evaluation of $f$.
 $\mathsf{invHoldForRule}_3(s,f, r,fs)$ states
  that  there exists another invariant $f' \in fs$ such that
  the conjunction of the guard of $r$ and $f'$ implies the precondition  $\mathsf{preCond}(S,f)$.
Intuitively, $\mathsf{invHoldForRule}(s, f, r, fs)$ defines a causal
relation, which can guaranttee that if each of formula in $fs$ holds
before the execution of the rule $r$, then  $f$ also holds after the
execution of the rule $r$. Secondly the relation
$\mathsf{invHoldForRule}(s, f, r, fs)$ can also be regarded as a
special kind of inductive tactics, which can be applied to prove
each formula in $fs$ holds at each inductive protocol rule cases. The most important of all is that the three kind of inductive tactics can be done by a theorem prover, which is the cornerstone of our work.



A consistency relation $\mathsf{consistent}( invs,ini, rs)$,
 which holds between a protocol $(inis,rs)$ and
a set of invariants $invs=\{inv_1,\ldots, inv_n\}$,  is defined as
follows:
\begin{definition}
we define a relation $consistent::formula~ set \times formula~ set
\times rule ~set \Rightarrow bool$.
 $consistent( invs,ini, rs)$ holds if the following conditions hold:
\begin{enumerate}
\item for all formulas $inv\in invs$ and $ini\in inis$ and all states $s$,
$s \models ini$ implies $s \models inv$;
\item for all formulas $inv\in invs$ and rules  $r \in rs$ and all states $s$,  $\mathsf{invHoldForRule}(s, inv, r, invs   )$
\end{enumerate}
\end{definition}

%Intuitively, the above definition specifies that:
%\begin{itemize}
%\item For any invariant $inv \in invs$,
%initializing predicate $ini \in ini$, and state $s$, if $ini$ is
%evaluated true at state $s$, then $inv$ is also evaluated true at
%state $s$.

%\item For any invariant $inv \in invs$, $r$ in the rule set
%$rs$, either one of the following five types of relation holds,
%i.e., $\mathsf{invHoldForRule_{1-3}}inv r$.

%\end{itemize}

%For instance,

\begin{example}\label{example2}
Let us define a set of auxiliary invariants:

\begin{specification}
invOnXC(i)  $\equiv$ $\negc$(x $\doteq$ true $\andc$ n[i]$\doteq$ C)   \ \ \

invOnXE(i)   $\equiv \negc$ (x $\doteq$ true$\andc$ n[i] $\doteq$ E)  \\


aux$_1$(i,j)   $\equiv \negc$ ( n[i]$\doteq$ C$\andc$n[j] $\doteq$ E)   \ \ \

aux$_2$ (i,j) $\equiv \negc$  ( n[i]$\doteq$ E$\andc$n[j]$\doteq$ C)\\

  pinvs(N)$\equiv$ \{f. $\exists$ \iInv1 \iInv2. \iInv1 $\le$ N $\wedge$ \iInv2 $\le$ N $\wedge$ \iInv1 $\ne$ \iInv2 $\wedge$   f =mutualInv   \iInv1 \iInv2) \\
 $ \vee(\exists$ \iInv1. \iInv1 $\le$ N $\wedge$  f =invOnXC  \iInv1)   \\
$\vee(\exists$ \iInv1. \iInv1 $\le$ N $\wedge$  f= invOnXE \iInv1)    \\
$\vee(\exists$ \iInv1 \iInv2. \iInv1 $\le$ N $\wedge$ \iInv2 $\le$ N $\wedge$ \iInv1 $\ne$ \iInv2 $\wedge$ f =  aux1  \iInv1 \iInv2) \\
$\vee(\exists$ \iInv1 \iInv2. \iInv1 $\le$ N $\wedge$ \iInv2 $\le$ N $\wedge$ \iInv1 $\ne$ \iInv2 $\wedge$ f =  aux2  \iInv1 \iInv2) \}.

\end{specification}
\begin{itemize}
\item  $\mathsf{invHoldForRule_1 }(s,\mathsf{invOnXC}( 1),
\mathsf{crit}(1))$ because $\mathsf{preCond}(\mathsf{act}(\mathsf{crit}(1)),
 \mathsf{invOnXC} (1))=\negc (\mathsf{flase}\eqc\mathsf{true}\andc \mathsf{C}\eqc\mathsf{C})$ which is a tautology;

\item     $\mathsf{invHoldForRule_2 }(s,\mathsf{mutual} (i_1,i_2), \mathsf{crit}(iR_1),(\mathsf{pinvs} (N))$, where $i_1 \neq i_2$,  $i_1 \neq iR_1$, and $i_2 \neq iR_1$.


 \item   $\mathsf{invHoldForRule_3 }(s,\mathsf{mutual} (i_1,i_2), \mathsf{crit}(iR_1),(\mathsf{pinvs} (N))$, where $i_1 \neq i_2$, and $i_1 = iR_1$.
  Since
 $\mathsf{invOnXC}( i_2) \in \mathsf{pinvs} (N)$, $\mathsf{preCond}(\mathsf{act}(\mathsf{crit}(iR_1)),
 \mathsf{mutual} (i_1,i_2))=\negc (\mathsf{C}\eqc\mathsf{C}\andc n[i_2]\eqc\mathsf{C})$.


\item   $\mathsf{invHoldForRule_3 }(s,\mathsf{mutual} (i_1,i_2), \mathsf{crit}(iR_1),(\mathsf{pinvs} (N))$, where $i_1 \neq i_2$, and $i_2 = iR_1$. Since
 $\mathsf{invOnXC}( i_1) \in \mathsf{pinvs} (N)$ implies $\mathsf{preCond}(\mathsf{act}(\mathsf{crit}(iR_1))
 \mathsf{mutual} (i_1,i_2))=\negc (\mathsf{C}\eqc\mathsf{C}\andc n[i_1]\eqc\mathsf{C})$.
% where $i_1 \neq i_2$,  $i_1 \neq iR_1$, and $i_2 \neq iR_1$.
  % because
 %$\mathsf{invOnXC}( i_2) \in \mathsf{pinvs} (N)$, $\mathsf{preCond}(\mathsf{act}(\mathsf{crit}(iR_1)),
 %\mathsf{mutual} (i_1,i_2))=\negc (\mathsf{C}\eqc\mathsf{C}\andc n[i_2]\eqc\mathsf{C})$,
 %where $i_1 \neq i_2$, and $i_2 = iR_1$.% $  s \models \mathsf{guard}(\mathsf{crit}(i_1)) \andc \mathsf{invOnXC}(i_2)$ implies
% $ s \models \negc (\mathsf{C}\eqc\mathsf{C}\andc n[2]\eqc\mathsf{C})$. Notice that  the guard condition of
% $\mathsf{crit}(1)$ is $n[1]\eqc T \andc x\eqc\mathsf{true}$.
 \end{itemize}
\end{example}



  %It is not diffcult to verify
%$\mathsf{consistent}~ (\mathsf{pinvs}~ N) ~(\mathsf{pini}~N)~
%(\mathsf{prules}~N)$ also holds.



 Suppose that the consistency relation
$\mathsf{consistent}( invs, inis, rs)$ holds, for any $inv \in invs$,
$inv$ holds for any reachable state $s$ such that $s  \in
\mathsf{reachableSet}( ini, rs)$. A so-called
consistency lemma formalizes the essence of the aforementioned causal relation.

\begin{lemma}\label{consistentLemma}%[(consistency lemma)]
 If $P=(ini,rs)$, $\mathsf{consistent}( invs, ini, rs)$, and $s  \in \mathsf{reachableSet}(P)$, %  $\isasymrbrakk\Longrightarrow$
 then   for all $inv$ s.t. $inv \in invs$, $s \models inv $.
\end{lemma}

\section{  {\sf invFinder}}
{\sf invFinder}  works in a semi-proving and semi-searching
way. A queue  $newInvs$ is used to store new invariants found up to now, and the initial value of $newInvs$ is set by the initial invariant formulas we want to verify. Head element $cinv$ of $newInvs$ is popped,  and used to compute the causal relation between  $cinv$ and a parameterized rule $pr$. {\sf invFinder}  analyzes the parameters occurring in $cinv$ and the numbers of parameters of $pr$, then instantiates the parameterized rule into a a set of concrete rules $crs$ with different groups of concrete parameters according to a parameter instantiation policy, each of which represents a case by comparing concrete rule parameters and invariant parameters. For a rule $cr \in crs$,    {\sf invFinder} tries to prove that some consistent
relation exists between them, and automatically
generates a new auxiliary invariant if there is no such an invariant
in the current invariant set, and records the corresponding causal
relation information between the current rule and invariant. If a new invariant is generated, it will be pushed into $newInvs$.  {\sf invFinder} will not stop the above searching process until $newInvs$  is empty.

In order to formulate our parameter instantiation policy, we need introduce the concept of permutation modulo to symmetry relation $\simeq_m^n$,  and a quotient set of $\mathsf{perms}_{m}^{n}$ (the set of all $n$-permutations of $m$) under the  relation.  Here a $n$-permutation of $m$ is ordered arrangement of a $n$--element subset of an $m$-element set $I=\{i. 0<i\le m\}$. We use a list with size $n$ to stand for a $n$-permutation of $m$, whose elemnts are mutually different from each other and taken from $I$. For instance, $[1,2]$ is a 2-permuatation of 3. If $xs_{[i]}=i$ for all $i \le |xs|$, we call it identical permutation, and sometimes is denoted by $1~ \mathsf{upto}~ n$ if $n=|xs|$.

\begin{definition}
Let $m$ and $n$ be two natural numbers, where $n \le m$,  $L$ and $L'$ are two lists which stand for two  $n$-permutations of $m$,
\begin{enumerate}
\item
$L \sim_m^n L' \equiv (|L| =|L'|=n) \wedge (\forall i. i<|L| \wedge L_{[i]} \le m-n \longrightarrow L_{[i]}=L'_{[i]}) $.

\item $L \simeq_m^n L' \equiv L \sim_m^n L' \wedge   L' \sim_m^n L$.

%\item$[[L]]_{m}^{n} \equiv \{L'. L \in \mathsf{perms}_{m}^{n} \wedge L \sim_m^n L'\}$.

\item $\mathsf{semiP}(m,n,S)\equiv (\forall  L \in \mathsf{perms}_{m}^{n} \exists  L' \in S. L \simeq_m^n L' ) \wedge (\forall  L\in S. \forall L'\in S. L \neq L' \longrightarrow \neg  (L \simeq_m^n L' )$.

\item    A set $S$ is called a quotient of the set $\mathsf{perms}_{m}^{n}$ under the relation $\simeq_m^n$ if    $\mathsf{semiP}(m,n,S)$.
\end{enumerate}
\end{definition}

Let us show the intuition behind the $L\simeq_{m+n}^{n}L'$,   $L \simeq_{m+n}^n L' $ means that if we compare any element $L_{[i]}$ with any $j\le m$, the comparing result should be the same as that obtained by comparing $L'_{[i]}$ with $j$, namely  $L_{[i]}=j$ if and only if $L'_{[i]}=j$. For instance, let $L=[2,3]$ and $L'=[2,4]$, then $L \simeq_{4}^2 L' $, for any $0<j\le 2$, we have $L_{[i]}=j$ iff $L'_{[i]}=j$.
\begin{lemma}\label{lemma:simeq1}%[(consistency lemma)]
If $L \simeq_{m+n}^n L' $, then for any $0<i\le |L|$, any $0<j \le m$, $L_{[i]}=j$ if and only if $L'_{[i]}=j$.
\end{lemma}

For a set $S$ s.t. $\mathsf{semiP}(m,n,S)$, we have that

\begin{lemma}\label{lemma:simeqQuotinent}  Let $S $ be a set s.t.  $\mathsf{semiP}(m,n,S)$,
\begin{enumerate}
\item \label{complete}  for any $L \in \mathsf{perms}_{m}^{n}$, there exists a $L' \in S$ s.t. $L \simeq_m^n L'$.
\item \label{distinct} let $L \in S$, $L' \in S$, if $L \ne L'$, then there exists two indice $i \le m$ and $j \le n$ such that $L_{[i]}=j$ and $L'_{[i]}\ne j$.
\end{enumerate}
\end{lemma}

In lemma \ref{lemma:simeqQuotinent}, \ref{complete} shows the completeness of $S$ w.r.t. the set $\mathsf{perms}_{m}^{n}$ under the relation $\simeq$. \ref{distinct}  the distinct between two different elements in $S$. Intuitively, $S$ has completely enumerated a complete case analysing patterns according to the aforementioned  comparing scheme between elements of $L$ with numbers $j<n-m$, and each. This intuition has been illustrated by the following example.

\begin{example}
Let $m=2$, $n=1$, $S=\{[1],[2],[3]\}$. $S$ be a set s.t.  $\mathsf{semiP}(m,n,S)$,  let $LR$ be an element in $S$, there are three cases:
\begin{enumerate}
\item $LR=[1]$: it is a special case where $LR_{[1]}=1 $;
\item $LR=[2]$: it is a special case where $LR_{[1]}=2 $;
\item $LR=[3]$: it is a special case where $LR_{[1]}\ne 1$ and $LR_{[1]}\ne 2$.
\end{enumerate}
\end{example}

\begin{definition}
A  concrete invariant formula $cinv$ is normalized if one of the following conditions hold:
\begin{itemize}
\item there exists a parameterized invariant $pinv$ and an identical permutation $LI$ with $|LI|>0$ such that $cinv=pinv(1,...~|LI|)$;
\item no array variable occurs in $cinv$;
\end{itemize}
\end{definition}

For a normalized $cinv$ which array variables occurs, it is a result by instantiating $pinv$ by a parameter list which is an identical permutation $LI$. Namely, the $j-th$ parameter is $j$ itself. Thus $LI_{[j]}=j$, and $LR_{[i]}=j$ (or $LR_{[i]}\ne j$) is equivalent to $LR_{[i]}=LI_{[j}]$ (or $LR_{[i]}\ne LI_{[j}]$), which is a factor to specify a case by comparing $LR_{[i]}$ with $LI_{[j}]$ .  All the auxiliary invariant formulas will be in a normalized form, and checked with any parameterized rule whether some kind of causal relation hold between them.


%{\bf Our Parameter Instantiation Policy:}
Let $cinv$  be a normalized concrete invariant, $pr$ be a parameterized rule, $m$ be the number of actual parameters occurring in $cinv$, and $n$  be the number of formal parameters occurring in $pr$,  our policy is to compute the set  $\mathsf{cmpSemiperm}(m+n,n )$, and use elements of it as a group of parameters to instantiate $pr$ into a set $crs$ of concrete rules.  For instance, for the invariant $\mathsf{mutualInv}(1,2)$, three groups of parameters [1], [2], [3] will be used to instantiate $\mathsf{crit}$ respectively, each of which will be used to check the consistency relation between it and $\mathsf{mutualInv}(1,2)$.


For a  $cinv$ and a rule $r \in crs$, the core part of the {\sf invFinder} tool is shown in Algorithm \ref{alg:invfinderI}. It needs to call two oracles. The first one, denoted by {\tt chk}, checks whether a ground formula is an invariant Such an oracle can be implemented by firstly translating the formula into a formula in SMV, and then calling SMV to check whether it is an invariant  in a given small reference model of the protocol. If  the reference model is too small to check the invariant, then the formula will be checked by Murphi in a big reference model.  The second oracle, denoted by {\tt tautChk}, checks whether a formula is a tautology. Such a tautology checker is implemented by translating the formula into a form in the SMT (abbreviation for SAT Modulo Theories) format, and then calls an SMT solver such as Z3 to check it.

%Besides the two oracles which are passed as parameters,
There are   parameters in the algorithm \ref{alg:invFinder-I}, including a rule instance $r$, an invariant $inv$, a sets of invariants $invs$.  The sets $invs$   stores the auxiliary invariants constructed up to now. The algorithm   searches for new invariants and    constructs the causal relation between the rule instance $r$ and the invariant $inv$.
The returned result is a pair of formula option,    and causal relation item between $r$ and $inv$. A formula option value $NONE$ denotes that no new invariant is found; and $SOME(f)$ that a new auxiliary invariant $f$ is searched.


\begin{algorithm}\label{alg:invFinder-I}

\caption{Core Searching Algorithm: $coreFinder$}\label{alg:invfinderI}

\KwIn{  $r$, $inv$, $invs$   }

\KwOut{A formula  option $f$, a new causal relation $rel$}

{
    $g\leftarrow $the guard of r, $S\leftarrow $the statement of r\;

    $inv'\leftarrow preCond(inv, S)$\; \label{line:preCondComp}

    \If{$inv=inv'$}
    {
    $relItem\leftarrow (r, inv, invRule_2,-)$\;
    \Return $(NONE,  relItem )$\;
    }
    \ElseIf{$tautChk(g\rightarrow inv')=true$}
    {
    $relItem\leftarrow (r, inv, invRule_1,-)$\;
    \Return $(NONE,  relItem )$\;
    }
    \Else
    {
    $candidates\leftarrow subsets(decompose(dualNeg(inv')\andc g))$\;
    $newInv\leftarrow choose(chk,candidates)$\;
    $relItem\leftarrow (r, inv, invRule_3,newInv)$\;
    \If{$isNew(newInv,  invs)$}
    {
    $newInv \leftarrow  normalize(newInv)$\;%$ and insert it into the head of $newInvs$\;
    \Return $(SOME(newInv),   relItem )$\;
    }
    \Else{\Return $(NONE,  relItem )$\;}
    }
}

%}

\end{algorithm}


%{\sf invFinder} is implemented by FL, which is an excellent STE-tool
%  The above function {\sf findInvsFromRule} tries to find new
%invariants and construct the causal relation between the rule
%instance $rule$. %The statement {\tt
%cond => te|fe} is an abbreviation of the if-then-else expression
%that if $cond$ is true then $te$ else $fe$.
%Parameters $newInvs$, $invs$, and $casRel$ are new invariants, invariants, and all the
%causal relations constructed up to now, the above oracle functions
%are also passed as parameters.  % Causal relations  are still not
%checked between the ones in $newInvs$ and rules.
%

Now let us explain the body of $coreFinder$. After computing the pre-condition $ inv'$ in line \ref{line:preCondComp}, which is the weakest precondition of the input formula $inv$ w.r.t. $S$, and takes further operations according to the cases it faces with:
%Algorithm {\sf invFinder-I} performs case analysis on $inv'$:

\begin{description}
\item[(1)]  if $ inv=inv'$,
 which means that statement $S$ does not change $inv$, then no new invariant is created, and  new causal
relation item marked with tag {\tt invHoldForRule$_2$} is recorded
between $r$ and $inv$, but at this moment there are no new
invariants to be added; for instance, let $ r=\mathsf{crit} (3)$,  $ inv=\mathsf{mutualInv}(1,2)$, thus
$inv'=\mathsf{preCond}(S,inv)=inv$, then a pair  $ (\mathsf{NONE}, ( crit(3), inv, \mathsf{invHoldForRule}_2,\_))$ will be returned, where $NONE$ means no new invariant formula is returned.

\item[(2)] Secondly, if $\mathsf{ tautChk}$ verifies that $g \dashrightarrow inv'$ is a tautology, then  no new invariant is created, and
the new causal relation item marked with tag
$ \mathsf{invHoldForRule}_1$ is recorded between $r$ and $inv$. For instance, let $r=\mathsf{crit}(2)$, $inv=\mathsf{invOnXC}(1)$,
 $inv'=\mathsf{preCond}(S,inv)=\neg(\mathsf{false }\eqc \mathsf{true} \andc n[1] \eqc \mathsf{C})$, obviously, $
g \dashrightarrow inv'$ holds forever because $inv'$ is always evaluated true,
 thus a pair $(\mathsf{NONE},  (\mathsf{crit}(2), inv, \mathsf{invHoldForRule}_1,\_))$ will be returned.


 \item[(3)] Thirdly, if neither of the above two cases holds, then a new auxiliary invariant $newInv$ will be constructed, which will make the causal relation $ \mathsf{invHoldForRule}_3$  to hold. The candidate set is $subsets(decompose(dualNeg(inv')\andc g))$, where $decompose(f)$ decompose $f$ into a set of sub-formulas $f_i$  such that each $f_i$ is not of a conjunction form and $f$   is semantically equivalent to $f_1 \andc f_2 \andc ... \andc f_N$. $dualNeg(\negc f)$ returns $f$. $subsets(S)$ to denote the power set of $S$.
%The construction of the auxiliary invariant is introduced better after giving some definitions. A formula $f$ can be composed into a set of sub-formulas $f_i$, denoted as $decompose(f)$, such that each $f_i$ is not of a conjunction form and $f$   is semantically equivalent to $f_1 \andc f_2 \andc ... \andc f_N$.  $f_i$ usually is an atomic formula in our work after decomposition. For a formula $f$, we use $subsets(f)$ to denote the power set of $decompose(f)$, which contains all subsets of $decompose(f)$. $dualNeg(\negc f)$ returns $f$. The $\mathsf{ normalize}(f)$ function normalizes the numbering order of the use of parameters in the invariant $inv$.
%The result formula should be in  a normal form, whose parameters
%  always start from 1, and increase one by one if there are more
%  parameters. E.g.,  $\negc (x\eqc\mathsf{true} \andc n[1]\eqc\mathsf{C})$ is normalized, but
%  $\negc (x\eqc\mathsf{true} \andc n[2]\eqc\mathsf{C})$  not. The implementation of $\mathsf{ normalize}$ firstly compute a protype of $f'$,  which is obtained by substituting concrete parameters with different  e index variables $i_1$, ...$i_n$ in a pre-order traversal of the syntax of $f$, where $n$ is  the number of concrete parameters occurring in $f$ , then the returned result by $normalize$ is the formula which is obtained by substituting index variables $i_1$, ...$i_n$ with concrete indexes 1,...,$n$. Namely, we can see a normalized formula is obtained by substituting formal index variables with an identical permutation $1~ \mathsf{upto}~ n$.
A proper formula is chosen from the candidate set to construct a new invariant $newInv$. This is accomplished by the {\tt choose} function, which calls the oracle {\tt chk} to verify whether a formula is an invariant in the given reference model. After $newInv$ is chosen, the function $isNew$ checks whether this invariant is new w.r.t. $newInvs$ or $invs$. If this is the case, the invariant will be normalized, and then be  added into $newInvs$, and the new causal relation item marked with tag {\tt invRule$_3$} will be added into the causal relations. Here, the meaning of the word ``new" is modulo to the symmetry relation. For instance,   $\mathsf{mutualInv}(1,2)$ is equivalent to
$\mathsf{mutualInv}(2,1)$ in a symmetry view.  Let $ invs=\emptyset$, $ r=\mathsf{crit}(1)$, $ inv=\mathsf{mutualInv}(1,2)$,
$ inv'= \mathsf{preCond}(S,inv)=\negc(true\eqc true \andc n[2]\eqc C)$, from all the subsets of $\{n[1]\eqc T, x\eqc true, n[2]\eqc C\}$, the $ \mathsf{choose}$ oracle selects the subset $\{ x=true, n[2]\eqc C\}$ combines all the item in this candidate, then constructs a new invariant $inv_0= \negc(x\eqc true \andc
   n[2]\eqc C)$. After   normalization, the new invariant   $\negc(x=true \andc
   n[1]\eqc C)$  and  a  relation item $ (crit(1),   \mathsf{invHoldForRule}_3, inv_0)$ will be returned.


\end{description}

%Roughly speaking, the top level of {\sf invFinder} works as follows: a queue  $newInvs'$ is used to store new invariants found, and the initial value of $newInvs'$ is set by the initial invariant formulas we want to verify. Head element of $newInvs'$ is pushed, and used to check the consistency relation with all the parameterized rules.  $\mathsf{InvFinder}$ is iteratively called to compute new invariant formulas and relation items. This searching procedure is not finished until no new invariant is searched.

For instance, let $PR=\{try, crit, exit, idle\}$, $invs=\{mutualInv(1,2)\}$,    the output of the {\sf invFinder}, which is stored in file {\tt mutual.tbl},  is shown in Table
\ref{table:groundCausalRelation}. In the table,  each line records the    index of a normalized   invariant, name of a parameterized rule, the rule
  parameters to instantiate the rule, a causal relation between
  the ground invariant and a kind of causal relation which involves the kind and proper formulas
  $f'$   in need (which are used to construct
      causal relations $\mathsf{invHoldForRule}_3$). The auxiliary invariants found by {\sf invFinder} includes: $\mathsf{inv_2}  \equiv  \negc (\mathsf{x} \eqc true  \andc  n[1]=C)$, $\mathsf{inv_3}    \equiv \negc  ( n[1]=C \andc n[2]=E)$,
$\mathsf{inv_4}  \equiv  \negc (x \eqc \mathsf{true}  \andc  n[1]\eqc \mathsf{E})$,   $\mathsf{inv_5}    \equiv \negc  ( n[1]\eqc \mathsf{C} \andc n[2] \eqc \mathsf{C})$.  \footnote{The names $\mathsf{mutualEx}$ and $\mathsf{invOnX1}$ in
  this work are just for easy-reading, their
 index here is generated  in some order by {\sf invFinder}}.



 \begin{table}[!t]\label{table:groundCausalRelation}
\centering \caption{A fragment of output of {\sf invFinder}} % {\tt
%simpMutual.tbl}
\begin{tabular}{|c|c|c|c|c|  }
\hline
  rule& ruleParas&inv&causal relation &   f'  \\
\hline
  .. & ..&.. &..&.. \\

\hline
  crit  & [1]&mutualInv(1,2)& invHoldForRule3 &invOnXC(2) \\
\hline
  crit &[2]& mutualInv(1,2)& invHoldForRule3 &invOnXC(1)  \\
\hline
  crit & [3]& mutualInv(1,2) & invHoldForRule2  & \\
\hline
  .. & ..&.. &..&.. \\

\hline
  crit  & [1]&invOnXC(1) & invHoldForRule1 &\_ \\
\hline
  crit &[2]& invOnXC(1) & invHoldForRule1 &\_  \\
\hline
\end{tabular}
\end{table}

\section{Generalization}
%From this section, our modelling language has been extended to HOL (Higher-order Logic) provided by Isabelle, which not only include the language in Section \ref{sec:protocolSyntax}, but also higher-order logic features. This is not surprising because our formal theory for a parameterized instance of a protocol is done in HOL/Isabelle.  In order to include the theory formally in section \ref{sec:protocolSyntax} and \ref{sec:causal_rel}, we define a Isabelle theory {\tt cache.thy}.

Intuitively, generalization means that a concrete index (formula or rule) is generalized into a set of concrete indice (formulas or rules), which can be formalized  by a symbolic index (formula or rules) with side conditions  specified by   constraint formulas.     In order to do this, we  adopt a new constructor to model symbolic index or symbolic value $\mathsf{symb}(str)$, where $str$ is   a string.  We use $\mathtt{N}$ to denote $symb("N")$, which formalizes the size of an parameterized protocol instance. A concrete index $i$ can be transformed into a symbolic one by some special strategy $g$.   Namely $symbolize(g,i)=symb(g(i))$. In this work, two special transforming function $fInv(i)="iInv"\cat itoa(i)$ and $fIr(i)="iR"\cat itoa(i)$, where $itoa(i)$ is the standard function transforming an integer $i$ into a string. We use  special symbols $\mathtt{\iInv_i}$  to denote $symbolize(fInv,i)$;  and $\mathtt{\iR_i}$ to denote $symbolize(fIr,i)$. The former formalizes a symbolic parameter of a parameterized   formula, and the latter    a symbolic  parameter of a parameterized rule. Accordingly, we define $symbolize2f(g,inv)$ (or  $symbolize2r(f,r)$), which returns the symbolic transformation result to a concrete formula $inv$ (or rule $r$) by replacing a concrete index $i$ occurring in $inv$ (or $r$) with a symbolic index $symbolize(g,i)$.


There are two
main kinds generalization in our work: (1) generalization on model constraints, which is specifying that any parameter index should be not greater than the instance size $\mathtt{N}$, and different parameters to instantiate a parameterized rule (formula) should be different. They are rather straightforward, and are put in the appendix; (2) generalization  for generation of case-splittings in the proofs, e.g., $iR_1 = \iInv_1$ or $iR_1 = \iInv_2$  stand for case splitting by comparing  a symbolic rule parameter $iR_1$ and invariant parameters $\iInv_1$ and $\iInv_2$. %These formulas should be formalized in HOL.


\begin{definition}
Let $LR$ be a permutation s.t. $|LR|>0$, which represents a list of actual parameters to instantiate a rule,    let $LI$  be a  permutation $|LI|>0$,  which  represents a list of actual parameters to instantiate a normalized invariant, we define:
\begin{enumerate}
\item symbolic comparison condition generalized from comparing $LR_{[i]}$ and $LI_{[j]}$: \\
\begin{numcases}{symbCmp(LR,LI,i,j)\equiv }
 \mathtt{\iR_i} = \mathtt{\iInv_j} &   if $LR_{[i]}=LI_{[j]}$\\
\mathtt{\iR_i} \ne \mathtt{\iInv_j} & otherwise
\end{numcases}
%$symbCmp(LR,LI,i,j)\equiv$ if $equality(LR,LI,i,j)$ then $\mathtt{\iR_i} = \mathtt{\iInv_j}$ else $ (\mathtt{\iR_i} \ne \mathtt{\iInv_j})$

\item symbolic comparison  condition generalized from comparing   $LR_{[i]}$ and with all $LI_{[j]}$ :\\
\begin{numcases}{ symbCaseI(LR,LI,i)\equiv }
   symbCmp(LR,LI,i,j)& if $\exists! j.  LR_{[i]}=LI_{[j]}$\\
   forallForm(|LI|,pf)& otherwise
 \end{numcases}
 where  $pf(j)= symbCmp(LR,LI,i,j)$, and $\exists!j.P$ is an qualifier meaning that  there exists a unique $j$ s.t. property $P$;

\item symbolic case  generalized from comparing $LR$ with $LI$ : $symbCase(LR,LI )\equiv forallForm(|LR|,pf)$, where $pf(i)= symbCaseI(LR,LI,i )$;

\item symbolic partition generalized from comparing all $LRS_{[k]}$ with $LI$, where $LRS$ is a list of permutations with the same length: $partition(LRS,LI) \equiv existsForm(|LRS|,pf)$,  where $pf(i)= symbCase(LRS_i,LI)$.

\end{enumerate}
\end{definition}

$symbCmp(LR,LI,i,j)$ defines a symbolic formula  generalized from comparing $LR_{[i]}$ and $LI_{[j]}$; $symbCaseI(LR,LI,i)$  a symbolic formula summarizing the results of comparison  between $LR_{[i]}$  and all $LI_{[j]}$ such that $j \le |LI|$; $symbCase(LR,LI )$ a symbolic formula representing a subcase generalized from comparing all $LR_{[i]}$  and all $LI_{[j]}$; $partition(LRS,LI)$  is a disjunction of subcases $symbCase(LRS_{[i]},LI )$.  Recall the first three lines in Table. \ref{table:groundCausalRelation}, and $LI=[1,2]$ is the list of parameters occurring in $mutualEx(1,2)$
 %\begin{itemize}
 %\item when   $LI=[1]$ is a list of parameters occurring in $invOnXC(1)$
%\begin{itemize}
 % \item $LR=[1]$ is the actual parameter list to instantiate $crit$, $symbCmp(LR,LI,1,1)=(\mathtt{\iR_1} = \mathtt{\iInv_1})$, $symbCase(LR,LI)=symbCaseI(LR,LI,1)=(\mathtt{\iR_1} = \mathtt{\iInv_1})$.

 % \item  $LR=[2]$ is the actual parameter list to instantiate $crit$, $symbCmp(LR,LI,1,1)= (\mathtt{\iR_1} \ne \mathtt{\iInv_1})$, $symbCase(LR,LI)=symbCase(LR,LI,1)=(\mathtt{\iR_1} \ne \mathtt{\iInv_1})$

  % \item let $LRS=[[1],[2]]$, $partition(LRS,LI)= (\mathtt{\iR_1} = \mathtt{\iInv_1}) \vee  (\mathtt{\iR_1} \ne \mathtt{\iInv_1})$
%\end{itemize}
%\item when   $LI=[1,2]$ is a list of parameters occurring in $mutualEx(1,2)$
\begin{itemize}

  \item $LR=[1]$ is the actual parameter list to instantiate $crit$, $symbCmp(LR,LI,1,1)=(\mathtt{\iR_1} = \mathtt{\iInv_1})$, $symbCase(LR,LI,1)=(\mathtt{\iR_1} = \mathtt{\iInv_1})$.

  \item  $LR=[2]$ is the actual parameter list to instantiate $crit$, $symbCmp(LR,LI,1,1)= (\mathtt{\iR_1} \ne \mathtt{\iInv_1})$, $symbCase(LR,LI)=(\mathtt{\iR_1} = \mathtt{\iInv_2})$ becasue $LR_{[1]}=LI_{[2]}$.


 \item  $LR=[3]$ is the actual parameter list to instantiate $crit$, $symbCmp(LR,LI,1,1)=\neg(\mathtt{\iR_1} = \mathtt{\iInv_1})$, $symbCase(LR,LI)=symbCaseI(LR,LI,1)= (\mathtt{\iR_1} \ne \mathtt{\iInv_1}) \wedge  (\mathtt{\iR_1} \ne \mathtt{\iInv_2})$ because neither $LR_{[1]}=LI_{[1]}$ nor $LR_{[1]}=LI_{[2]}$.

  \item let $LRS=[[1],[2],[3]]$, $partition(LRS,LI)= (\mathtt{\iR_1} = \mathtt{\iInv_1}) \vee (\mathtt{\iR_1} = \mathtt{\iInv_2}) \vee ( (\mathtt{\iR_1} \ne \mathtt{\iInv_1}) \wedge  (\mathtt{\iR_1} \ne \mathtt{\iInv_2}))$
\end{itemize}
%\end{itemize}

Note that $partition(LRS,LI)$ is a complete partition if it is a tautology. In the above example, the two partitions are both complete. If we see a line as a concrete test case for some concrete causal relation in table \ref{table:groundCausalRelation},  then $symbCase(LR, LI)$ is an abstraction predicate to generalize the concrete case. Namely, if we transform $symbCase(LR, LI)$ by substitute $\mathtt{\iInv_i}$ with $LI_{[i]}$, and $\mathtt{\iR_j}$ with $LR_{[j]}$, the result is semantically equivalent to true. %If another $LR'$ and $LI'$ are permutations s.t.  $symbCase(LR', LI')$, then the same kind of causal relation  should hold, thus we can apply the same proof tactics to prove.

The last thing is how to generalize the formula $f'$ in a line of table \ref{table:groundCausalRelation} where the causal relation $\mathsf{invHoldForRule_3}$ holds. An index occurring in $f'$ can   occur in the invariant formula, or in the rule. We need look up the parameters occurring in the formula  or in the rule to determine the   transformation.

\begin{definition}
Let $LI$ and $LR$ are two permutations,  $find\_first(L,i)$ returns the least index $j$ s.t. $L_{[i]}=j$ if there exists such an index; otherwise returns an error.
$lookup(LI,LR, i)\equiv$
 if $i\in LI$ then $\mathtt{\iInv_{find\_first(LI,i)}}$ else $\mathtt{iR_{find\_first(LR,i) }}$
%$symbolize'(f,LI,LR) $ is a formula transformed from $f$ by substituting each $i$ with $lookup(LI,LR, i)$.
\end{definition}

$lookup(LI,LR, i)$ returns the symbolic index transformed from $i$ according to whether $i$ occurs in $LI$ or in $LR$, which defines the generalization strategy into the concrete index $i$.
For instance, let $LI=[1,2]$, $LR=[2]$, then  $lookup(LI,LR, 2)=\mathtt{\iInv_2}$, and  $invOnXC(2)$ is transformed into $\neg(x\eqc true \wedge n[\mathtt{\iInv_2}]\eqc C)$ by the strategy $lookup$.

%Let $LI=[1]$, $LR=[1,2]$, then $symbolize'(mutualInv(1,2),LI,LR)$ is $\neg(n[\iInv_1]\eqc C \wedge n[\iR_2]\eqc C)$. Here the latter exmple is only  artificial because there is no rule which will be instantiated by $[1,2]$. But for complex protocols like FLASH, the case exits where a rule with two parameters and an invariant with only a parameter exits.
For convenience in generating Isabelle proofs,      %a formula $\mathsf{diffConGen}~(\mathsf{paraMumsOfInv}~cr~"iR"$ to specify with the assumptions that mutual difference between the parameters of the symbolic invariant.  Here we assume that the string $"iR"$ does not occur in $cr$.
a table $symbCausalTab$ is generated, which  stores causal relation between a parameterized rule and an  invariant w.r.t. a  size $N$. An entry of the table is referenced by concatation of the name of a rule and an invariant formula. Such an entry is a record containing fields {\tt symbCases} and  {\tt relationItems}, and created by collecting all the lines on the concrete relation items between the rule and the invariant. {\tt symbCases}  stores the list of symbolic cases each of which is derived by $\mathtt{symbCase}(LR, 1~\mathsf{upto}~n)$, where $LR$ is the rule parameters, and $n$ the number of parameters occuring in the invariant. relations store a list of generalized causal relation items.  For instance, for the rule $crit$ and $inv5$, a record $(|\mathtt{symbCases}=[\mathtt{\iR_1} = \mathtt{\iInv_1},\mathtt{\iR_1} = \mathtt{\iInv_2},(\mathtt{\iR_1} \ne \mathtt{\iInv_1}) \wedge  (\mathtt{\iR_1} \ne \mathtt{\iInv_2})]$; $\mathtt{relationItems}= [invHoldForRule_3(f_1')$,$invHoldForRule_3(f_2')$,$invHoldForRule_2]|)$, where $f_1'=symbolize2f(lookup([1,2],[1]),invONXC(2))$, and $f_2'=symbolize2f(lookup([1,2],[2]),invONXC(1))$.


%-------------------------------------------------------------------------
\section{Automatical generation of Isabelle proof by {\tt proofGen}}
%-------------------------------------------------------------------------
%\subsection{An  Example of Generated Isabelle/Script} \label{subsection:introOfIsabelleProof}
A formal model for a protocol case in a theorem prover like Isabelle
includes the definitions of constants and rules and invariants,
lemmas, and proofs. An overview of the hierarchy  of the formal proof scripts of  is
shown in Fig \ref{fig:arch}.% \begin{figure}[!ht]\label{fig:isabelleProofIntro}
% \centering %
 %\vspace{-0.8cm}
%\includegraphics[width=1.0\textwidth]{isabelleScript.pdf}
%\vspace{-0.5cm}
% \caption{An overview of an Isabelle proof}

%\end{figure}

In detail, the proof script is divided into   parts as follows: (1) Definitions of protocol under case study including enumerating datatypes; definitions of formally parameterized invariant formulas, and the set of all actual invariants w.r.t. a protocol instance; definitions of formally parameterized rules, and the set of all actual rules w.r.t. a protocol instance; definitions of specification of the initial state; (2) A lemma  such as {\tt rule$_i$\_Vs\_inv$_j$} on a causal relation of a rule and an invariant; (3) A  Lemma  such as {\tt rules\_inv$_i$} on causal relations for all rules in  the rule set  and an invariant. (4) A lemma {\tt rules\_invs} on a causal relation for all rules in  the rule set  and all invariants in the invariant set. (4) A Lemma such as {\tt iniImply\_inv$_i$} on a fact that an invariant {\tt inv$_i$}  hold at the initial state defined by the specification of the initial state. (5) A lemma {\tt on\_inits} proves that for all invariants they hold at the initial state of the protocol. (6) Main theorem  proving that any invariant formula  holds at any reachable state of the  N-parameterized FLASH protocol instance.
 

%\subsubsection{Lemmas for Causal Relation between Rules and Invariants}
 % Now we discuss how to use records on {\tt crit} and {\tt inv$_1$} in the tables   $symbInvs$, $symbRules$, and $symbCausalTab$ to generate a lemma to prove that causal relation hold between   crit and   $inv_1$, which will be applied in the proof of main lemma.
 A lemma at the bottom level, specifies that causal relation hold between  a rule like  {\tt crit} and a parameterized rule like  $inv_1$, An  example lemma
{\tt critVsinv$_1$} and its proof in Isabelle in the {\tt mutualEx} protocol, is illustrated as follows:


\begin{specification}
%\begin{algorithm}
%\caption{Generating a kind of proof which is according with a relation tag of $invHoldForRule_{1-3}$ : rel2proof}\label{lemma:causal relation lemma}
1lemma critVsinv1:\\
2  assumes  a1: $\exists$ \iR1. \iR1 $\le$ N $\wedge$ r=crit \iR1 and \\
  a2: $\exists$  \iInv1 \iInv2. \iInv1 $\le$ N $\wedge$ \iInv2 $\le$ N $\wedge$ \iInv1 $\neq$ \iInv2 $\wedge$ f=inv1  \iInv1 \iInv2\\
3  shows  invHoldForRule s f r (invariants
  N)\\
4  proof -\\
   from a1 obtain \iR1 where a1:\iR1 $\le$ N $\wedge$ r=crit \iR1 \\
\twoSpaces   by blast\\
   from a2 obtain \iInv1 \iInv2 where \\
   a2: \iInv1 $\le$ N $\wedge$ \iInv2 $\le$ N $\wedge$ \iInv1 $\neq$ \iInv2 $\wedge$ f=inv1  \iInv1 \iInv2\\
\twoSpaces   by blast \\
5  have iR1=\iInv1 $\vee$ \iR1=\iInv2 $\vee$ (\iR1 $\ne$ \iInv1 $\wedge$  \iR1 $\ne$ \iInv2) by auto\\

6  moreover\{assume  b1:\iR1=\iInv1\\
7  \twoSpaces have invHoldForRule3 s f r (invariants N)\\
 \twoSpaces  \twoSpaces   proof(cut\_tac a1 a2 b1, simp, rule\_tac x=$\negc$ (x=true $\andc$ n[\iInv2]=C)  in exI,auto)qed\\
8  \twoSpaces then have invHoldForRule s f r
(invariants
  N)
by auto\}\\

9  moreover\{assume  b1:iR1=\iInv2\\
10 \twoSpaces have invHoldForRule3 s f r (invariants N)\\
 \twoSpaces \twoSpaces   proof(cut\_tac a1 a2 b1, simp, rule\_tac x=$\negc$ (x=true $\andc$ n[\iInv1]=C  in exI,auto)qed\\
11 \twoSpaces then have invHoldForRule s f r (invariants
  N)
by auto\}\\

12   moreover\{assume  b1:(\iR1 $\ne$  \iInv1 $\wedge$   \iR1 $\ne$  \iInv2)\\
13 \twoSpaces have invHoldForRule2 s f r  \\
  \twoSpaces \twoSpaces  proof(cut\_tac a1 a2 b1,  auto) qed\\
14 \twoSpaces then have invHoldForRule s f r
(invariants
  N)
by auto\} \\

15ultimately show invHoldForRule s f r
(invariants N) by blast\\
16qed\\
%\end{algorithm}
\end{specification}

In the above proof, line 2 are assumptions on the parameters of the invariant and rule, which are composed of two parts: (1) assumption {\tt a1} specifies that there exists an actual parameter {\tt \iR1} with which {\tt r} is a rule obtained by instantiating {\tt crit}; (2) assumption {\tt a2} specifies that  there exists   actual parameters {\tt \iInv1} and {\tt \iInv2} with which {\tt f} is a formula obtained by instantiating {\tt inv1}.
 %(1) the facts that all parameters of this invariant should be less than the parameter $N$; %(2) the facts that all parameters of this invariant should be less than the parameter $N$; (3) the constraints of he mutual difference between parameters of the invariant (rule), which can %be looked up in the field of those records  from the table $symbInvTab$ ($symbRuleTab$) by the invariant (rule) name {\tt inv1} ({\tt crit}), which specifies that the mutual difference %between two parameters.
Line 4 are two typical  proof patterns forward-style which fixes local variables such as {\tt \iR1} and new facts such as {\tt a1: iR1 $\le$ N $\wedge$ r=crit \iR1}. From line 5, the remaining parts of the proof is a typically readable one in Isar style \cite{Wen99}, which uses calculation
reasoning such as {\tt moreover} and {\tt ultimately} to do  case analysis.
Line 5 splits cases of {\tt iR1} into all possible cases by comparing
{\tt \iR1} with {\tt \iInv1} and {\tt \iInv2}, which is in fact characterized by $partition([1],[2],[3]],[1,2])$. Lines 6-14  proves    these cases one by one: Lines 6-8 proves the case where {\tt iR1=\iInv1}, line 7 first proves that the causal relation $invHoldForRule_3$ holds by supplying a formula, which is $symbolize'(invOnXC(2),[1,2],[1])$. %Notes that $invOnXC(2)$ is the $f'$ which is provided in the last column of the line.
From the conclusion at line 7, line 8 furthermore proves the causal relation $invHoldForRule$ hold; Lines 9-11 proves the case where {\tt iR1=\iInv2}, proof of which is similar to that of case 1; Lines 12-14 the case   where neither {\tt iR1=\iInv1} nor {\tt iR1=\iInv2}. Each proof of a subcase is done in a block {\tt moreover b1:asm1 proof1}, the {\tt ultimately}  proof command in line 15 concludes by summing up all the subcases.



\paragraph*{Algorithms of Proof Generator {\sf proofGen}}
A lemma such as {\tt critVsinv1}  is generated by collecting all the records on the invariant {\tt inv1} and rule {\tt crit} in the aforementioned tables.
Due to length limitation, we illustrate the algorithm to generate a key part of the proof of the lemma: the generation of a subproof according to a symbolic  relation tag of $invHoldForRule_{1-3}$, which is shown in Algorithm \ref{alg:proofGenOfReltag}.

\begin{algorithm}
\caption{Generating a kind of proof which is according with a relation tag of $invHoldForRule_{1-3}$ : rel2proof}\label{alg:proofGenOfReltag}
\KwIn{A causal    relation item $relTag$}
\KwOut{  An Isablle proof: $proof$   }

{
 \If{$relTag=invHoldForRule_1$}
  {$proof \leftarrow $ sprintf\\
\twoSpaces"have invHoldForRule1 f r (invariants N)  \\
\twoSpaces         by(cut\_tac a1 a2 b1, simp, auto) \\
\twoSpaces then have invHoldForRule f r (invariants N)  by blast" \; }
 \ElseIf{ $relTag=invHoldForRule_2$}
  {$proof \leftarrow$  sprintf\\
\twoSpaces"have invHoldForRule2 f r (invariants N)
\twoSpaces         by(cut\_tac a1 a2 b1, simp, auto) \\
\twoSpaces then have invHoldForRule f r (invariants N)  by blast" \; }
 \Else{
 \label{label:getFormField}$f' \leftarrow getFormField(relTag)$\;
 $proof \leftarrow$ sprintf\\
\twoSpaces"have invHoldForRule3 f r (invariants N)  \\
\twoSpaces proof(cut\_tac a1 a2 b1, simp, rule\_tac x=\%s  in exI,auto)qed\\
\twoSpaces then have invHoldForRule f r (invariants N)  by blast" (symbf2Isabelle f')"\;}
\Return{proof}
}
\end{algorithm}

In the body of function {\sf rel2proof},  $sprintf$ writes a formatted data to string and returns it.
In line \ref{label:getFormField}, $getFormField(relTag)$ returns the field of formula $f'$ if $relTag=invHoldForRule_3(f')$.  {\sf rel2proof} transforms a symbolic relation tag into a paragraph of proof, as shown in lines 7-8, 10-11, or 13-14. Such a relation tag is stored as an element in {\tt relationTags} field of an entry of $symbCausalTable$.  
If the tag is among $invHoldForRule_{1-2}$, the transformation is rather straight-forward, else the form $f'$ is assigned by the formula $getFormField(relTag)$, and provided to tell Isabelle the formula which should be used to construct the $invHoldForRule_3$ relation. 

\end{document}

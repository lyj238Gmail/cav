\documentclass{llncs}
%%%%%%%%%%%%%%%%%%%%%%
%%%%   PACKAGES   %%%%
%%%%%%%%%%%%%%%%%%%%%%
\usepackage{makeidx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{latexsym}
\usepackage{url}
\usepackage{color}
\usepackage{isabelle}
\usepackage{isabellesym}
\usepackage{theorem}
\usepackage{algorithmic}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
%\usepackage{program}
\usepackage{cases}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%For Isabelle code
\newlength{\fminilength}
\newsavebox{\fminibox}
\newenvironment{fmini}[1][\linewidth]
  {\setlength{\fminilength}{#1\fboxsep-2\fboxrule}%
   \vspace{2ex}\noindent\begin{lrbox}{\fminibox}\begin{minipage}{\fminilength}%
   \mbox{ }\hfill\vspace{-2.5ex}}%
  {\end{minipage}\end{lrbox}\vspace{1ex}\hspace{0ex}%
   \framebox{\usebox{\fminibox}}}

\newenvironment{specification}
{\noindent\scriptsize
\tt\begin{fmini}\begin{tabbing}X\=X12345\=XXXX\=XXXX\=XXXX\=XXXX\=XXXX
\=\+\kill} {\end{tabbing}\normalfont\end{fmini}}
\def \twoSpaces {\ \ }
\def \oneSpace {\ }
\def \eqc {\doteq }
\def \andc {\barwedge }
\def \negc {!}
\def \orc {\veebar }
\def \alt {$/\backslash$ }
\def \cat {\symbol{94}}

\def \dbRight {$\backslash\backslash$}
\def \iInv {iInv}
\def \iR {iR}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%for comments
\newcommand\JP[1]{\textcolor{magenta}{JP: #1}}
\newcommand\lyj[1]{\textcolor{green}{lyj: #1}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Additional math operators
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[colorlinks,
            linkcolor=black,
            anchorcolor=black,
            citecolor=blue,
            urlcolor=black,
            bookmarks=true
            ]{hyperref}

\input{tcilatex}

%=========================================
\begin{document}

\title{ {\sf A Novel Approach to Parameterized verification of Cache Coherence Protocols}}
\titlerunning{A Novel Approach to Parameterized verification of Cache Coherence Protocols}
\author{~}
\authorrunning{~}
\institute{~}

\maketitle
\vspace{-2.6cm}
%-------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------
Parameterized verification of parameterized protocols like cache coherence protocols is important
but hard.   Our tool {\sf paraVerifier} handles this hard problem in
a unified framework: (1) it automatically  discovers auxiliary invariants and the
corresponding causal relations %between invariants and rules
 from a small reference instance of the verified protocol; (2) the above
invariants and causal relation information  can be also  automatically generalized into a parameterized
form to construct a formally parameterized proof in a theorem prover
(e.g., Isabelle). The principle underlying the generalization is the
symmetry mapping. Our method is successfully applied to typical
benchmarks including  snoopy-based and directory-based. Another novel
feature of our method lies in that the last verification result of a
protocol is provided by a formally readable proof.% in a theorem
%prover like Isabelle.

%-------------------------------------------------------------------------
\end{abstract}
%-------------------------------------------------------------------------
%-------------------------------------------------------------------------
\vspace{-1.5cm}
\section{Introduction }
%-------------------------------------------------------------------------
%=========================================
Verification of parameterized concurrent systems is interesting in
the area of formal methods, mainly due to the practical importance
of such systems. Parameterized systems exist in many important
application areas: cache coherence protocols, security systems, and
network communication protocols, \emph{etc}. %In this work, we will
%focus on cache coherence protocols, which play a key role in modern
%computer architectures. They require complex algorithms that must
%deal with asynchrony, unpredictable message delays, and multiple
%communication paths between many clients. Therefore, the highest
%possible assurance for the correctness of these complex
%parameterized systems should be guaranteed by formal reasoning
%techniques.
The real challenge posed by parameterized verification is that the
desired properties should hold in any instance of the parameterized
system, not just for a single protocol instance. Model checking is
automatical but able to verify just an instance of the parameterized
 system. The correctness of the reference instance  does
not formally suffice to conclude the correctness for all instances.
Due to the extreme importance of many parameterized system, it is
preferable to have a proof that the correctness holds for any
instance.

\paragraph*{Related Work} There have been a lot of research papers in the field of  parameterized
verification~\cite{Pnueli1996,Bj√∏rner1997,Arons2001,Pnueli2001,Tiwari2001,Chou2004,Pandav2005,Lv2007,cubicle2011}.
Among them, the `invisible invariants' method, proposed in~\cite{Arons2001},
is an automatic technique for parameterized verification. In this
method, auxiliary invariants are computed in a finite system
instance to aid inductive invariant checking.  % Work~\cite{Arons2001,Lv2007} attempts to automatically
%find invariants. However, the invisible invariants are raw boolean formulas transferred from the reachable sate set of a small finite instance
%of a protocol, which are BDDs computed by TLV (an variant of BDD\_based SMV model checker). They are too raw to have an intuitive meanings. The capacity of the invisible invariant method is seriously limited when computing the reachable  set of invisible invariants for  the inductive checking is not feasible in the case of a large example like FLASH . Until now, the  examples, which can be handled by the "invisible invariant" method, are quite small,  we still can't find successful experiments  on large examples like FLASH with data paths.
The CMP method, which adopts parameter abstraction and guard strengthening, is proposed
in~\cite{Chou2004} for verifying a safety property $inv$ of
a parameterized system.
 An abstract instance of the parameterized protocol %$, % which consists of m + 1
%nodes $\{P_1, \ldots , P_m, P^*\}$ with $m$ normal nodes and one
%abstract node $P^*$, is constructed iteratively. The abstract system
is constructed by a counter-example-guided refinement process.  %However, this method's soundness is only argued in an
informal way. %To the best of our knowledge, no one has
%formally proved its correctness in a theorem prover although the authors argued for a mechanized proof for all the thing of CMP in \cite{Chou2004}. Besides, the analysis of counter-example and generation of new auxiliary invariants usually
% depend on human's deep insightful understanding of the protocol. It is too laborious for people to do these analysis. %and some effective automatic  tool is needed to help people.
%It was demonstrated in
%[7] that this method is powerful enough to handle complex
%cache coherence protocols such as FLASH effectively.





The degree of scalability and automatic is the most important of all to estimate an approach in the field of parameterized verification. For instance, FLASH is a hard real-world benchmark for any proposed method for parameterized verification. Human guidance still plays a key role in the existing successful verification for FLASH in \cite{Park1996a,McMillan2001,Chou2004} up to now.%: °∞if the method works on FLASH, then there is a good chance that it will also work on many real-world cache coherence protocols°± \cite{Chou2004}. However, the existing approaches, which have verified FLASH, need too much human intervention. The first full verification of safety properties of FLASH is done by work in \cite{Park1996a}. Park and Dill  proved the safety properties of FLASH using  PVS \cite{cade92-pvs}. %They introduce the aggressioned FLASH protocol, which
%is in fact an abstracted transaction version of FLASH,   need prove
%the correspondence between the abstract and the original FLASH
%protocol, and then prove the correctness of the abstracted protocol, and subsequently derive the correctness of  the
%original protocol by the correspondence. New   auxiliary state variables
%like {\tt fwdSrc} are   introduced  for verification. Deep human insight for FLASH is needed for both the construction of the aggressioned model  and  introducing new state variables.  Later research on FLASH must also rely on these auxiliary
%variables for verification.
%McMillan applied compositional
%model checking \cite{McMillan2001}  and used Candence SMV  \cite{cadenceSMV} to the verification of both safety and liveness properties of FLASH. In a different context, safety
%properties of German 2000 and FLASH were proved via
%Murphi tool \cite{alanHuMurphi} by adopting CMP method in \cite{Chou2004}. In
%all the three methods mentioned above, auxiliary invariants
%have to be supplied manually. Predicate abstraction based
%methods were applied to verify
%FLASH in \cite{dillPred}. Users need to manually provide plausible properties
%in predicate abstraction and automated predicate discovery
%techniques to find large predicates. So verifying large protocols
%like FLASH using predicate abstraction is also difficult. In contrast to previous work, our work need fewer human's aid in the verification of FLASH.   Both the auxiliary invariants and formal proof are generated automatically, and these   auxiliary invariants have intuitive meanings which can  be used to analyze FLASH.  %  The abstractions
%we used, the reliance on apparently circular reasoning, and the counterexampleguided
%discovery of noninterference lemmas are all deeply influenced by McMillan°Øs
%work.
There are two central problems which need better solution in the parameterized verification for complex protocols like FLASH.  How to find a set of sufficient and necessary invariants
is the core in the field of parameterized verification. It is desirable that the
invariants are provided with less human intervention.
Besides, the theory foundation of a technique of parameterized verification and its
soundness are only discussed in a paper proof style.  We will compare our approach in \ref{sec:experiments}.%For instance,
%the theory contains the apparent circularity in reasoning and
%applying the auxialiary invariants, and is based on the classical
%notion of a so-called simulation proofs \cite{Chou2004}. Frankly speaking, the
%theory itself is not easy to be understood, and  needs to be
%checked mechanically due to its soundness of should be
%guaranteed without conditions.
It is preferable to make all the verification can be formulated in a publicly-recognized trust-worthy framework like a theorem prover\cite{Chou2004}. However,
 theorem proving in a theorem prover like Isabelle usually is interactive, not automatical.

%which are either used for inductive verification or abstraction
%model construction. Therefore, how to find ans use these auxiliary
%invariants is the central problem in the research field of
%parameterized verification.

In order to solve the parameterized
verification of cache coherence protocols in a both automatical and rigorous way, we design a tool {\sf
paraVerifier}, which is based on a a simple but elegant theory.  Three kinds of causal
relations are introduced, which are
essentially special cases of the general induction rule. Then a
so-called consistency lemma is proposed, which is the cornerstone in
our framework. Especially, the theory foundation itself is  verified as a
formal theory in Isabelle, which is the basically formal library to verify protocol case studies. The library provides basical type and constant definitions to model protocol cases and lemmas to prove invariant properties. Therefore the theoretical foundation is
the most rigourous. 

{\sf
paraVerifier} composed of two parts:  an invariant finder {\tt invFinder}
and a proof generator {\tt proofGen}. %In order to verify  that an
%invariant $inv$ holds for any parameterizd instance of a protocol.
Given a protocol $\mathcal{P}$, and a property $inv$. {\sf
paraVerifier} works as follows:
Firstly,  from a reference model of $\mathcal{P}$ with a fixed number
of clients, {\tt invFinder} tries to search
interesting auxiliary invariants and causal relations which are
capable of proving $inv$. This process is guided by the heuristics inspired by constructing auxiliary invariants and causal relations that satisfy 
  consistency relation.


Next, {\tt proofGen}
 uses the output of {\tt invFinder} in the first stage, and
 constructs a a completely parameterized
formal proof which can
be checked automatically in a theorem prover(e.g., Isabelle). %In order to make the proof checking automatical, the basically formal library theory should be imported, and support 


The originality of our work lies in the following aspects:
\begin{itemize}
\item Our work is based on a simple but elegant theory, which glues the two parts of {\sf paraVerifier}. Three kinds of causal
relations are introduced, which are
essentially special cases of the general induction rule. Then a
so-called consistency lemma is proposed, which is the cornerstone in
our framework. On one side, it is heuristics inspired by trying to
construct the consistency relation that guides the tool {\sf
invFinder} to find auxiliary invariants. On the other side, the
consistency lemma gives a general guiding principle to prove
invariants  in the parameterized instance of a cache coherence
protocol. Especially, the theory foundation itself is  verified as a
formal theory in Isabelle, which is the basically formal library to verify protocol case studies. Therfore the theoretical foundation is
the most rigourous.

\item Our verification products are a list of interesting invariants
and a formally readable proof script. Our invariants are visible,
 which can characterize the semantical features of the protocol, and help people to
   precisely
    understand the design of the protocol. %This feature distinguish ours from  the so-called ``the invisible invariants" method clearly.
  Furthermore, the formal proof script not  only models the protocol
rigorously and specifies its properties without any ambiguity, but also
proves them mechanically in the theorem prover. Therefore, it helps us to achieve the highest possible
assurance for formal reasoning of the protocol.

\item Our work is both automatical and scalable. After the protocol is modelled in {\sf paraVerifier}, auxiliary invariants
 are searched automatically,  the formal proof script in Isabelle is also  automatically generated by {\tt proofGen} , and   checked by Isabelle without human guidance. Thus the most automatical degree is preserved when we solve the hard problems of finding invariants and theorem proving, both of which need much human guidance in previous work in this field. Furthermore our tool can handle some hard examples from industry like FLASH protocols, %German2004 protocols,
 and Godson-t protocols.
\end{itemize}

To the best of our knowledge, {\sf paraVerifier} is the first work
that generates automatically formal proofs in a theorem prover for
verification of cache coherence protocols. It is also the first one which automatically
verify safety properties of  full version of FLASH without auxiliary invariants manually provided by people in a theorem prover.




\end{document}
